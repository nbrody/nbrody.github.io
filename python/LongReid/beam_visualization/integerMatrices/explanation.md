# Integer Matrix Search Project

This project implements a tool to find words (sequences of generators) in a specific deformation of $SL(2, \mathbb{Z})$ that result in **integer matrices**.

## Mathematical Context

We are exploring a subgroup of $SL(2, \mathbb{R})$ generated by two matrices, $a$ and $b$, which depend on a parameter $t$:

$$ a = \begin{pmatrix} t & 0 \\ 0 & t^{-1} \end{pmatrix}, \quad b = \begin{pmatrix} 1+t^2 & 2 \\ t & 1 \end{pmatrix} $$

Actually, the code implements a slightly different version to work with integers more easily, likely effectively working with matrices scaled to be integral or working in a specific representation. Looking at `integerMatrices.py`:
- **Generator a**: `[[t, 0], [0, 1]]`  (Determinant $t$)
- **Generator b**: `[[1+t^2, 2], [t, 1]]` (Determinant ?) -> Wait, let's calculate det(b) = $(1+t^2)(1) - 2(t) = 1+t^2 - 2t = (t-1)^2$? No. 
Let's look at the code's matrix definitions again:
`MAT_b = [1 + t^2, 2, t, 1]` -> $1+t^2 - 2t = (t-1)^2 + 2t - 2t$... wait.
$(1+t^2)*1 - 2*t = 1 - 2t + t^2 = (t-1)^2$.

The code aims to find combinations of these matrices (and their inverse-like counterparts) that result in a matrix with **determinant $\pm 1$** (specifically checking `abs(det) == 1`) and integer entries.

## Core Components

### 1. `IntegerMatrixSearch` (Backend Logic)
Located in `integerMatrices.py`.

*   **Goal**: Find words $w$ in the generators $\{a, b, a^{-1}, b^{-1}\}$ such that the resulting matrix $M_w$ has integer entries and determinant $\pm 1$.
*   **Algorithm**: **Beam Search**.
    *   It starts with the Identity matrix.
    *   At each step, it expands the "beam" of most promising matrices by multiplying them by all 4 generators.
    *   **Pruning**: It keeps only the best `BEAM_WIDTH` candidates.
    *   **Scoring**: Candidates are scored based on how "close" they are to being valid integer matrices with determinant 1. The score uses $\log(\det(M))$.
    *   **Canonicalization**: To keep numbers manageable and detect "integer-like" structures, the matrices are divided by common factors related to primes of $t(t-1)$, effectively working in a localized ring or simplifying the search space.
*   **Libraries**: Uses `python-flint` for high-performance arbitrary-precision integer arithmetic (`fmpz_mat`).

### 2. Batch Processing Wrapper
Located in `integerMatricesWrapper.py`.

*   Iterates through integer values of $t$ from 2 to 50.
*   Runs the search for each $t$.
*   Saves up to 100 successful "words" for each $t$ into a JSONL file (`integer_matrices.jsonl`).

### 3. Web Interface
Located in `app.py` and `templates/index.html`.

*   **Flask App**: Provides a web server.
*   **Streaming Results**: Uses **Server-Sent Events (SSE)**. This is crucial because the search is computationally intensive. As the search finds valid words, they are immediately pushed to the browser without waiting for the whole search to finish.
*   **Concurrency**: The search runs in a separate thread to ensure the web server remains responsive.
*   **Frontend**: A modern, dark-themed UI that allows users to configure $T$, Beam Width, and Max Iterations dynamically.

## Summary of Workflow

1.  **User Inputs Parameters**: $T=25$, Beam Width=10000.
2.  **Server Starts Thread**: `IntegerMatrixSearch` begins BFS/Beam search.
3.  **Search Loop**:
    *   Expand current matrices.
    *   Simplify/Canonicalize.
    *   Check if `det == 1`.
    *   If yes, **Callback** -> Send word to Queue -> Stream to Browser.
    *   Keep best candidates for next iteration.
4.  **Browser Updates**: New words appear instantly in the "Found Words" list.
