#!/usr/bin/env python3
"""
Beam search for relations in the reduction mod p of the group generated by:
  a = [[t, 0], [0, 1]],  b = [[t^2 + 1, 2], [t, 1]]
in PGL_2(F_p(t)).
"""

import argparse
import random
from dataclasses import dataclass

try:
    from flint import nmod_poly
except ImportError:
    raise SystemExit("Error: python-flint not found. Please install it.")

# --- Matrix Utils ---

def mat_mul(M, N):
    (a, b), (c, d) = M
    (e, f), (g, h) = N
    return ((a*e + b*g, a*f + b*h), (c*e + d*g, c*f + d*h))

def mat_adj(M):
    (a, b), (c, d) = M
    return ((d, -b), (-c, a))

def mat_normalize(M, p):
    (a, b), (c, d) = M
    if not any([a, b, c, d]): return M
    g = a.gcd(b).gcd(c).gcd(d)
    if not g.is_zero() and (g.degree() > 0 or int(g.leading_coefficient()) != 1):
        a //= g; b //= g; c //= g; d //= g
    first = next((x for x in (a, b, c, d) if not x.is_zero()), None)
    if first:
        inv = pow(int(first.leading_coefficient()), -1, p)
        a *= inv; b *= inv; c *= inv; d *= inv
    return ((a, b), (c, d))

def mat_is_scalar(M):
    (a, b), (c, d) = M
    return b.is_zero() and c.is_zero() and a == d

def mat_to_latex(M):
    """Convert matrix entries to LaTeX strings."""
    (a, b), (c, d) = M
    def pstr(f):
        if f.is_zero(): return "0"
        s = str(f)
        # Simple cleanup if needed, flint str is usually good
        return s.replace("*", "")
    return r"\begin{pmatrix} " + f"{pstr(a)} & {pstr(b)} \\\\ {pstr(c)} & {pstr(d)}" + r" \end{pmatrix}"

@dataclass(frozen=True)
class State:
    word: str
    mat: tuple
    score: float
    last: str

# --- Configuration & Search ---

INV = {"a": "ai", "ai": "a", "b": "bi", "bi": "b"}
FORBID_FOLLOW = {
    "a": ("a . b . ai . bi", "a . bi . ai . b"),
    "b": ("b . a . bi . ai", "b . ai . bi . a"),
    "ai": ("ai . b . a . bi", "ai . bi . a . b"),
    "bi": ("bi . a . b . ai", "bi . ai . b . a"),
}

def beam_search(p, width, depth, samples, seed, min_len, stop_after):
    rng = random.Random(seed)
    candidates = [x for x in range(p) if x not in (0, 1)]
    pts = rng.sample(candidates, min(len(candidates), samples)) if candidates else [0]
    
    t, one, zero = nmod_poly([0, 1], p), nmod_poly([1], p), nmod_poly([], p)
    ga = ((t, zero), (zero, one))
    gb = ((t*t + one, nmod_poly([2], p)), (t, one))
    gens = {"a": ga, "b": gb, "ai": mat_adj(ga), "bi": mat_adj(gb)}
    
    beam = [State("", ((one, zero), (zero, one)), 0, "")]
    found = []

    for d in range(1, depth + 1):
        next_states = {}
        for st in beam:
            for ch, gmat in gens.items():
                if st.last and INV[st.last] == ch: continue
                if any(st.word.endswith(s) for s in FORBID_FOLLOW.get(ch, [])): continue
                
                word = (st.word + " . " + ch) if st.word else ch
                mat = mat_normalize(mat_mul(st.mat, gmat), p)
                
                if d >= min_len and mat_is_scalar(mat):
                    found.append(word)
                    yield {"type": "found", "word": word, "depth": d, "matrix": mat_to_latex(mat)}
                    if len(found) >= stop_after: return
                
                complexity = sum(x.degree() for row in mat for x in row if not x.is_zero())
                defect = sum(1 for tp in pts if mat[0][1](tp) or mat[1][0](tp) or mat[0][0](tp) != mat[1][1](tp))
                score = d + 2*complexity + 50*defect
                
                key = str(mat)
                if key not in next_states or score < next_states[key].score:
                    next_states[key] = State(word, mat, score, ch)
        
        beam = sorted(next_states.values(), key=lambda s: s.score)[:width]
        if not beam: break
        yield {
            "type": "progress", 
            "depth": d, 
            "beam_size": len(beam), 
            "best_score": beam[0].score, 
            "best_word": beam[0].word,
            "best_matrix": mat_to_latex(beam[0].mat)
        }
    return found

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--p", type=int, required=True, help="Prime modulus p.")
    ap.add_argument("--beam", type=int, default=100000)
    ap.add_argument("--depth", type=int, default=200)
    ap.add_argument("--samples", type=int, default=5)
    ap.add_argument("--seed", type=int, default=0)
    ap.add_argument("--minlen", type=int, default=8)
    ap.add_argument("--stop", type=int, default=3)
    args = ap.parse_args()
    
    gen = beam_search(args.p, args.beam, args.depth, args.samples, args.seed, args.minlen, args.stop)
    
    rels = []
    for update in gen:
        if update["type"] == "found":
            rels.append(update["word"])
            print(f"[FOUND] {update['word']}")
        else:
            print(f"[d={update['depth']}] beam={update['beam_size']} best={update['best_word']}")

    print("\nRelations found:")
    for w in rels:
        print(" ", w)

if __name__ == "__main__":
    main()