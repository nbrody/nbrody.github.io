/**
 * AlgebraicGroup class scaffold.
 *
 * Represents an algebraic group defined by polynomial equations over a polynomial ring.
 * Provides methods to test membership and compute Zariski closures of subgroups.
 *
 * Future goal: Implement algorithms for computing Zariski closures of subgroups
 * given by generators.
 */
(function() {
  class AlgebraicGroup {
    /**
     * Construct an AlgebraicGroup.
     * @param {PolynomialRingZ} ring - The polynomial ring over which the group is defined.
     * @param {Array} definingPolynomials - List of polynomials defining the group equations.
     * @param {Array} variables - Variable names used in the polynomials.
     */
    constructor(ring, definingPolynomials, variables) {
      this.ring = ring;
      this.definingPolynomials = definingPolynomials;
      this.variables = variables;
    }

    /**
     * Check if a given tuple of elements satisfies the defining equations of the group.
     * @param {Array} polyTuple - Tuple of elements to test.
     * @returns {boolean} True if all defining polynomials evaluate to zero at polyTuple.
     */
    isElement(polyTuple) {
      // Evaluate each defining polynomial at the given tuple.
      for (let poly of this.definingPolynomials) {
        const val = poly.evaluate(polyTuple);
        if (val !== 0n) return false;
      }
      return true;
    }

    /**
     * Compute the Zariski closure of a subgroup generated by the given elements.
     * @param {Array} generators - List of elements generating the subgroup.
     * @returns {AlgebraicGroup} The algebraic group representing the closure.
     */
    subgroupClosure(generators) {
      // Heuristic fast implementation for additive algebraic groups A^k:
      // Given generators v1,...,vm in Z^k, the Zariski-closure of the
      // subgroup they generate is the linear algebraic subgroup defined by
      // all linear forms L(x)=0 vanishing on Span_Q{v1,...,vm}.
      // We compute a basis of the annihilator by RREF(A) over Q, where
      // A is the m x k matrix with rows v_i (or equivalently columns as generators),
      // and convert those relations into linear polynomials with integer coefficients.
      const R = this.ring;
      const k = R && R.k;
      if (!k || !Number.isInteger(k)) throw new Error("subgroupClosure: invalid polynomial ring");
      if (!Array.isArray(generators)) throw new Error("subgroupClosure: generators must be an array of k-tuples");

      // Convert input to matrix A (m x k) with BigInt entries
      const A = generators.map((g, idx) => {
        if (!Array.isArray(g) || g.length !== k) throw new Error(`subgroupClosure: generator ${idx} must be a ${k}-tuple`);
        return g.map((x, j) => {
          if (typeof x === 'bigint') return x;
          if (typeof x === 'number' && Number.isFinite(x) && Math.floor(x) === x) return BigInt(x);
          throw new Error(`subgroupClosure: entry (${idx},${j}) must be an integer`);
        });
      });

      // Edge case: no generators => closure is {0} defined by x_i = 0
      if (A.length === 0) {
        const polys = [];
        for (let i = 0; i < k; i++) {
          const exp = new Array(k).fill(0); exp[i] = 1;
          polys.push(R.mon(exp, 1n));
        }
        return new AlgebraicGroup(R, this.definingPolynomials.concat(polys), this.variables);
      }

      // Rational arithmetic with BigInt
      const gcdBI = (a, b) => { a = a < 0n ? -a : a; b = b < 0n ? -b : b; while (b !== 0n) { const t = a % b; a = b; b = t; } return a; };
      const lcmBI = (a, b) => { a = a < 0n ? -a : a; b = b < 0n ? -b : b; if (a === 0n || b === 0n) return 0n; return (a / gcdBI(a, b)) * b; };
      const normQ = (n, d) => {
        if (d === 0n) throw new Error("subgroupClosure: division by zero in rational");
        if (n === 0n) return { n: 0n, d: 1n };
        if (d < 0n) { n = -n; d = -d; }
        const g = gcdBI(n < 0n ? -n : n, d);
        return { n: n / g, d: d / g };
      };
      const Q = {
        fromBI: (a) => ({ n: a, d: 1n }),
        add: (x, y) => normQ(x.n * y.d + y.n * x.d, x.d * y.d),
        sub: (x, y) => normQ(x.n * y.d - y.n * x.d, x.d * y.d),
        mul: (x, y) => normQ(x.n * y.n, x.d * y.d),
        div: (x, y) => normQ(x.n * y.d, x.d * y.n),
        neg: (x) => ({ n: -x.n, d: x.d }),
        isZero: (x) => x.n === 0n,
        eq: (x, y) => x.n === y.n && x.d === y.d
      };

      // Build rational matrix (m x k)
      const M = A.map(row => row.map(Q.fromBI));
      const m = M.length;

      // RREF over Q: returns pivot columns and row-reduced matrix in-place
      const pivotCols = [];
      let r = 0;
      for (let c = 0; c < k && r < m; c++) {
        // Find pivot row >= r with nonzero entry in column c
        let piv = -1;
        for (let i = r; i < m; i++) if (!Q.isZero(M[i][c])) { piv = i; break; }
        if (piv === -1) continue;
        // Swap rows r and piv
        if (piv !== r) { const tmp = M[r]; M[r] = M[piv]; M[piv] = tmp; }
        // Normalize row r so pivot is 1
        const inv = Q.div(Q.fromBI(1n), M[r][c]);
        for (let j = c; j < k; j++) M[r][j] = Q.mul(M[r][j], inv);
        // Eliminate column c in all other rows
        for (let i = 0; i < m; i++) if (i !== r && !Q.isZero(M[i][c])) {
          const factor = M[i][c];
          for (let j = c; j < k; j++) M[i][j] = Q.sub(M[i][j], Q.mul(factor, M[r][j]));
          // ensure exact zeros are normalized
          M[i][c] = Q.fromBI(0n);
        }
        pivotCols.push(c);
        r++;
      }

      // Determine free columns
      const pivSet = new Set(pivotCols);
      const freeCols = [];
      for (let c = 0; c < k; c++) if (!pivSet.has(c)) freeCols.push(c);

      // If no relations (full rank), closure is ambient group
      if (freeCols.length === 0) {
        return new AlgebraicGroup(R, this.definingPolynomials.slice(), this.variables);
      }

      // Extract nullspace basis: for each free column f, set x_f = 1 and others per RREF
      const relations = [];
      for (const f of freeCols) {
        const vec = new Array(k).fill(null).map(() => Q.fromBI(0n));
        vec[f] = Q.fromBI(1n);
        // For each pivot row t with pivot at col p = pivotCols[t], we have x_p + sum_j M[t][j]*x_j = 0 in RREF
        for (let t = 0; t < pivotCols.length; t++) {
          const pcol = pivotCols[t];
          if (!Q.isZero(M[t][f])) vec[pcol] = Q.neg(M[t][f]); else vec[pcol] = Q.fromBI(0n);
        }
        relations.push(vec);
      }

      // Convert rational relations to integer linear forms with gcd=1
      const toIntegerVector = (vecQ) => {
        // Common denominator
        let D = 1n;
        for (const x of vecQ) D = lcmBI(D, x.d);
        const ints = vecQ.map(x => (D / x.d) * x.n);
        // Normalize by gcd and sign
        let g = 0n;
        for (const a of ints) g = g === 0n ? (a < 0n ? -a : a) : gcdBI(g, a < 0n ? -a : a);
        if (g !== 0n && g !== 1n) for (let i = 0; i < ints.length; i++) ints[i] /= g;
        // Make leading nonzero positive for consistency
        for (let i = 0; i < ints.length; i++) {
          if (ints[i] !== 0n) {
            if (ints[i] < 0n) for (let j = 0; j < ints.length; j++) ints[j] = -ints[j];
            break;
          }
        }
        return ints;
      };

      const linearPolys = [];
      for (const rel of relations) {
        const coeffs = toIntegerVector(rel);
        // Skip trivial relation
        if (coeffs.every(c => c === 0n)) continue;
        let poly = R.zero();
        for (let i = 0; i < k; i++) if (coeffs[i] !== 0n) {
          const exp = new Array(k).fill(0); exp[i] = 1;
          poly = poly.add(R.mon(exp, coeffs[i]));
        }
        linearPolys.push(poly);
      }

      const newPolys = this.definingPolynomials.concat(linearPolys);
      return new AlgebraicGroup(R, newPolys, this.variables);
    }

    /**
     * Return a human-readable description of the algebraic group.
     * @returns {string}
     */
    toString() {
      return `AlgebraicGroup defined by polynomials: ${this.definingPolynomials.map(p => p.toString()).join(", ")}`;
    }
  }

  window.Rings = window.Rings || {};
  window.Rings.AlgebraicGroup = AlgebraicGroup;
})();
