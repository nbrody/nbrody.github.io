<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minkowski Embedding of Z[√2]</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            /* Prevent scrollbars during animation */
        }

        canvas {
            background-color: #f8fafc;
            /* Tailwind gray-50 */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        /* Ensure MathJax SVG renders inline, not as a block */
        mjx-container[jax="SVG"] svg {
            display: inline;
            vertical-align: -0.2em; /* better baseline alignment */
        }
        #minkowskiCanvasLabels .math-label {
            position: absolute;
            pointer-events: none;
            transform: translate(8px, -50%) scale(1.4); /* enlarge for higher resolution */
            transform-origin: left center;
            font-size: 16px;
            font-weight: 600;
            color: #1f2937; /* Tailwind gray-800 */
            background: rgba(255, 255, 255, 0.85);
            padding: 3px 8px;
            border-radius: 4px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.25);
            white-space: nowrap;
        }
    </style>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4 antialiased">

    <div class="w-full max-w-4xl text-center">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Minkowski Embedding of \(\mathbb{Z}[\sqrt{2}]\)</h1>
        <p class="text-gray-600 mb-4">
            Visualizing the mapping from \(a + b\sqrt{2}\) to the point \((a + b\sqrt{2},\, a - b\sqrt{2}) \in \mathbb{R}^2\).
        </p>
    </div>

    <div class="relative w-full max-w-4xl">
        <canvas id="minkowskiCanvas" class="w-full max-w-4xl aspect-video"></canvas>
        <div
            class="absolute top-4 left-4 bg-white/80 backdrop-blur-sm p-3 rounded-lg shadow-md text-sm text-gray-700 pointer-events-none">
            <h3 class="font-bold mb-2">Norm: \(a^2 - 2b^2\)</h3>
            <div class="flex items-center space-x-2">
                <div class="w-4 h-4 rounded-full" style="background-color: rgb(59, 130, 246);"></div>
                <span>Negative</span>
            </div>
            <div class="flex items-center space-x-2 my-1">
                <div class="w-4 h-4 rounded-full" style="background-color: rgb(209, 213, 219);"></div>
                <span>Zero</span>
            </div>
            <div class="flex items-center space-x-2">
                <div class="w-4 h-4 rounded-full" style="background-color: rgb(239, 68, 68);"></div>
                <span>Positive</span>
            </div>
        </div>
    </div>


    <div class="mt-4">
        <button id="animateBtn"
            class="bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75 transition-transform transform hover:scale-105">
            Start Animation
        </button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('minkowskiCanvas');
            const ctx = canvas.getContext('2d');
            const animateBtn = document.getElementById('animateBtn');

            // --- Configuration ---
            const range = 16; // Integers a, b will go from -range to +range (17x17 grid)
            const sqrt2 = Math.sqrt(2);
            const animationDuration = 3000; // in milliseconds
            let animationFrameId;

            // --- Point and Drawing Configuration ---
            const labelColor = '#374151'; // gray-700
            const axisColor = '#9ca3af'; // gray-400
            const gridColor = '#e5e7eb'; // gray-200
            const pointRadius = 4;

            // --- Color Gradient Configuration ---
            const negColor = { r: 59, g: 130, b: 246 }; // Tailwind blue-500
            const posColor = { r: 239, g: 68, b: 68 };  // Tailwind red-500
            const zeroColor = { r: 209, g: 213, b: 219 }; // Tailwind gray-300

            let points = [];
            let scale;
            let origin;
            let minNorm = 0, maxNorm = 0;

            // --- Color Utility Functions ---
            const lerpColor = (c1, c2, t) => {
                const r = Math.round(c1.r * (1 - t) + c2.r * t);
                const g = Math.round(c1.g * (1 - t) + c2.g * t);
                const b = Math.round(c1.b * (1 - t) + c2.b * t);
                return `rgb(${r}, ${g}, ${b})`;
            };

            const getColorForNorm = (norm) => {
                if (norm === 0) return `rgb(${zeroColor.r}, ${zeroColor.g}, ${zeroColor.b})`;
                // Use sqrt for better color distribution, emphasizing values closer to zero
                if (norm > 0) {
                    return lerpColor(zeroColor, posColor, Math.sqrt(norm / maxNorm));
                } else { // norm < 0
                    return lerpColor(zeroColor, negColor, Math.sqrt(norm / minNorm));
                }
            }

            // --- Utility Functions ---
            const generatePoints = () => {
                points = [];
                for (let a = -range; a <= range; a++) {
                    for (let b = -range; b <= range; b++) {
                        const x = a + b * sqrt2;
                        const yFinal = a - b * sqrt2;
                        const norm = a * a - 2 * b * b;
                        let label;
                        if (b === 0) label = `${a}`;
                        else if (a === 0) label = `${b}√2`;
                        else label = `${a} ${b > 0 ? '+' : '-'} ${Math.abs(b)}√2`;

                        points.push({ a, b, x, yInitial: 0, yFinal, norm, label });
                    }
                }
                // Find min/max norms for color scaling
                const norms = points.map(p => p.norm);
                maxNorm = Math.max(...norms.filter(n => n > 0));
                minNorm = Math.min(...norms.filter(n => n < 0));
            };

            const setupCanvas = () => {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                // Fix to window [-10,10]^2
                const maxCoord = 10;
                scale = Math.min(canvas.clientWidth / (2 * maxCoord), canvas.clientHeight / (2 * maxCoord));
                origin = { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 };
            }

            // --- Drawing Functions ---
            const drawGridAndAxes = () => {
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;

                // Draw vertical grid lines
                for (let i = -Math.floor(range * 2.5); i <= Math.floor(range * 2.5); i++) {
                    if (i === 0) continue;
                    const x = origin.x + i * scale * 2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.clientHeight);
                    ctx.stroke();
                }

                // Draw horizontal grid lines
                for (let i = -Math.floor(range * 2.5); i <= Math.floor(range * 2.5); i++) {
                    if (i === 0) continue;
                    const y = origin.y + i * scale * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.clientWidth, y);
                    ctx.stroke();
                }

                // Draw axes
                ctx.strokeStyle = axisColor;
                ctx.lineWidth = 2;
                // X-axis
                ctx.beginPath();
                ctx.moveTo(0, origin.y);
                ctx.lineTo(canvas.clientWidth, origin.y);
                ctx.stroke();
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(origin.x, 0);
                ctx.lineTo(origin.x, canvas.clientHeight);
                ctx.stroke();
            };

            const drawPoint = (p, y, color) => {
                const canvasX = origin.x + p.x * scale;
                const canvasY = origin.y - y * scale; // Invert Y-axis for standard math coordinates

                // Draw point
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, pointRadius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                // Draw label for a few points to avoid clutter
                if (Math.abs(p.x) < 5 && Math.abs(y) < 5 && (Math.abs(p.a) <= 2 && Math.abs(p.b) <= 2)) {
                    ctx.fillStyle = labelColor;
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.label, canvasX + 8, canvasY);
                }
            };

            const draw = (progress) => {
                ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
                drawGridAndAxes();

                points.forEach(p => {
                    const currentY = p.yInitial + (p.yFinal - p.yInitial) * progress;
                    const color = getColorForNorm(p.norm);
                    drawPoint(p, currentY, color);
                });
            };

            // --- Animation Logic ---
            const startAnimation = () => {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                let startTime = null;

                const animate = (timestamp) => {
                    if (!startTime) startTime = timestamp;
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / animationDuration, 1);

                    draw(progress);

                    if (progress < 1) {
                        animationFrameId = requestAnimationFrame(animate);
                    } else {
                        animateBtn.textContent = 'Restart Animation';
                    }
                };

                animateBtn.textContent = 'Animating...';
                animationFrameId = requestAnimationFrame(animate);
            };

            // --- Initialization ---
            const initialize = () => {
                setupCanvas();
                generatePoints();
                draw(0); // Initial draw at progress 0
            }

            animateBtn.addEventListener('click', startAnimation);
            window.addEventListener('resize', initialize);

            // Initial setup
            initialize();
        });
    </script>
</body>

</html>