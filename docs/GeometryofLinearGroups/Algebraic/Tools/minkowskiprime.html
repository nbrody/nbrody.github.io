<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minkowski Embedding of Z[1/3]</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f9;
            color: #333;
            margin: 0;
        }

        #container {
            margin-top: 20px;
            padding: 20px;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            text-align: center;
        }

        h1 {
            color: #2c3e50;
        }

        p {
            max-width: 800px;
            line-height: 1.6;
        }

        canvas {
            border: 1px solid #ccc;
            margin-top: 15px;
        }

        button {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }
</style>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$','$$'], ['\\[','\\]']]
        },
        svg: { fontCache: 'global' }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
    <div id="container">
        <h1>Minkowski Embedding of $\mathbb{Z}[\frac{1}{3}]$</h1>
        <p>
            This visualization shows how to separate points in $\mathbb{Z}[\frac{1}{3}]$ in a product of local fields.
            Initially, we see $\mathbb{Z}[\frac{1}{3}]$ as a dense subring of $\mathbb{R}$. However, in the animation,
            we see that we can spread the points out according to their 3-adic valuation. In particular, points that are
            very close to zero must have a very large power of 3 in the denominator, which corresponds to having $v_3(x)$
            a negative number with large magnitude.
        </p>
        <p>
            Click the button below to animate the Minkowski embedding, which maps a point $x$ from $(x, 0)$ to $(x,3^{v_3(x)})$.
        </p>
        <canvas id="minkowski-canvas" width="800" height="500"></canvas>
        <div>
            <button id="animate-btn">Animate Embedding</button>
        </div>
    </div>

    <script>
        // A simple rational number library
        const Q = {
            // Greatest Common Divisor
            gcd: (a, b) => {
                a = Math.abs(a);
                b = Math.abs(b);
                while (b) {
                    [a, b] = [b, a % b];
                }
                return a;
            },
            // Simplify a fraction
            simplify: (num, den) => {
                if (den === 0) throw new Error("Denominator cannot be zero.");
                if (den < 0) {
                    num = -num;
                    den = -den;
                }
                const common = Q.gcd(num, den);
                return { num: num / common, den: den / common };
            }
        };

        // --- MATH HELPERS ---
        /**
         * Computes the exponent of a prime p in the prime factorization of an integer n.
         * @param {number} n The integer.
         * @param {number} p The prime.
         * @returns {number} The exponent.
         */
        function integerExponent(n, p) {
            if (n === 0 || p <= 1) return Infinity;
            n = Math.abs(n);
            let count = 0;
            while (n > 0 && n % p === 0) {
                count++;
                n /= p;
            }
            return count;
        }

        /**
         * Computes the 3-adic valuation of a rational number.
         * @param {{num: number, den: number}} q The rational number.
         * @returns {number} The 3-adic valuation v_3(q).
         */
        function v3(q) {
            return integerExponent(q.num, 3) - integerExponent(q.den, 3);
        }


        // --- VISUALIZATION LOGIC ---
        const canvas = document.getElementById('minkowski-canvas');
        const ctx = canvas.getContext('2d');
        const animateBtn = document.getElementById('animate-btn');

        // HiDPI / resolution setup
        let VIEW_W = 800; // logical drawing width in CSS pixels
        let VIEW_H = 500; // logical drawing height in CSS pixels
        function setupHiDPI() {
          const DPR = window.devicePixelRatio || 1;
          // Use the current displayed size (fallback to attributes)
          const rect = canvas.getBoundingClientRect();
          VIEW_W = Math.round(rect.width) || (parseInt(canvas.getAttribute('width'), 10) || 800);
          VIEW_H = Math.round(rect.height) || (parseInt(canvas.getAttribute('height'), 10) || 500);
          canvas.style.width = VIEW_W + 'px';
          canvas.style.height = VIEW_H + 'px';
          canvas.width = Math.round(VIEW_W * DPR);
          canvas.height = Math.round(VIEW_H * DPR);
          // Scale drawing operations so all coordinates stay in CSS pixels
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        }
        setupHiDPI();
        window.addEventListener('resize', () => {
          setupHiDPI();
        });

        // --- CONFIGURATION ---
        const X_RANGE = [-5, 5]; // Real values to display
        const NUMERATOR_MAX = 60;
        const DENOMINATOR_POWER_MAX = 5; // allow denominators up to 3^5
        const BASE_RADIUS = 5;
        const RADIUS_SCALE_FACTOR = 1.7;

        let points = [];
        let isAnimating = false;
        let animationProgress = 0; // Goes from 0 to 1
        const ANIMATION_SPEED = 0.02;

        /**
         * Generates points of the form m / 3^k to be visualized.
         */
        function generatePoints() {
          const generated = new Map();
          for (let k = 0; k <= DENOMINATOR_POWER_MAX; k++) {
            const den = Math.pow(3, k);
            for (let num = -5 * den; num <= 5 * den; num++) {
              const val = num / den;
              if (val > X_RANGE[0] && val < X_RANGE[1]) {
                const rational = Q.simplify(num, den);
                const valuation = v3(rational);
                generated.set(`${rational.num}/${rational.den}`, {
                  x: val,
                  y: 0,
                  targetY: Math.pow(3, valuation),
                  valuation,
                  radius: BASE_RADIUS * Math.pow(RADIUS_SCALE_FACTOR, valuation),
                  label: `${rational.num}/${rational.den}`
                });
              }
            }
          }
          points = Array.from(generated.values()).sort((a, b) => a.x - b.x);
        }

        /**
         * Maps world coordinates (x, y) to canvas pixel coordinates.
         */
        function mapCoords(x, y) {
            const canvasX = (x - X_RANGE[0]) / (X_RANGE[1] - X_RANGE[0]) * VIEW_W;

            // Y-axis range: from 0 up to 3^(DENOMINATOR_POWER_MAX)
            const Y_VAL_RANGE = [-.2, 3.2];
            const canvasY = VIEW_H - ((y - Y_VAL_RANGE[0]) / (Y_VAL_RANGE[1] - Y_VAL_RANGE[0]) * VIEW_H);

            return { x: canvasX, y: canvasY };
        }

        /**
         * Draws the X and Y axes.
         */
        function drawAxes() {
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1;

            // X-axis (Valuation = 0)
            const zeroValLine = mapCoords(0, 0);
            ctx.beginPath();
            ctx.moveTo(0, zeroValLine.y);
            ctx.lineTo(VIEW_W, zeroValLine.y);
            ctx.stroke();

            // Ticks and labels
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';

            // X-axis ticks (Real numbers)
            for (let i = Math.ceil(X_RANGE[0]); i <= Math.floor(X_RANGE[1]); i++) {
                if (i === 0) continue;
                const pos = mapCoords(i, 0);
                ctx.fillText(i, pos.x, pos.y + 15);
            }
        }

        /**
         * The main drawing loop.
         */
        function draw() {
            ctx.clearRect(0, 0, VIEW_W, VIEW_H);
            drawAxes();

            if (isAnimating && animationProgress < 1) {
                animationProgress += ANIMATION_SPEED;
                if (animationProgress > 1) animationProgress = 1;
            }

            // Update and draw points
            points.forEach(p => {
                // Interpolate position during animation
                const easedProgress = 0.5 - 0.5 * Math.cos(animationProgress * Math.PI);
                p.y = p.targetY * easedProgress;

                const pos = mapCoords(p.x, p.y);

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, p.radius, 0, 2 * Math.PI);

                // Color based on valuation
                const hue = 180 + p.valuation * 30; // Shift hue from cyan to magenta
                ctx.fillStyle = `hsla(${hue}, 80%, 50%, 0.7)`;
                ctx.fill();
                ctx.strokeStyle = `hsla(${hue}, 90%, 30%, 0.9)`;
                ctx.stroke();
            });

            requestAnimationFrame(draw);
        }

        // --- INITIALIZATION ---
        animateBtn.addEventListener('click', () => {
            if (animationProgress >= 1) { // Reset if finished
                animationProgress = 0;
            }
            isAnimating = true;
        });

        generatePoints();
        draw();
    </script>
</body>

</html>