<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2-adic Solenoid</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: monospace;
        }
    </style>
</head>

<body>
    <div id="info">2-adic Solenoid (Mapping Torus of +1 on Zâ‚‚)</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.171.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.171.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101018);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 4.5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.4;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(3, 5, 5);
            scene.add(directionalLight);

            // Create the Solenoid Geometry
            createSolenoid();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        /**
         * Maps an integer k to an angle, creating a Cantor set-like distribution on the circle.
         * This uses the binary representation of k to compute its position.
         * @param {number} k The integer index.
         * @param {number} N The level of approximation.
         * @returns {number} An angle in radians.
         */
        function getCantorAngle(k, N) {
            let val = 0;
            for (let i = 0; i < N; i++) {
                if ((k >> i) & 1) { // Check the i-th bit of k
                    val += Math.pow(2, -(i + 1));
                }
            }
            // val is now a number in [0, 1) representing the position
            return 2 * Math.PI * val;
        }

        function createSolenoid() {
            // N determines the level of approximation. The number of strands is 2^N.
            // N=12 gives 4096 strands, which is a good balance of detail and performance.
            const N = 12;
            const NUM_STRANDS = Math.pow(2, N);
            const RADIUS = 2;
            const HEIGHT = 2.5;
            const TUBE_RADIUS = 0.006;

            for (let k = 0; k < NUM_STRANDS; k++) {
                // Calculate the angle for point 'k' on the bottom circle
                const angle1 = getCantorAngle(k, N);
                const startPoint = new THREE.Vector3(
                    RADIUS * Math.cos(angle1),
                    RADIUS * Math.sin(angle1),
                    -HEIGHT / 2
                );

                // Calculate the angle for point 'k+1' on the top circle
                const angle2 = getCantorAngle((k + 1) % NUM_STRANDS, N);
                const endPoint = new THREE.Vector3(
                    RADIUS * Math.cos(angle2),
                    RADIUS * Math.sin(angle2),
                    HEIGHT / 2
                );

                // Create a straight line curve between the start and end points
                const curve = new THREE.LineCurve3(startPoint, endPoint);

                // Create a tube geometry from this curve
                const tubeGeometry = new THREE.TubeGeometry(curve, 1, TUBE_RADIUS, 5, false);

                // Assign a color based on the position (k) to visualize the mapping
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(k / NUM_STRANDS, 0.9, 0.6),
                    metalness: 0.2,
                    roughness: 0.4
                });

                const tubeMesh = new THREE.Mesh(tubeGeometry, material);
                scene.add(tubeMesh);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>