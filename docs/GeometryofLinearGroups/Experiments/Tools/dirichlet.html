<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Dirichlet Polyhedron in H³ (three.js)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0b0f12; color:#fff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
  #container { position:fixed; inset:0; }
  /* Floating, collapsible controls */
  #panel {
    position: absolute; top: 12px; left: 12px;
    background: rgba(0,0,0,0.75); backdrop-filter: blur(6px);
    border: 1px solid #2a3340; border-radius: 12px; padding: 8px;
    max-width: 340px; color:#e6eef7;
  }
  #panel.collapsed .content { display:none; }
  #panel .row { display:flex; align-items:center; gap:8px; margin:6px 0; }
  #panel .row small { opacity:.8; }
  #panel .btn { cursor:pointer; border:1px solid #334; background:#1a212b; color:#e6eef7; padding:6px 10px; border-radius:8px; font-size:12px; }
  #panel .btn.ghost { background:transparent; border-color:#2a3340; }
  #panel h2 { margin:6px 0 4px; font-size:14px; font-weight:600; }
  #panel h3 { margin:10px 0 4px; font-size:12px; font-weight:600; opacity:.9; }
  #genList { max-height: 220px; overflow:auto; padding-right:4px; }
  .matrix { display:grid; grid-template-columns: 1fr 1fr; gap:4px; margin-bottom:6px; }
  .entry { width:100%; padding:4px 6px; font-size:12px; background:#11161d; border:1px solid #2a3340; color:#e6eef7; border-radius:6px; }
  .tiny { font-size:11px; opacity:.8; }
  .switch { display:inline-flex; align-items:center; gap:6px; margin-right:8px; }
  input[type="checkbox"] { transform: scale(1.1); }
  input[type="range"] { width:100%; }
  pre#log { background:#0e131a; border:1px solid #233042; border-radius:8px; padding:8px; font-size:11px; max-height:140px; overflow:auto; white-space:pre-wrap; }
  /* overlay legend dots */
  .legend { position:absolute; bottom:12px; left:12px; background:rgba(0,0,0,0.6); border:1px solid #2a3340; border-radius:10px; padding:6px 8px; font-size:12px; display:flex; align-items:center; gap:12px; }
  .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
  .dot.base { background:#ffcc66; }
  .dot.orbit { background:#99ccff; }
  .dot.cloud { background:#ffffff; }
</style>
</head>
<body>
<div id="container"></div>

<!-- Floating Controls -->
<div id="panel" class="">
  <div class="row" style="justify-content:space-between;">
    <div style="display:flex; align-items:center; gap:8px;">
      <button id="toggle" class="btn">☰</button>
      <h2>Dirichlet Polyhedron (H³)</h2>
    </div>
    <button id="build" class="btn">Build</button>
  </div>

  <div class="content">
    <h3>Generators (2×2 complex, det normalized)</h3>
    <div id="genList"></div>
    <div class="row" style="gap:6px;">
      <button id="addGen" class="btn tiny">+ Add</button>
      <button id="useTight" class="btn tiny ghost">Use tight example</button>
      <button id="useST" class="btn tiny ghost">Use PSL(2,ℤ) S,T</button>
      <small class="tiny">Entries like <code>a+bi</code> or real fraction <code>p/q</code>.</small>
    </div>

    <h3>Sampling & Words</h3>
    <div class="row">
      <small>Max word length:</small><span id="lenLabel" style="min-width:2ch;">4</span>
    </div>
    <input id="len" type="range" min="1" max="7" step="1" value="4" />
    <div class="row">
      <small>Boundary points:</small><span id="ptsLabel">15000</span>
    </div>
    <input id="pts" type="range" min="1000" max="50000" step="1000" value="15000" />
    <div class="row">
      <small>ε (boundary tolerance):</small><span id="epsLabel">0.015</span>
    </div>
    <input id="eps" type="range" min="0.005" max="0.08" step="0.001" value="0.015" />

    <h3>Display</h3>
    <div class="row" style="flex-wrap:wrap;">
      <label class="switch"><input id="showBis" type="checkbox" checked /> <small>Bisectors</small></label>
      <label class="switch"><input id="showOrbit" type="checkbox" checked /> <small>Orbit</small></label>
      <label class="switch"><input id="showCloud" type="checkbox" checked /> <small>Cloud</small></label>
      <label class="switch"><input id="showGrid" type="checkbox" checked /> <small>Grid</small></label>
      <label class="switch"><input id="flipClip" type="checkbox" /> <small>Flip z-clip (if needed)</small></label>
    </div>
    <div class="row">
      <small>Bisector opacity</small><span id="bisOpLabel">0.18</span>
    </div>
    <input id="bisOp" type="range" min="0.05" max="0.6" step="0.01" value="0.18" />
    <div class="row">
      <small>Cloud opacity</small><span id="cloudOpLabel">0.9</span>
    </div>
    <input id="cloudOp" type="range" min="0.1" max="1" step="0.05" value="0.9" />
    <div class="row">
      <small>Point size</small><span id="ptSizeLabel">0.05</span>
    </div>
    <input id="ptSize" type="range" min="0.01" max="0.12" step="0.005" value="0.05" />

    <h3>Log</h3>
    <pre id="log"></pre>
  </div>
</div>

<div class="legend">
  <span><span class="dot base"></span> basepoint j</span>
  <span><span class="dot orbit"></span> orbit g·j</span>
  <span><span class="dot cloud"></span> boundary samples</span>
</div>

<!-- three.js -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ========= Complex numbers ========= */
class C {
  constructor(re=0, im=0){ this.re=re; this.im=im; }
  static from(x){ return x instanceof C ? x : new C(x,0); }
  static add(a,b){ return new C(a.re+b.re, a.im+b.im); }
  static sub(a,b){ return new C(a.re-b.re, a.im-b.im); }
  static mul(a,b){ return new C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
  static div(a,b){ const d=b.re*b.re + b.im*b.im || 1e-18; return new C((a.re*b.re + a.im*b.im)/d, (a.im*b.re - a.re*b.im)/d); }
  static conj(a){ return new C(a.re, -a.im); }
  static abs2(a){ return a.re*a.re + a.im*a.im; }
  static sqrt(a){
    const r = Math.hypot(a.re, a.im);
    const u = Math.sqrt((r + a.re)/2);
    const v = (a.im>=0?1:-1) * Math.sqrt(Math.max(0,(r - a.re)/2));
    return new C(u, v);
  }
}

/* Parsing "a+bi" or "p/q" (real) */
function parseComplex(str){
  const s = (str||"").trim().replace(/[()\s]/g,"");
  if (!s) return new C(0,0);
  if (s === 'i') return new C(0,1);
  if (s === '-i') return new C(0,-1);
  // pure real fraction (no 'i')
  if (!/i/i.test(s) && s.includes('/')){
    const [p,q] = s.split('/');
    const v = parseFloat(p)/parseFloat(q);
    return new C(isFinite(v)?v:0,0);
  }
  // a+bi or a-bi
  let m = s.match(/^([+-]?\d*\.?\d+)([+-]\d*\.?\d+)i$/i);
  if (m) return new C(parseFloat(m[1]), parseFloat(m[2]));
  // bi
  m = s.match(/^([+-]?\d*\.?\d+)i$/i);
  if (m) return new C(0, parseFloat(m[1]));
  // a
  const val = parseFloat(s);
  if (!isNaN(val)) return new C(val,0);
  // fallback 0
  return new C(0,0);
}

/* ========= 2×2 complex matrices ========= */
class M2C {
  constructor(a,b,c,d){ this.a=C.from(a); this.b=C.from(b); this.c=C.from(c); this.d=C.from(d); }
  static I(){ return new M2C(new C(1,0),new C(0,0),new C(0,0),new C(1,0)); }
  static mul(X,Y){
    const a = C.add(C.mul(X.a,Y.a), C.mul(X.b,Y.c));
    const b = C.add(C.mul(X.a,Y.b), C.mul(X.b,Y.d));
    const c = C.add(C.mul(X.c,Y.a), C.mul(X.d,Y.c));
    const d = C.add(C.mul(X.c,Y.b), C.mul(X.d,Y.d));
    return new M2C(a,b,c,d);
  }
  static det(X){ return C.sub(C.mul(X.a,X.d), C.mul(X.b,X.c)); }
  static scale(X,s){ return new M2C(C.mul(X.a,s), C.mul(X.b,s), C.mul(X.c,s), C.mul(X.d,s)); }
  static conjT(X){ return new M2C(C.conj(X.a), C.conj(X.c), C.conj(X.b), C.conj(X.d)); }
  static inv(X){
    const det = M2C.det(X); const invDet = C.div(new C(1,0), det);
    return new M2C(C.mul(X.d,invDet), C.mul(new C(-X.b.re,-X.b.im),invDet), C.mul(new C(-X.c.re,-X.c.im),invDet), C.mul(X.a,invDet));
  }
  static normalizeSL2(X){
    const det = M2C.det(X), s = C.sqrt(det), invs = C.div(new C(1,0), s);
    return M2C.scale(X, invs);
  }
}

/* ========= H^3 via Hermitian model ========= */
function hermitian_Q_from_g(g){ return M2C.mul(g, M2C.conjT(g)); } // positive Hermitian
function pointFromHermitian(Q){
  // Q = [[A, conj(B)], [B, D]] (A,D ~ real)
  const D = Q.d.re || 1e-18;
  const B = C.conj(Q.b);
  const t = 1 / D;
  const w = C.div(B, new C(D,0));
  return { w, t };
}
/* Bisector A = I - (gg*)^{-1} => α,β,δ with equation α(|w|^2+t^2)+2Re(βw)+δ = 0 */
function bisectorFromG(g){
  const gSL = M2C.normalizeSL2(g);
  const Q = hermitian_Q_from_g(gSL);
  const Qinv = M2C.inv(Q);
  const I = M2C.I();
  const A = new M2C(
    new C(I.a.re - Qinv.a.re, I.a.im - Qinv.a.im),
    new C(I.b.re - Qinv.b.re, I.b.im - Qinv.b.im),
    new C(I.c.re - Qinv.c.re, I.c.im - Qinv.c.im),
    new C(I.d.re - Qinv.d.re, I.d.im - Qinv.d.im),
  );
  // Hermitian-ize gently
  const alpha = new C(A.a.re, 0);
  const delta = new C(A.d.re, 0);
  const beta  = new C((A.c.re + A.b.re)/2, (A.c.im - A.b.im)/2); // ≈ lower-left, respecting conjugacy
  const tol = 1e-12;
  if (Math.abs(alpha.re) < tol){
    return { type:"plane", alpha:0, beta, delta:delta.re };
  }
  const a = alpha.re;
  const c = C.div(new C(-beta.re, beta.im), new C(a,0)); // center = -conj(beta)/alpha
  const r2 = (C.abs2(beta) / (a*a)) - (delta.re / a);
  return { type:"sphere", alpha:a, beta, delta:delta.re, center:c, r2 };
}
/* side test s(w,t) */
function sValue(bis, x, y, t){
  return bis.alpha*(x*x + y*y + t*t) + 2*(bis.beta.re*x - bis.beta.im*y) + bis.delta;
}

/* ========= Word generation ========= */
function inverses(mats){ return mats.map(M2C.inv); }
function generateWords(gens, L){
  const syms=[];
  gens.forEach((g,i)=>{ syms.push({M:g, i, inv:false}); });
  inverses(gens).forEach((g,i)=>{ syms.push({M:g, i, inv:true}); });

  const words=[{M:M2C.I(), w:[]}];
  const seen=new Map();
  const keyOf = (M)=>{
    const r=(z)=> (z.re.toFixed(9)+","+z.im.toFixed(9));
    return [M.a,M.b,M.c,M.d].map(r).join("|");
  };
  seen.set(keyOf(M2C.I()), true);

  for (let len=1; len<=L; len++){
    const prev = words.filter(p=>p.w.length===len-1);
    const next=[];
    for (const base of prev){
      const last = base.w[base.w.length-1];
      for (const s of syms){
        if (last && last.i===s.i && last.inv!==s.inv) continue; // immediate cancellation
        const M = M2C.mul(base.M, s.M);
        const k = keyOf(M);
        if (!seen.has(k)){
          seen.set(k,true);
          next.push({M, w:[...base.w, s]});
        }
      }
    }
    words.push(...next);
  }
  return words.map(p=>p.M);
}

/* ========= three.js setup ========= */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f12);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.01, 5000);
camera.position.set(6, -10, 6);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(window.devicePixelRatio||1);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.localClippingEnabled = true;
container.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 0.75);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(6,6,10); scene.add(dir);

const grid = new THREE.GridHelper(40, 40, 0x222a32, 0x1a1f25);
grid.rotation.x = Math.PI/2; // XY plane
grid.position.z = 0.0001;
scene.add(grid);

/* Groups */
const gBis = new THREE.Group(); scene.add(gBis);
const gOrbit = new THREE.Group(); scene.add(gOrbit);
const gCloud = new THREE.Group(); scene.add(gCloud);

/* Global clipping plane to keep z >= 0 (upper half-space) */
let clipPlane = new THREE.Plane(new THREE.Vector3(0,0,-1), 0); // n·x + d = 0 => with n=(0,0,-1), j=(0,0,1) => -1 <= 0 -> kept
function setClipFlipped(flip){
  clipPlane = new THREE.Plane(new THREE.Vector3(0,0, flip? 1 : -1), 0);
}

/* Helpers */
function clearGroup(G){ while(G.children.length) G.remove(G.children[0]); }
function log(msg){
  const pre = document.getElementById('log');
  pre.textContent += msg + "\n";
  pre.scrollTop = pre.scrollHeight;
}

/* ========= Rendering loop ========= */
function animate(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* ========= UI wiring ========= */
const panel = document.getElementById('panel');
document.getElementById('toggle').onclick = ()=> panel.classList.toggle('collapsed');
const len = document.getElementById('len'), lenLabel = document.getElementById('lenLabel');
const pts = document.getElementById('pts'), ptsLabel = document.getElementById('ptsLabel');
const eps = document.getElementById('eps'), epsLabel = document.getElementById('epsLabel');
const showBis = document.getElementById('showBis');
const showOrbit = document.getElementById('showOrbit');
const showCloud = document.getElementById('showCloud');
const showGrid = document.getElementById('showGrid');
const flipClip = document.getElementById('flipClip');
const bisOp = document.getElementById('bisOp'), bisOpLabel = document.getElementById('bisOpLabel');
const cloudOp = document.getElementById('cloudOp'), cloudOpLabel = document.getElementById('cloudOpLabel');
const ptSize = document.getElementById('ptSize'), ptSizeLabel = document.getElementById('ptSizeLabel');

len.oninput = ()=> lenLabel.textContent = len.value;
pts.oninput = ()=> ptsLabel.textContent = pts.value;
eps.oninput = ()=> epsLabel.textContent = (+eps.value).toFixed(3);
bisOp.oninput = ()=> bisOpLabel.textContent = (+bisOp.value).toFixed(2);
cloudOp.oninput = ()=> cloudOpLabel.textContent = (+cloudOp.value).toFixed(2);
ptSize.oninput = ()=> ptSizeLabel.textContent = (+ptSize.value).toFixed(3);
showGrid.onchange = ()=> grid.visible = showGrid.checked;
flipClip.onchange = ()=> setClipFlipped(flipClip.checked);

/* Generators UI */
const genList = document.getElementById('genList');
let generators = [
  {a:"1.05", b:"0.22+0.12i", c:"0", d:"1/1.05"},
  {a:"1.08", b:"0.18-0.15i", c:"0.05i", d:"1/1.08"},
];
function drawGenerators(){
  genList.innerHTML = "";
  generators.forEach((g, idx)=>{
    const wrap = document.createElement('div');
    wrap.className = 'matrix';
    ["a","b","c","d"].forEach(k=>{
      const input = document.createElement('input');
      input.className = 'entry';
      input.value = g[k];
      input.placeholder = k;
      input.oninput = (e)=>{ generators[idx][k]=e.target.value; };
      wrap.appendChild(input);
    });
    const rm = document.createElement('div');
    rm.style.gridColumn = "1 / span 2";
    rm.style.display = "flex";
    rm.style.justifyContent = "flex-end";
    const btn = document.createElement('button');
    btn.className = "btn tiny ghost";
    btn.textContent = "Remove";
    btn.onclick = ()=>{ generators.splice(idx,1); drawGenerators(); };
    rm.appendChild(btn);
    wrap.appendChild(rm);
    genList.appendChild(wrap);
  });
}
drawGenerators();
document.getElementById('addGen').onclick = ()=>{ generators.push({a:"1",b:"0",c:"0",d:"1"}); drawGenerators(); };
document.getElementById('useTight').onclick = ()=>{
  generators = [
    {a:"1.05", b:"0.22+0.12i", c:"0", d:"1/1.05"},
    {a:"1.08", b:"0.18-0.15i", c:"0.05i", d:"1/1.08"},
  ];
  drawGenerators();
};
document.getElementById('useST').onclick = ()=>{
  // PSL(2,Z) example (Fuchsian)
  generators = [
    {a:"0", b:"-1", c:"1", d:"0"},   // S
    {a:"1", b:"1",  c:"0", d:"1"},   // T
  ];
  drawGenerators();
};

/* ========= Build pipeline ========= */
document.getElementById('build').onclick = ()=>{
  // clear
  clearGroup(gBis); clearGroup(gCloud); clearGroup(gOrbit);
  document.getElementById('log').textContent = "";
  log("Parsing generators & building words...");

  // parse matrices
  const gens = [];
  for (const m of generators){
    const a=parseComplex(m.a), b=parseComplex(m.b), c=parseComplex(m.c), d=parseComplex(m.d);
    gens.push(M2C.normalizeSL2(new M2C(a,b,c,d)));
  }
  const L = Math.max(1, Math.min(7, parseInt(len.value)));
  const elems = generateWords(gens, L);
  log(`Words up to length ${L}: ${elems.length} elements.`);

  // Compute bisectors with orientation so that side containing j has s <= 0.
  const rawBis = [];
  for (const g of elems){
    // skip identity
    const idLike = Math.abs(g.a.re-1)<1e-12 && Math.abs(g.a.im)<1e-12 &&
                   Math.abs(g.b.re)  <1e-12 && Math.abs(g.b.im)  <1e-12 &&
                   Math.abs(g.c.re)  <1e-12 && Math.abs(g.c.im)  <1e-12 &&
                   Math.abs(g.d.re-1)<1e-12 && Math.abs(g.d.im)<1e-12;
    if (idLike) continue;
    const bis = bisectorFromG(g);
    const sAtJ = sValue(bis, 0, 0, 1);
    // Flip to ensure j is on the ≤ 0 side
    if (sAtJ > 0){
      bis.alpha = -bis.alpha;
      bis.beta  = new C(-bis.beta.re, -bis.beta.im);
      bis.delta = -bis.delta;
    }
    rawBis.push(bis);
  }
  log(`Bisectors computed: ${rawBis.length}.`);

  // Materials with clipping to z>=0
  const bisOpacity = parseFloat(bisOp.value);
  const matSphere = new THREE.MeshStandardMaterial({ transparent:true, opacity:bisOpacity, metalness:0.0, roughness:0.95, side:THREE.DoubleSide, clippingPlanes:[clipPlane] });
  const matPlane  = new THREE.MeshStandardMaterial({ transparent:true, opacity:Math.min(bisOpacity,0.15), metalness:0.0, roughness:1.0, side:THREE.DoubleSide, clippingPlanes:[clipPlane] });

  // Draw bisector surfaces
  if (showBis.checked){
    for (const bis of rawBis){
      if (bis.type === "sphere"){
        if (!(bis.r2 > 1e-10)) continue;
        const R = Math.sqrt(bis.r2);
        const geo = new THREE.SphereGeometry(R, 48, 32);
        const mesh = new THREE.Mesh(geo, matSphere.clone());
        mesh.position.set(bis.center.re, bis.center.im, 0);
        gBis.add(mesh);
      } else {
        // plane: 2 Re(β w) + δ = 0 -> n=(2β.re, -2β.im, 0)
        const nx = 2*bis.beta.re, ny = -2*bis.beta.im, nz = 0;
        const lenN = Math.hypot(nx, ny);
        if (lenN < 1e-12) continue;
        const nUnit = new THREE.Vector3(nx/lenN, ny/lenN, 0);
        const dPrime = bis.delta / lenN;
        const geo = new THREE.PlaneGeometry(80, 80, 1, 1);
        const mesh = new THREE.Mesh(geo, matPlane.clone());
        // orient +Z to nUnit
        const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), nUnit);
        mesh.quaternion.copy(q);
        // position so that n·x + δ = 0 -> x0 = -d' nUnit
        mesh.position.copy(nUnit.clone().multiplyScalar(-dPrime));
        gBis.add(mesh);
      }
    }
  }

  // Orbit points g·j (limit count)
  if (showOrbit.checked){
    const sphGeo = new THREE.SphereGeometry(0.05, 12, 12);
    const matO = new THREE.MeshStandardMaterial({ color: 0x99ccff, clippingPlanes:[clipPlane] });
    const MAX = Math.min(600, elems.length);
    for (let i=0;i<MAX;i++){
      const g = elems[i];
      const Q = hermitian_Q_from_g(M2C.normalizeSL2(g));
      const {w,t} = pointFromHermitian(Q);
      const m = new THREE.Mesh(sphGeo, matO);
      m.position.set(w.re, w.im, t);
      gOrbit.add(m);
    }
    // basepoint j
    const base = new THREE.Mesh(new THREE.SphereGeometry(0.07, 16, 16), new THREE.MeshStandardMaterial({ color:0xffcc66, clippingPlanes:[clipPlane] }));
    base.position.set(0,0,1);
    gOrbit.add(base);
  }

  // Boundary point cloud (near the intersection of half-spaces)
  if (showCloud.checked){
    log("Sampling Dirichlet boundary...");
    const N = Math.max(1000, Math.min(50000, parseInt(pts.value)));
    const epsVal = Math.max(1e-5, Math.min(0.2, parseFloat(eps.value)));

    // bounding box from some orbit points
    const ptsTmp = [];
    for (let i=0;i<Math.min(300, elems.length); i++){
      const {w,t} = pointFromHermitian(hermitian_Q_from_g(M2C.normalizeSL2(elems[i])));
      ptsTmp.push({w,t});
    }
    let Rxy=3, zMax=3;
    for (const p of ptsTmp){
      Rxy = Math.max(Rxy, Math.hypot(p.w.re, p.w.im)+1.5);
      zMax = Math.max(zMax, p.t + 1.5);
    }
    const zMin = 0.04;

    const positions = new Float32Array(N*3);
    let count=0, tried=0;
    const psize = parseFloat(ptSize.value);
    const ptsMat = new THREE.PointsMaterial({ size: psize, opacity: parseFloat(cloudOp.value), transparent:true, clippingPlanes:[clipPlane] });

    while (count < N && tried < N*35){
      // random in cylinder
      const r = Rxy*Math.sqrt(Math.random());
      const theta = 2*Math.PI*Math.random();
      const x = r*Math.cos(theta), y = r*Math.sin(theta);
      const t = zMin + (zMax-zMin)*Math.random();

      let ok=true, minAbs=Infinity;
      for (const bis of rawBis){
        const s = sValue(bis, x, y, t);
        if (s > 1e-8){ ok=false; break; }
        const a = Math.abs(s);
        if (a<minAbs) minAbs=a;
      }
      if (ok && minAbs < epsVal){
        positions[3*count+0]=x;
        positions[3*count+1]=y;
        positions[3*count+2]=t;
        count++;
      }
      tried++;
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions.subarray(0,3*count), 3));
    const cloud = new THREE.Points(geo, ptsMat);
    gCloud.add(cloud);
    log(`Boundary samples placed: ${count}/${N} (R≈${Rxy.toFixed(1)}, z∈[${zMin},${zMax.toFixed(1)}])`);
  }

  log("Done.");
};
</script>
</body>
</html>