<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shadertoy-style Wrapper (WebGL2)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0e13; }
    #c { width:100%; height:100%; display:block; }
    .hud { position:fixed; left:12px; bottom:12px; color:#cbd5e1; font:12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; opacity:.8; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">Drag to scroll; resize window to scale. Î“-corrected output.</div>
<script>
(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl2', { antialias:false, preserveDrawingBuffer:true });
  if (!gl) { alert('WebGL2 not supported'); return; }

  // --- Vertex + Fragment shaders (Shadertoy-style wrapper) ---
  const vertSrc = `#version 300 es\n
  precision highp float;\n
  // Fullscreen triangle via gl_VertexID
  void main(){
    vec2 p = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2);
    gl_Position = vec4(p * 2.0 - 1.0, 0.0, 1.0);
  }`;

  const fragSrc = `#version 300 es\n
  precision highp float;\n
  // Shadertoy-style uniforms
  uniform vec3 iResolution;   // (width, height, 1.0)
  uniform float iTime;        // seconds since start

  out vec4 outColor;\n
  
  vec3 color(vec3 z) {
      int i;
      float res = 0.0;
      for (i=0; i<160; i++) {
          z.x = mod(z.x + 1.0,4.0) - 1.0; 
          if (z.x > 1.0) {
              z.x = 2.0-z.x;
          } // Move x into [-1,1] reflection interval
          
          if (z.y < -1.0) {
              z.y = -2.0 - z.y;
          } // Move y into [-1,inf) reflection interval
          res += float(int((z.y+1.0) / 2.0));
          z.y = mod(z.y + 1.0, 4.0) - 1.0;
          if (z.y > 1.0) {
              z.y = 2.0 - z.y;
              res += 1.0;
          }
          if (dot(z,z) < 2.0) {
              z /= -0.5 * dot(z,z);
              z.z = abs(z.z);
              res = -res;
          } else {
              break;
          }
      }
      if (i%2!=0) {
          res = -res;
      }
      float col = 1.0 - 1.0 / abs(res);
      if (res > 0.0) { 
          return col * vec3(1.0, 0.7098, 0.0); // Gold
      } else {
          return col * vec3(0.0, 0.2118, 0.3765); // Blue
      }
  }

  void mainImage( out vec4 fragColor, in vec2 fragCoord )
  {
      vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;
      float ds = 1.0 / iResolution.y;

      float t = iTime * 0.5;
      float period = 4.0 * log(2.0 + sqrt(5.0));
      while (t > period * 0.5) {
          t -= period;
      }

      vec3 z = vec3(uv, 1.3 * ds);
      z *= exp(-t);

      z.x -= sqrt(0.05);
      z /= dot(z,z);
      z.x += sqrt(5.0);

      fragColor = vec4(color(z),1.0);
      fragColor = pow(fragColor, vec4(1.0/2.2));
  }

  void main(){
    vec4 col; 
    mainImage(col, gl_FragCoord.xy);
    outColor = col;
  }
  `;

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(sh);
      console.error(info); throw new Error(info);
    }
    return sh;
  }

  const vs = compile(gl.VERTEX_SHADER, vertSrc);
  const fs = compile(gl.FRAGMENT_SHADER, fragSrc);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    const info = gl.getProgramInfoLog(prog);
    console.error(info); throw new Error(info);
  }
  gl.useProgram(prog);

  const uTime = gl.getUniformLocation(prog, 'iTime');
  const uRes  = gl.getUniformLocation(prog, 'iResolution');

  function resize(){
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    const w = Math.floor(gl.canvas.clientWidth * dpr);
    const h = Math.floor(gl.canvas.clientHeight * dpr);
    if (gl.canvas.width !== w || gl.canvas.height !== h){
      gl.canvas.width = w; gl.canvas.height = h;
    }
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }

  function fit(){
    // Make canvas fill the window
    canvas.width = canvas.clientWidth; // CSS controls size
    canvas.height = canvas.clientHeight;
    resize();
  }

  const observer = new ResizeObserver(fit);
  observer.observe(canvas);
  fit();

  const start = performance.now();
  function frame(){
    const t = (performance.now() - start) / 1000;
    gl.uniform1f(uTime, t);
    gl.uniform3f(uRes, gl.drawingBufferWidth, gl.drawingBufferHeight, 1.0);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>