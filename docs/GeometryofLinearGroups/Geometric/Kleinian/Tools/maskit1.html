<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fractal Explorer (Riley Slice)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŒ€</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden flex flex-col h-screen">

    <!-- Main Content -->
    <main class="flex-grow relative w-full h-full">
        <canvas id="fractalCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        
        <!-- Loading Indicator -->
        <div id="loader" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 hidden flex-col items-center gap-2">
            <div class="loader"></div>
            <p class="text-gray-300">Rendering...</p>
        </div>
    </main>

    <!-- Control Panel -->
    <div class="bg-gray-800/80 backdrop-blur-sm p-4 w-full flex-shrink-0">
        <div class="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4 items-center">
            
            <!-- Mouse Position -->
            <div class="text-sm">
                <p class="font-bold text-gray-300">Cursor Position (Âµ)</p>
                <p id="mouseCoords" class="text-mono text-cyan-400">-</p>
            </div>

            <!-- Viewport Info -->
            <div class="text-sm">
                <p class="font-bold text-gray-300">View Center</p>
                <p id="viewCenter" class="text-mono text-green-400">-</p>
            </div>

            <!-- Controls -->
            <div class="md:col-span-1 lg:col-span-2 flex flex-col sm:flex-row gap-4 items-center justify-end">
                <div class="w-full sm:w-auto flex items-center gap-3">
                    <label for="qualitySlider" class="text-sm font-medium whitespace-nowrap">Quality:</label>
                    <input type="range" id="qualitySlider" min="4" max="12" value="8" class="w-full sm:w-32 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <span id="qualityValue" class="text-sm font-bold w-6 text-right">8</span>
                </div>
                <button id="resetButton" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Reset View
                </button>
            </div>

        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const mouseCoordsEl = document.getElementById('mouseCoords');
        const viewCenterEl = document.getElementById('viewCenter');
        const qualitySlider = document.getElementById('qualitySlider');
        const qualityValueEl = document.getElementById('qualityValue');
        const resetButton = document.getElementById('resetButton');
        const loader = document.getElementById('loader');

        // --- Global State ---
        let view = {
            center: { re: 0.0, im: 0.0 },
            scale: 4.0 
        };
        let maxDepth = 8;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let renderTimeout;
        let isRendering = false;
        let worker;

        // --- Drawing and Rendering ---
        function drawFractal() {
            if (isRendering) {
                if(worker) worker.terminate();
            }
            isRendering = true;
            loader.classList.remove('hidden');
            loader.classList.add('flex');
            
            worker = new Worker(URL.createObjectURL(new Blob([`
                // --- Worker Code ---
                const complex = {
                    add: (c1, c2) => ({ re: c1.re + c2.re, im: c1.im + c2.im }),
                    mul: (c1, c2) => ({
                        re: c1.re * c2.re - c1.im * c2.im,
                        im: c1.re * c2.im + c1.im * c2.re
                    }),
                };
                
                const mat_mul = (m1, m2) => {
                    const a = complex.add(complex.mul(m1[0], m2[0]), complex.mul(m1[1], m2[2]));
                    const b = complex.add(complex.mul(m1[0], m2[1]), complex.mul(m1[1], m2[3]));
                    const c = complex.add(complex.mul(m1[2], m2[0]), complex.mul(m1[3], m2[2]));
                    const d = complex.add(complex.mul(m1[2], m2[1]), complex.mul(m1[3], m2[3]));
                    return [a, b, c, d];
                };

                function checkPoint(mu, maxDepth) {
                    const TRACE_EPSILON = 1e-9;

                    // Generator matrices for the Riley Slice
                    const MA = [{re:1, im:0}, {re:1, im:0}, {re:0, im:0}, {re:1, im:0}];
                    const MA_inv = [{re:1, im:0}, {re:-1, im:0}, {re:0, im:0}, {re:1, im:0}];
                    const MB = [{re:1, im:0}, {re:0, im:0}, mu, {re:1, im:0}];
                    const MB_inv = [{re:1, im:0}, {re:0, im:0}, {re:-mu.re, im:-mu.im}, {re:1, im:0}];

                    const gens = [MA, MB, MA_inv, MB_inv];
                    const inv_map = [2, 3, 0, 1];
                    
                    const queue = [];
                    for(let i = 0; i < 4; i++) {
                        queue.push({ M: gens[i], last_gen_idx: i, depth: 1 });
                    }
                    let head = 0;

                    while(head < queue.length) {
                        const { M, last_gen_idx, depth } = queue[head++];

                        const trace = complex.add(M[0], M[3]);
                        
                        if (Math.abs(trace.im) < TRACE_EPSILON && Math.abs(trace.re) < 2.0 - TRACE_EPSILON) {
                             return { inSet: false, depth: depth };
                        }

                        if (depth >= maxDepth) continue;

                        for (let i = 0; i < 4; i++) {
                            if (i === inv_map[last_gen_idx]) continue;
                            const next_M = mat_mul(M, gens[i]);
                            queue.push({ M: next_M, last_gen_idx: i, depth: depth + 1 });
                        }
                    }

                    return { inSet: true, depth: maxDepth };
                }
                
                self.onmessage = function(e) {
                    const { width, height, view, maxDepth } = e.data;
                    const imageData = new Uint8ClampedArray(width * height * 4);
                    const aspect = width / height;

                    for (let px = 0; px < width; px++) {
                        for (let py = 0; py < height; py++) {
                            const mu = {
                                re: view.center.re + (px / width - 0.5) * view.scale * aspect,
                                im: view.center.im - (py / height - 0.5) * view.scale
                            };
                            
                            const result = checkPoint(mu, maxDepth);
                            const index = (py * width + px) * 4;
                            
                            if (result.inSet) {
                                imageData[index] = 15;
                                imageData[index + 1] = 25;
                                imageData[index + 2] = 40;
                                imageData[index + 3] = 255;
                            } else {
                                const factor = Math.pow(result.depth / maxDepth, 0.4);
                                imageData[index] = 210 * factor;
                                imageData[index + 1] = 230 * factor;
                                imageData[index + 2] = 255;
                                imageData[index + 3] = 255;
                            }
                        }
                    }
                    postMessage(imageData);
                };
            `], { type: 'application/javascript' })));

            worker.onmessage = (e) => {
                const imageData = new ImageData(e.data, canvas.width, canvas.height);
                ctx.putImageData(imageData, 0, 0);
                isRendering = false;
                loader.classList.add('hidden');
                loader.classList.remove('flex');
                worker = null;
            };

            worker.onerror = (e) => {
                console.error('Worker error:', e);
                isRendering = false;
                loader.classList.add('hidden');
                loader.classList.remove('flex');
                worker = null;
            };

            worker.postMessage({
                width: canvas.width,
                height: canvas.height,
                view: view,
                maxDepth: maxDepth
            });
        }

        // --- UI and Event Handlers ---
        function updateUI() {
            viewCenterEl.textContent = `Re: ${view.center.re.toFixed(4)}, Im: ${view.center.im.toFixed(4)}`;
            qualityValueEl.textContent = maxDepth;
        }
        
        function pixelToComplex(x, y) {
            const aspect = canvas.width / canvas.height;
            return {
                re: view.center.re + (x / canvas.width - 0.5) * view.scale * aspect,
                im: view.center.im - (y / canvas.height - 0.5) * view.scale
            };
        }

        function handleResize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            requestRender();
        }

        function requestRender() {
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(drawFractal, 150);
        }

        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            panStart.x = e.clientX;
            panStart.y = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const c = pixelToComplex(e.clientX - rect.left, e.clientY - rect.top);
            mouseCoordsEl.textContent = `Re: ${c.re.toFixed(4)}, Im: ${c.im.toFixed(4)}`;

            if (isPanning) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                const aspect = canvas.width / canvas.height;

                view.center.re -= (dx / canvas.width) * view.scale * aspect;
                view.center.im += (dy / canvas.height) * view.scale;

                panStart.x = e.clientX;
                panStart.y = e.clientY;
                
                updateUI();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isPanning) {
                isPanning = false;
                requestRender();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            mouseCoordsEl.textContent = '-';
            if (isPanning) {
                isPanning = false;
                requestRender();
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.15;
            const rect = canvas.getBoundingClientRect();
            const mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            const c_before = pixelToComplex(mousePos.x, mousePos.y);

            if (e.deltaY < 0) {
                view.scale /= zoomFactor;
            } else {
                view.scale *= zoomFactor;
            }

            const c_after = pixelToComplex(mousePos.x, mousePos.y);
            view.center.re += c_before.re - c_after.re;
            view.center.im += c_before.im - c_after.im;

            updateUI();
            requestRender();
        });

        qualitySlider.addEventListener('input', (e) => {
            maxDepth = parseInt(e.target.value);
            updateUI();
        });
        
        qualitySlider.addEventListener('change', () => {
             requestRender();
        });

        resetButton.addEventListener('click', () => {
            view.center = { re: 0.0, im: 0.0 };
            view.scale = 4.0;
            qualitySlider.value = 8;
            maxDepth = 8;
            updateUI();
            requestRender();
        });

        // --- Initialization ---
        function init() {
            window.addEventListener('resize', handleResize);
            handleResize();
            updateUI();
        }

        init();
    </script>
</body>
</html>
