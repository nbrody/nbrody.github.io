<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keen-Series Word, Matrix & Root Plotter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .card {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
            font-weight: 600;
            border-radius: 0.5rem;
            padding: 0.75rem 1.5rem;
            transition: background-color 0.3s, transform 0.2s;
        }
        .btn-primary:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }
        .input-field {
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .input-field:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.3);
        }
        .result-box {
            background-color: #f3f4f6;
            border: 1px dashed #d1d5db;
            border-radius: 0.75rem;
            padding: 1rem 1.5rem;
            min-height: 80px;
            word-break: break-all;
        }
        .plot-canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 1/1;
            background-color: #f9fafb;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db;
        }
        .matrix-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 1rem;
            border-left: 2px solid #4f46e5;
            border-right: 2px solid #4f46e5;
            border-radius: 8px;
            width: fit-content;
            margin: 0 auto;
        }
        .matrix-cell {
            background-color: #eef2ff;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 500;
            font-size: 1rem;
            color: #3730a3;
            word-break: break-all;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="card w-full max-w-6xl p-6 md:p-8">
        <div class="text-center">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">Pleating Ray Word, Matrix & Root Plotter</h1>
            <p class="mt-2 text-gray-600">Enter p/q to find the Keen-Series word, its matrix, and plots of its characteristic roots.</p>
        </div>

        <!-- Input Section -->
        <div class="mt-8">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center max-w-xl mx-auto">
                <div>
                    <label for="numerator" class="block text-sm font-medium text-gray-700">Numerator (p)</label>
                    <input type="number" id="numerator" class="input-field mt-1 block w-full" placeholder="e.g., 3">
                </div>
                <div>
                    <label for="denominator" class="block text-sm font-medium text-gray-700">Denominator (q)</label>
                    <input type="number" id="denominator" class="input-field mt-1 block w-full" placeholder="e.g., 8">
                </div>
            </div>
            <div class="mt-6 text-center">
                <button id="generateBtn" class="btn-primary">Generate</button>
            </div>
        </div>

        <!-- Error Message Area -->
        <div id="error-message" class="mt-4 text-center text-red-600 font-medium"></div>

        <!-- Result Section -->
        <div class="mt-8 space-y-8">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-center">
                 <div>
                    <h2 class="text-lg font-semibold text-gray-800 text-center">Resulting Word:</h2>
                    <div id="result-word" class="result-box mt-2 text-gray-700 font-mono text-base flex items-center justify-center">
                        <span class="text-gray-400">Result will appear here...</span>
                    </div>
                </div>
                <div>
                    <h2 class="text-lg font-semibold text-gray-800 text-center">Resulting Matrix (in t):</h2>
                    <div id="result-matrix" class="result-box mt-2 flex items-center justify-center">
                         <span class="text-gray-400">Matrix will be calculated here...</span>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <div>
                     <h2 class="text-lg font-semibold text-gray-800 text-center">Zeros of Bottom-Left</h2>
                     <p class="text-sm text-center text-gray-500 mb-2">Roots of c(t) = 0</p>
                     <div class="mt-2">
                        <canvas id="plot-canvas-c" class="plot-canvas" width="500" height="500"></canvas>
                     </div>
                </div>
                <div>
                     <h2 class="text-lg font-semibold text-gray-800 text-center">Parabolic Locus (-2)</h2>
                     <p class="text-sm text-center text-gray-500 mb-2">Roots of a(t) + d(t) = -2</p>
                     <div class="mt-2">
                        <canvas id="plot-canvas-trace-neg" class="plot-canvas" width="500" height="500"></canvas>
                     </div>
                </div>
                 <div>
                     <h2 class="text-lg font-semibold text-gray-800 text-center">Parabolic Locus (+2)</h2>
                     <p class="text-sm text-center text-gray-500 mb-2">Roots of a(t) + d(t) = 2</p>
                     <div class="mt-2">
                        <canvas id="plot-canvas-trace-pos" class="plot-canvas" width="500" height="500"></canvas>
                     </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Complex Number Helper ---
        class Complex {
            constructor(re = 0, im = 0) { this.re = re; this.im = im; }
            add(z) { return new Complex(this.re + z.re, this.im + z.im); }
            sub(z) { return new Complex(this.re - z.re, this.im - z.im); }
            mul(z) { return new Complex(this.re * z.re - this.im * z.im, this.re * z.im + this.im * z.re); }
            div(z) {
                const den = z.re * z.re + z.im * z.im;
                if (den === 0) return new Complex(Infinity, Infinity);
                return new Complex((this.re * z.re + this.im * z.im) / den, (this.im * z.re - this.re * z.im) / den);
            }
            abs() { return Math.sqrt(this.re * this.re + this.im * this.im); }
            static pow(z, n) {
                let result = new Complex(1, 0);
                for (let i = 0; i < n; i++) result = result.mul(z);
                return result;
            }
        }

        // --- Polynomial Helper Functions ---
        function polyAdd(p1, p2) {
            const result = { ...p1 };
            for (const pow in p2) {
                result[pow] = (result[pow] || 0) + p2[pow];
            }
            return result;
        }

        function polyMultiply(p1, p2) {
            const result = {};
            for (const pow1 in p1) {
                for (const pow2 in p2) {
                    const newPow = Number(pow1) + Number(pow2);
                    const newCoeff = p1[pow1] * p2[pow2];
                    result[newPow] = (result[newPow] || 0) + newCoeff;
                }
            }
            return result;
        }

        function polyToString(p) {
            const cleaned_p = {};
            for (const pow in p) {
                if (Math.abs(p[pow]) > 1e-9) { cleaned_p[pow] = p[pow]; }
            }
            p = cleaned_p;
            if (Object.keys(p).length === 0) return '0';
            const terms = Object.keys(p).map(Number).sort((a, b) => b - a).map(pow => {
                const coeff = p[pow];
                if (coeff === 0) return null;
                let coeffStr = (Math.abs(coeff) === 1 && pow !== 0) ? (coeff === 1 ? '' : '-') : `${coeff}`;
                let powStr = (pow === 0) ? '' : (pow === 1 ? 't' : `t^${pow}`);
                if (pow === 0) return `${coeff}`;
                return `${coeffStr}${powStr}`;
            }).filter(term => term !== null);
            if (terms.length === 0) return '0';
            let result = terms[0];
            for (let i = 1; i < terms.length; i++) {
                result += terms[i].startsWith('-') ? ` - ${terms[i].substring(1)}` : ` + ${terms[i]}`;
            }
            return result;
        }

        function polyToCoeffs(p) {
            if (!p || Object.keys(p).length === 0) return [0];
            const degree = Math.max(0, ...Object.keys(p).map(Number));
            const coeffs = new Array(degree + 1).fill(0);
            for (const pow in p) {
                coeffs[degree - Number(pow)] = p[pow];
            }
            return coeffs;
        }

        function evalPoly(coeffs, z) {
            let result = new Complex(0, 0);
            for (let i = 0; i < coeffs.length; i++) {
                const power = coeffs.length - 1 - i;
                result = result.add(new Complex(coeffs[i], 0).mul(Complex.pow(z, power)));
            }
            return result;
        }

        // --- Root Finding (Durand-Kerner Method) ---
        function findRoots(coeffs, iterations = 100, tolerance = 1e-7) {
            const degree = coeffs.length - 1;
            if (degree < 1) return [];
            const leadingCoeff = coeffs[0];
            if (Math.abs(leadingCoeff) < 1e-9) return [];
            coeffs = coeffs.map(c => c / leadingCoeff);
            let roots = [];
            let p = new Complex(0.4, 0.8);
            for (let i = 0; i < degree; i++) {
                roots.push(Complex.pow(p, i));
            }
            for (let i = 0; i < iterations; i++) {
                let maxChange = 0;
                const nextRoots = roots.slice();
                for (let j = 0; j < degree; j++) {
                    let denominator = new Complex(1, 0);
                    for (let k = 0; k < degree; k++) {
                        if (j !== k) {
                            denominator = denominator.mul(roots[j].sub(roots[k]));
                        }
                    }
                    const numerator = evalPoly(coeffs, roots[j]);
                    if (denominator.abs() < 1e-9) continue;
                    const correction = numerator.div(denominator);
                    nextRoots[j] = roots[j].sub(correction);
                    const change = correction.abs();
                    if (change > maxChange) maxChange = change;
                }
                roots = nextRoots;
                if (maxChange < tolerance) break;
            }
            return roots;
        }

        // --- Plotting ---
        function plotRoots(canvas, roots) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);

            // Set a fixed window of [-4, 4] on both axes
            const maxAbs = 4.0;
            const scale = width / (2 * maxAbs);
            const centerX = width / 2;
            const centerY = height / 2;

            // Draw axes
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY); // Real axis
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height); // Imaginary axis
            ctx.strokeStyle = '#d1d5db';
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('4', width - 10, centerY + 5);
            ctx.textAlign = 'left';
            ctx.fillText('-4', 10, centerY + 5);
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText('4i', centerX - 8, 10);
            ctx.fillText('-4i', centerX - 8, height - 10);

            // Draw unit circle for reference
            ctx.beginPath();
            ctx.arc(centerX, centerY, scale, 0, 2 * Math.PI);
            ctx.strokeStyle = '#e5e7eb';
            ctx.stroke();

            // Plot roots
            roots.forEach(root => {
                if (!isFinite(root.re) || !isFinite(root.im)) return;
                // Only plot roots within the [-4, 4] window
                if (Math.abs(root.re) <= maxAbs && Math.abs(root.im) <= maxAbs) {
                    const x = centerX + root.re * scale;
                    const y = centerY - root.im * scale; // Y is inverted in canvas
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4f46e5';
                    ctx.fill();
                    ctx.strokeStyle = '#3730a3';
                    ctx.stroke();
                }
            });
        }

        // --- Main Generation Logic ---
        const numeratorInput = document.getElementById('numerator');
        const denominatorInput = document.getElementById('denominator');
        const generateBtn = document.getElementById('generateBtn');
        const resultWordDiv = document.getElementById('result-word');
        const resultMatrixDiv = document.getElementById('result-matrix');
        const errorDiv = document.getElementById('error-message');
        const canvasC = document.getElementById('plot-canvas-c');
        const canvasTraceNeg = document.getElementById('plot-canvas-trace-neg');
        const canvasTracePos = document.getElementById('plot-canvas-trace-pos');

        function getContinuedFraction(p, q) {
            const coeffs = [];
            let tempP = p; let tempQ = q;
            while (tempP > 0) {
                const a = Math.floor(tempQ / tempP);
                coeffs.push(a);
                const remainder = tempQ % tempP;
                tempQ = tempP; tempP = remainder;
            }
            return coeffs;
        }
        function generateWord(coeffs) {
            let w_prev = 'Y'; let w_curr = 'X';
            for (const a of coeffs) {
                const w_next = w_curr.repeat(a) + w_prev;
                w_prev = w_curr; w_curr = w_next;
            }
            return w_curr;
        }
        function multiplyMatrices(A, B) {
            const [a, b] = A[0]; const [c, d] = A[1];
            const [e, f] = B[0]; const [g, h] = B[1];
            return [
                [polyAdd(polyMultiply(a, e), polyMultiply(b, g)), polyAdd(polyMultiply(a, f), polyMultiply(b, h))],
                [polyAdd(polyMultiply(c, e), polyMultiply(d, g)), polyAdd(polyMultiply(c, f), polyMultiply(d, h))]
            ];
        }
        function calculateMatrix(word) {
            const matrixX = [[{0:1}, {0:1}], [{0:0}, {0:1}]];
            const matrixY = [[{0:1}, {0:0}], [{1:1}, {0:1}]];
            let resultMatrix = [[{0:1}, {0:0}], [{0:0}, {0:1}]];
            for (let i = 0; i < word.length; i++) {
                const char = word[i];
                if (char === 'X') resultMatrix = multiplyMatrices(resultMatrix, matrixX);
                else if (char === 'Y') resultMatrix = multiplyMatrices(resultMatrix, matrixY);
            }
            return resultMatrix;
        }

        function handleGeneration() {
            resultWordDiv.innerHTML = '<span class="text-gray-400">Calculating...</span>';
            resultMatrixDiv.innerHTML = '<span class="text-gray-400">Matrix will be calculated here...</span>';
            errorDiv.textContent = '';
            plotRoots(canvasC, []);
            plotRoots(canvasTraceNeg, []);
            plotRoots(canvasTracePos, []);

            const p = parseInt(numeratorInput.value, 10);
            const q = parseInt(denominatorInput.value, 10);

            if (isNaN(p) || isNaN(q) || q <= 0 || p <= 0 || p >= q) {
                errorDiv.textContent = 'Please enter valid integers for p and q where 0 < p < q.';
                resultWordDiv.innerHTML = '<span class="text-gray-400">Result will appear here...</span>';
                return;
            }

            try {
                const coeffs = getContinuedFraction(p, q);
                const word = generateWord(coeffs);
                const matrix = calculateMatrix(word);
                
                resultWordDiv.textContent = word;
                
                if (matrix && matrix.length === 2 && matrix[0].length === 2 && matrix[1].length === 2) {
                    resultMatrixDiv.innerHTML = `
                        <div class="matrix-grid">
                            <div class="matrix-cell">${polyToString(matrix[0][0])}</div>
                            <div class="matrix-cell">${polyToString(matrix[0][1])}</div>
                            <div class="matrix-cell">${polyToString(matrix[1][0])}</div>
                            <div class="matrix-cell">${polyToString(matrix[1][1])}</div>
                        </div>
                    `;

                    const polyA = matrix[0][0];
                    const polyD = matrix[1][1];
                    const polyTrace = polyAdd(polyA, polyD);

                    // Plot roots of c(t) = 0
                    const polyC = matrix[1][0];
                    const coeffsC = polyToCoeffs(polyC);
                    const rootsC = findRoots(coeffsC);
                    plotRoots(canvasC, rootsC);

                    // Plot roots of a(t) + d(t) + 2 = 0
                    const polyTraceNeg = polyAdd(polyTrace, {0: 2}); 
                    const coeffsTraceNeg = polyToCoeffs(polyTraceNeg);
                    const rootsTraceNeg = findRoots(coeffsTraceNeg);
                    plotRoots(canvasTraceNeg, rootsTraceNeg);

                    // Plot roots of a(t) + d(t) - 2 = 0
                    const polyTracePos = polyAdd(polyTrace, {0: -2});
                    const coeffsTracePos = polyToCoeffs(polyTracePos);
                    const rootsTracePos = findRoots(coeffsTracePos);
                    plotRoots(canvasTracePos, rootsTracePos);
                } else {
                    resultMatrixDiv.innerHTML = '<span class="text-red-500">Error: Could not compute matrix.</span>';
                }

            } catch (e) {
                errorDiv.textContent = 'An unexpected error occurred.';
                console.error(e);
            }
        }

        generateBtn.addEventListener('click', handleGeneration);
        [numeratorInput, denominatorInput].forEach(input => {
             input.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleGeneration(); });
        });
        
        window.onload = () => {
             plotRoots(canvasC, []);
             plotRoots(canvasTraceNeg, []);
             plotRoots(canvasTracePos, []);
        }

    </script>
</body>
</html>
