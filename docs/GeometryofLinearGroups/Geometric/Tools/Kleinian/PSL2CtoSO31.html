<!DOCTYPE html>
<html lang="en" class="min-h-screen">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSL(2,C) to SO(3,1) Calculator</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for better typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code&display=swap"
        rel="stylesheet">
    <script>
        // Configuration for Tailwind CSS dark mode
        tailwind.config = {
            darkMode: 'class', // or 'media'
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Fira Code', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Basic styling for dark mode and layout */
        html {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$','$$'], ['\\[','\\]']],
          processEscapes: true
        },
        options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] },
        svg: { fontCache: 'global' }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body
    class="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans flex items-start justify-center p-4 overflow-y-auto">

    <div id="app-container" class="w-full max-w-screen-2xl mx-auto">
        <!-- The user interface will be generated and injected here by the script -->
    </div>

    <script>

        // Given g = [[a,b],[c,d]] in SL2(C), compute the corresponding element of SO^+(3,1)
        // via the standard action on 2x2 Hermitian matrices: H -> g H g^†.
        // We identify Minkowski vectors (x,y,z,t) with Hermitian matrices
        //   H(t,x,y,z) = [[t + z, x + i y], [x - i y, t - z]]
        // so that det(H) = - x^2 - y^2 - z^2 + t^2.
        // The resulting 4x4 real matrix Λ satisfies v' = Λ v for v ∈ R^{3,1}.

        // ------------------ Complex helpers ------------------
        function toC(z) {
            if (typeof z === 'number') return { re: z, im: 0 };
            if (z && typeof z.re === 'number' && typeof z.im === 'number') return { re: z.re, im: z.im };
            throw new Error('Complex inputs must be numbers or {re,im} objects');
        }
        function C(re, im) { return { re, im }; }
        function cAdd(z, w) { return C(z.re + w.re, z.im + w.im); }
        function cSub(z, w) { return C(z.re - w.re, z.im - w.im); }
        function cMul(z, w) { return C(z.re * w.re - z.im * w.im, z.re * w.im + z.im * w.re); }
        function cConj(z) { return C(z.re, -z.im); }

        // 2x2 complex matrix helpers
        function cMatMul2(A, B) {
            return [
                [cAdd(cMul(A[0][0], B[0][0]), cMul(A[0][1], B[1][0])),
                cAdd(cMul(A[0][0], B[0][1]), cMul(A[0][1], B[1][1]))],
                [cAdd(cMul(A[1][0], B[0][0]), cMul(A[1][1], B[1][0])),
                cAdd(cMul(A[1][0], B[0][1]), cMul(A[1][1], B[1][1]))]
            ];
        }
        function cMatAdjoint2(A) {
            return [
                [cConj(A[0][0]), cConj(A[1][0])],
                [cConj(A[0][1]), cConj(A[1][1])]
            ];
        }

        // -------- Additional Complex & 2x2 helpers (for word enumeration) --------
        function cNeg(z){ return C(-z.re, -z.im); }
        function cAbs(z){ return Math.hypot(z.re, z.im); }
        function cDiv(z,w){
            const den = w.re*w.re + w.im*w.im; if (den===0) throw new Error('Divide by zero');
            return C((z.re*w.re + z.im*w.im)/den, (z.im*w.re - z.re*w.im)/den);
        }
        function cEq(z,w, tol=1e-9){ return Math.abs(z.re-w.re)<=tol && Math.abs(z.im-w.im)<=tol; }
        function cToStr(z){
            const r = +z.re.toFixed(6), i = +z.im.toFixed(6);
            if (Math.abs(i)<1e-12) return `${r}`;
            if (Math.abs(r)<1e-12) return `${i}i`;
            return `${r}${i<0?'' : '+'}${i}i`;
        }

        function cDet2(A){ return cSub(cMul(A[0][0],A[1][1]), cMul(A[0][1],A[1][0])); }
        function cInv2(A){
            const det = cDet2(A);
            const invDet = cDiv(C(1,0), det);
            return [
                [ cMul(A[1][1],invDet), cMul(cNeg(A[0][1]),invDet) ],
                [ cMul(cNeg(A[1][0]),invDet), cMul(A[0][0],invDet) ]
            ];
        }

        function matEq2(A,B,tol=1e-9){
            for(let i=0;i<2;i++) for(let j=0;j<2;j++) if(!cEq(A[i][j],B[i][j],tol)) return false; return true;
        }
        function matKey2(A){
            // stable key for dedupe: round to 1e-9
            const f = z=>`${(+z.re.toFixed(9))}:${(+z.im.toFixed(9))}`;
            return `${f(A[0][0])}|${f(A[0][1])}|${f(A[1][0])}|${f(A[1][1])}`;
        }

        // Generate words up to length L from generators and their inverses (on 2x2 complex matrices)
        function generateWords2x2Complex(gens2x2, L){
            const initial = [];
            gens2x2.forEach((G,i)=>{
                initial.push({ m:G, word:`g${i+1}` });
                try{ initial.push({ m:cInv2(G), word:`g${i+1}^{-1}` }); }catch(_){ /* skip non-invertible */ }
            });
            const seen = new Map();
            const out = [];
            const I = [[C(1,0),C(0,0)],[C(0,0),C(1,0)]];
            const Ikey = matKey2(I);
            function pushObj(o){ const k=matKey2(o.m); if(!seen.has(k)){ seen.set(k,o); if(k!==Ikey) out.push(o);} }
            initial.forEach(pushObj);
            let frontier = initial.slice();
            for(let l=1;l<L; l++){
                const next=[];
                for(const w of frontier){
                    for(const s of initial){
                        const m = cMatMul2(w.m, s.m);
                        const obj = { m, word: `${w.word}\u22C5${s.word}` };
                        const k = matKey2(m);
                        if(!seen.has(k) && !matEq2(m,I)) { seen.set(k,obj); out.push(obj); next.push(obj);} }
                }
                frontier = next;
            }
            return out;
        }

        function __formatMat2LineSimple(A){
            return `(${cToStr(A[0][0])} ${cToStr(A[0][1])} ${cToStr(A[1][0])} ${cToStr(A[1][1])})`;
        }


        function generateGroupElements(gens, wordLength) {
                // Return [{ m: Matrix2, word: string }], excluding identity
                const elements = new Map();

                // Identity
                const I = new Matrix2(
                    new Complex(1, 0), new Complex(0, 0),
                    new Complex(0, 0), new Complex(1, 0)
                );
                const identityKey = keyFromMatrix(I);
                elements.set(identityKey, { m: I, word: 'e' });

                // Initial set: g_i and g_i^{-1}
                const initialSet = [];
                gens.forEach((g, i) => {
                    const name = `g${i + 1}`;
                    initialSet.push({ m: g, word: name });
                    const inv = g && g.inverse ? g.inverse() : null;
                    if (inv) initialSet.push({ m: inv, word: `${name}^{-1}` });
                });

                // Seed queue + map
                let queue = [];
                initialSet.forEach(obj => {
                    if (!obj || !obj.m) return;
                    const key = keyFromMatrix(obj.m);
                    if (!elements.has(key)) {
                        elements.set(key, obj);
                        queue.push(obj);
                    }
                });

                // BFS up to the requested word length
                for (let l = 1; l < (parseInt(wordLength) || 1); l++) {
                    const nextQueue = [];
                    for (const wobj of queue) {
                        for (const s of initialSet) {
                            const newM = wobj.m.multiply(s.m);
                            if (newM.isIdentity && newM.isIdentity()) continue;
                            const key = keyFromMatrix(newM);
                            if (!elements.has(key)) {
                                const newObj = { m: newM, word: wobj.word + s.word };
                                elements.set(key, newObj);
                                nextQueue.push(newObj);
                            }
                        }
                    }
                    queue = nextQueue;
                }

                // Exclude identity
                const out = [];
                for (const [k, v] of elements.entries()) {
                    if (k !== identityKey) out.push(v);
                }
                return out;
            }

        // ------------------ Minkowski <-> Hermitian ------------------
        function hermitianFromVec(v) {
            const [x, y, z, t] = v;
            return [
                [C(t + z, 0), C(x, y)],
                [C(x, -y), C(t - z, 0)]
            ];
        }
        function vecFromHermitian(H) {
            const x = H[0][1].re;
            const y = H[0][1].im;
            const z = (H[0][0].re - H[1][1].re) / 2;
            const t = (H[0][0].re + H[1][1].re) / 2;
            return [x, y, z, t];
        }

        // ------------------ Main map ------------------
        function PSL2CtoSO31(a, b, c, d) {
            const A = toC(a), B = toC(b), Cc = toC(c), D = toC(d);
            const g = [[A, B], [Cc, D]];
            const gAdj = cMatAdjoint2(g);
            const basis = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];

            const columns = basis.map(v => {
                const H = hermitianFromVec(v);
                const gHgAdj = cMatMul2(cMatMul2(g, H), gAdj);
                return vecFromHermitian(gHgAdj);
            });

            const Lambda = Array.from({ length: 4 }, (_, r) =>
                columns.map(col => {
                    const val = col[r];
                    const eps = 1e-8;
                    return Math.abs(val) < eps ? 0 : val;
                })
            );
            return Lambda;
        }

        // ------------------ sDF utilities ------------------
        const __ETA = [-1, -1, -1, +1];
        function __etaApply(v) { return [-v[0], -v[1], -v[2], v[3]]; }
        function __stdBasis(j) {
            return [0, 0, 0, 0].map((_, k) => (k === j ? 1 : 0));
        }
        function __ginv_ej(g, j) {
            // Using g^{-1} = η g^T η with η = diag(-1,-1,-1,+1).
            // Column j of g^{-1} equals: w_i = η_{ii} * g_{j i} * η_{jj}.
            const r = g[j];                 // row j of g
            const sj = (j === 3) ? 1 : -1;  // η_{jj}
            return [
                (-1) * r[0] * sj,           // η_{00} = -1
                (-1) * r[1] * sj,           // η_{11} = -1
                (-1) * r[2] * sj,           // η_{22} = -1
                (+1) * r[3] * sj            // η_{33} = +1
            ];
        }

        function sDF_autoFromSO31(g) {
            if (!Array.isArray(g) || g.length !== 4 || g.some(r => !Array.isArray(r) || r.length !== 4)) {
                throw new Error('sDF_autoFromSO31 expects a 4x4 matrix');
            }
            const eps = 1e-8;
            for (let j = 3; j >= 0; j--) {
                const s = __ETA[j];
                const w = __ginv_ej(g, j);
                const denom = s * (w[j] - 1);
                if (Math.abs(denom) < eps) {
                    continue;
                }
                const e = __stdBasis(j);
                const u = [w[0] - e[0], w[1] - e[1], w[2] - e[2], w[3] - e[3]];
                const eta_u = __etaApply(u);
                const row = eta_u;
                // Normalize sign: ensure the last nonzero coordinate is negative
                const epsSign = 1e-12;
                let lastIdx = -1;
                for (let k = 3; k >= 0; k--) {
                    if (Math.abs(row[k]) > epsSign) { lastIdx = k; break; }
                }
                if (lastIdx !== -1 && row[lastIdx] > 0) {
                    for (let k = 0; k < 4; k++) row[k] = -row[k];
                }
                return { row, pivot: j };
            }
            throw new Error('sDF undefined: g fixes all basis vectors e₀, e₁, e₂, e₃');
        }

        // Minkowski helpers (signature + + + - becomes ⟨u,v⟩ = -u_x v_x - u_y v_y - u_z v_z + u_t v_t)
        function __minkowskiDot(u, v) {
            return -(u[0]*v[0] + u[1]*v[1] + u[2]*v[2]) + u[3]*v[3];
        }
        function __etaVec(v) { return [-v[0], -v[1], -v[2], v[3]]; } // η·v
        function __norm2M(u) { return __minkowskiDot(u, u); }
        function __normalizeTimelike(u, eps=1e-12) {
            // Scale u so that ⟨u,u⟩ = +1 and t > 0 (forward sheet)
            let n2 = __norm2M(u);
            if (n2 <= eps) return null; // not timelike
            let s = 1/Math.sqrt(n2);
            let w = [u[0]*s, u[1]*s, u[2]*s, u[3]*s];
            if (w[3] < 0) w = [-w[0], -w[1], -w[2], -w[3]];
            return w;
        }
        function __projectToHyperplane(x, n) {
            // Orthogonal projection (Lorentzian metric):
            // Hyperplane H_n = { y : ⟨n, y⟩ = 0 }. For a spacelike normal n (⟨n,n⟩<0),
            // the Lorentzian orthogonal projection is x' = x - (⟨n,x⟩ / ⟨n,n⟩) * n.
            const nn = __minkowskiDot(n, n);
            if (Math.abs(nn) < 1e-16) return null; // degenerate normal
            const nx = __minkowskiDot(n, x);
            const scale = nx / nn;
            return [
                x[0] - scale * n[0],
                x[1] - scale * n[1],
                x[2] - scale * n[2],
                x[3] - scale * n[3],
            ];
        }

        // --- Half-space normalization & dedup helpers (positive-scale equivalence) ---
        function __hsNormalize(v, EPS=1e-12){
          // Flip so d >= 0; then prefer d=1 normalization when possible.
          let a=v[0], b=v[1], c=v[2], d=v[3];
          if (d < -EPS){ a=-a; b=-b; c=-c; d=-d; }
          if (Math.abs(d) > EPS){
            const s = 1/d;
            return [a*s, b*s, c*s, 1];
          } else {
            // Fallback: unit Euclidean length for (a,b,c), keep d=0.
            const n = Math.hypot(a,b,c) || 1;
            return [a/n, b/n, c/n, 0];
          }
        }
        function __hsKey(v){
          // Stable key with rounding to avoid duplicates
          return __hsNormalize(v).map(x => +x.toFixed(9)).join(',');
        }
        function __dedupeHalfspaces(rows, EPS=1e-9){
          const out = [];
          const seen = new Set();
          for (const r of rows){
            const key = __hsKey(r);
            if (!seen.has(key)){ seen.add(key); out.push(r); }
          }
          return out;
        }
        function __cosBetween(a, b){
          const ax=a[0], ay=a[1], az=a[2], bx=b[0], by=b[1], bz=b[2];
          const da = Math.hypot(ax,ay,az), db = Math.hypot(bx,by,bz);
          if (da===0 || db===0) return 1;
          return (ax*bx + ay*by + az*bz)/(da*db);
        }

        // --- New: Cone-based face-defining covector filter for sDFs [a,b,c,d] with t=1 ---
        function filterFaceDefiningCovectorsCone(rows, opts = {}) {
                // rows: [[a,b,c,d], ...] define half-spaces a x + b y + c z + d >= 0 with t fixed to 1
                // A covector v defines a face if ∃ (x,y,z) with all inequalities >= 0 and v·(x,y,z,1) = 0.
                const EPS = opts.eps ?? 1e-5;      // numeric epsilon
                const R = opts.initBox ?? 1e6;   // initial bounding box for clipping in (s,t)
                const STRICT = opts.strict_margin ?? 1e-9;  // require v·x >= STRICT for other planes

                // Pre-deduplicate by positive scaling to cut spurious copies of the same wall
                rows = __dedupeHalfspaces(rows, EPS);

                // Use covectors as given; rely on Minkowski evaluation for inequalities
                const rowsOriented = rows.map(r => [ +r[0], +r[1], +r[2], -r[3] ]);

                // Minkowski-evaluated affine and directional forms on t=1 slice
                // ⟨(a,b,c,d), (x,y,z,1)⟩ = -(a x + b y + c z) + d
                function minkowskiAffine3(aVec, xVec, d){
                  // aVec: [a,b,c], xVec: [x,y,z]
                  return -(aVec[0]*xVec[0] + aVec[1]*xVec[1] + aVec[2]*xVec[2]) + d;
                }
                function minkowskiDir3(aVec, uVec){
                  // directional coefficient along u with t fixed (Δt = 0)
                  return -(aVec[0]*uVec[0] + aVec[1]*uVec[1] + aVec[2]*uVec[2]);
                }
                function dot3(a, b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; }
                function norm2(a) { return Math.hypot(a[0], a[1], a[2]); }
                function cross(a, b) { return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]; }
                function scale(v, s) { return [v[0] * s, v[1] * s, v[2] * s]; }

                function orthonormalBasisPerp(a) {
                    let helper = Math.abs(a[0]) < 0.9 ? [1, 0, 0] : [0, 1, 0];
                    let u1 = cross(a, helper);
                    let n1 = norm2(u1);
                    if (n1 < 1e-12) { helper = [0, 0, 1]; u1 = cross(a, helper); n1 = norm2(u1); }
                    if (n1 < 1e-12) return null;
                    u1 = scale(u1, 1 / n1);
                    let u2 = cross(a, u1);
                    const n2 = norm2(u2);
                    if (n2 < 1e-12) return null;
                    u2 = scale(u2, 1 / n2);
                    return [u1, u2];
                }

                function clipHalfPlane(poly, A, B, C) {
                    if (!poly || poly.length === 0) return [];
                    const out = [];
                    const evalPt = p => A * p[0] + B * p[1] + (C - STRICT);
                    for (let i = 0; i < poly.length; i++) {
                        const P = poly[i], Q = poly[(i + 1) % poly.length];
                        const fP = evalPt(P), fQ = evalPt(Q);
                        const inP = fP >= -EPS, inQ = fQ >= -EPS;
                        if (inP && inQ) {
                            out.push(Q);
                        } else if (inP && !inQ) {
                            const denom = (A * (Q[0] - P[0]) + B * (Q[1] - P[1]));
                            if (Math.abs(denom) > 1e-18) {
                                const t = - (A * P[0] + B * P[1] + (C - STRICT)) / denom;
                                out.push([P[0] + t * (Q[0] - P[0]), P[1] + t * (Q[1] - P[1])]);
                            }
                        } else if (!inP && inQ) {
                            const denom = (A * (Q[0] - P[0]) + B * (Q[1] - P[1]));
                            if (Math.abs(denom) > 1e-18) {
                                const t = - (A * P[0] + B * P[1] + (C - STRICT)) / denom;
                                out.push([P[0] + t * (Q[0] - P[0]), P[1] + t * (Q[1] - P[1])]);
                            }
                            out.push(Q);
                        }
                    }
                    return out;
                }

                // Helper: polygon centroid
                function polyCentroid(poly){
                  if (!poly || poly.length === 0) return [0,0];
                  let sx=0, sy=0;
                  for (const p of poly){ sx += p[0]; sy += p[1]; }
                  const n = poly.length || 1;
                  return [sx/n, sy/n];
                }

                const N = rowsOriented.length;
                const survivors = [];
                const A = rowsOriented.map(r => [r[0], r[1], r[2]]);
                const D = rowsOriented.map(r => r[3]);

                for (let i = 0; i < N; i++) {
                    const ai = A[i];
                    const di = D[i];
                    const aNorm2 = norm2(ai);
                    if (!(aNorm2 > EPS)) continue; // degenerate

                    // Solve a·x0 = d with minimal-norm choice x0 = (d/||a||^2) a
                    const x0 = scale(ai, di / (aNorm2 * aNorm2));

                    const basis = orthonormalBasisPerp(ai);
                    if (!basis) continue;
                    const [u1, u2] = basis;

                    let poly = [[-R, -R], [R, -R], [R, R], [-R, R]];

                    let infeasible = false;
                    for (let j = 0; j < N; j++) if (j !== i) {
                        const aj = A[j];
                        const dj = D[j];
                        const alpha = minkowskiDir3(aj, u1);   // = -(aj·u1)
                        const beta  = minkowskiDir3(aj, u2);   // = -(aj·u2)
                        const gamma = minkowskiAffine3(aj, x0, dj); // = -(aj·x0) + dj
                        if (Math.abs(alpha) < 1e-5 && Math.abs(beta) < 1e-5) {
                            if (gamma < -EPS) { infeasible = true; break; }
                            else continue;
                        }
                        poly = clipHalfPlane(poly, alpha, beta, gamma);
                        if (!poly || poly.length === 0) { infeasible = true; break; }
                    }
                    // Area check (keep as-is)
                    if (!infeasible && poly && poly.length) {
                        // Witness validation: use centroid of polygon as (s,t), map to 3D point, check strict inequalities
                        const [cs, ct] = polyCentroid(poly);
                        // Map centroid (cs,ct) back to 3D point on the candidate wall: x = x0 + cs*u1 + ct*u2
                        const xw = [
                          x0[0] + cs*u1[0] + ct*u2[0],
                          x0[1] + cs*u1[1] + ct*u2[1],
                          x0[2] + cs*u1[2] + ct*u2[2]
                        ];
                        // Candidate should be on its wall (≈0)
                        const onWall = Math.abs(minkowskiAffine3(ai, xw, di)) <= 10*EPS;
                        if (!onWall) { infeasible = true; }
                        // All other covectors must be strictly positive at the witness
                        if (!infeasible){
                          for (let j=0; j<N; j++) if (j !== i){
                            const val = minkowskiAffine3(A[j], xw, D[j]);
                            if (!(val >= STRICT)) { infeasible = true; break; }
                          }
                        }
                    }
                    if (!infeasible && poly && poly.length) {
                        survivors.push(i);
                    }
                }
                // Post-filter: merge faces with (nearly) identical normals, keep smallest offset (most restrictive)
                const keep = [];
                const used = new Array(survivors.length).fill(false);
                for (let ii=0; ii<survivors.length; ii++){
                  if (used[ii]) continue;
                  const i = survivors[ii];
                  const ni = A[i], di = D[i];
                  let bestIdx = i, bestD = di;
                  for (let jj=ii+1; jj<survivors.length; jj++){
                    if (used[jj]) continue;
                    const j = survivors[jj];
                    const nj = A[j], dj = D[j];
                    if (__cosBetween(ni,nj) > 1 - 1e-4){
                      // Same direction; pick tighter plane (smaller d after d>=0 orientation)
                      if (dj < bestD - 1e-9){ bestD = dj; bestIdx = j; }
                      used[jj] = true;
                    }
                  }
                  used[ii] = true;
                  keep.push(bestIdx);
                }
                // Sort & unique just in case
                keep.sort((x,y)=>x-y);
                return Array.from(new Set(keep));
            }

        try { window.filterFaceDefiningCovectorsCone = filterFaceDefiningCovectorsCone; } catch(_){}

        // ------------------ UI-specific helpers ------------------
        function __parseComplex(s) {
            if (typeof s === 'number') return { re: s, im: 0 };
            // Sanitize input: trim whitespace, convert to lower case, remove internal spaces
            s = (s || '').toString().trim().toLowerCase().replace(/\s/g, '');
            if (s === '') return { re: 0, im: 0 };

            // Handle special cases for 'i' and '-i'
            if (s === 'i') return { re: 0, im: 1 };
            if (s === '-i') return { re: 0, im: -1 };

            if (s.endsWith('i')) {
                const core = s.slice(0, -1);
                // Find the sign that splits real and imaginary parts.
                // We search from the right, but ignore a potential leading sign.
                const signIndex = Math.max(core.lastIndexOf('+'), core.lastIndexOf('-'));

                if (signIndex > 0) { // A sign is found in the middle (e.g., in "1+2" or "-3-4")
                    const reStr = core.substring(0, signIndex);
                    let imStr = core.substring(signIndex);

                    // Handle cases where the imaginary part is just 'i' (e.g., "1+i")
                    if (imStr === '+') imStr = '1';
                    if (imStr === '-') imStr = '-1';

                    const re = parseFloat(reStr);
                    const im = parseFloat(imStr);
                    if (!isNaN(re) && !isNaN(im)) return { re, im };

                } else { // No middle sign, so it's a pure imaginary number (e.g., "2i" or "-3.5i")
                    // Handle case of just 'i' e.g. '1+i' -> imStr will be '+', need to handle that
                    if (core === '+' || core === '') return { re: 0, im: 1 };
                    if (core === '-') return { re: 0, im: -1 };

                    const im = parseFloat(core);
                    if (!isNaN(im)) return { re: 0, im };
                }
            } else { // No 'i' at the end, so it must be a pure real number
                const re = parseFloat(s);
                if (!isNaN(re)) return { re, im: 0 };
            }

            // If none of the above worked, the format is invalid
            throw new Error(`Cannot parse complex: "${s}"`);
        }

        function __formatMatrix4(M) {
            return M.map(row => row.map(x => Math.abs(x) < 1e-12 ? "0" : +x.toFixed(6)));
        }

        function __formatRow(v) {
            return v.map(x => Math.abs(x) < 1e-12 ? "0" : +x.toFixed(6));
        }



        // --- START: UI Generation and Event Handling (Enhanced) ---

        // --- Auto-detect payload of matrices from other tools/pages ---
        function getExternalMatricesPayload() {
            // Prefer explicit URL param ?matrices= (Base64-encoded text with lines "a b c d")
            try {
                const params = new URLSearchParams(window.location.search);
                const mParam = params.get('matrices');
                if (mParam) {
                    try {
                        const decoded = atob(decodeURIComponent(mParam));
                        if (decoded && decoded.trim().length > 0) return decoded;
                    } catch (e) {
                        console.warn('Failed to decode matrices param:', e);
                    }
                }
            } catch (e) {
                console.warn('URL parsing failed:', e);
            }
            // Fallback: localStorage key written by other pages
            try {
                const ls = localStorage.getItem('psl2c_matrices');
                if (ls && ls.trim().length > 0) return ls;
            } catch (e) {
                // ignore storage access errors
            }
            return null;
        }

        /**
         * Attaches a modern UI to the specified container.
         * @param {string|HTMLElement} containerSelector - The DOM element or selector to attach the UI to.
         */
        function attachPSL2CtoSO31Tester(containerSelector) {
            const root = (typeof containerSelector === 'string') ? document.querySelector(containerSelector) : containerSelector;
            if (!root) throw new Error('attachPSL2CtoSO31Tester: container not found');
            root.innerHTML = '';

            const card = document.createElement('div');
            card.className = "bg-white dark:bg-gray-800/50 dark:backdrop-blur-sm p-6 sm:p-8 rounded-2xl shadow-lg w-full max-w-none border border-gray-200 dark:border-gray-700";

            card.innerHTML = `
                <h2 class="text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white mb-2 tracking-tight">\\(\\mathrm{PSL}_2(\\mathbb{C}) \\to \\mathrm{SO}^{+}(3,1)\\) Calculator</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-6">Add matrices to the list. The calculation is performed for each matrix individually.</p>
                
                <div class="flex flex-wrap items-start gap-4 mb-4">
                    <div id="psl-matrix-list" class="flex flex-wrap gap-4 items-start">
                        <!-- Matrix input forms will be injected here -->
                    </div>
                    <button id="psl-add" class="h-fit px-5 py-2 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition-all duration-200 bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500 shadow-sm hover:shadow-md self-start">Add Matrix</button>
                </div>
                <div class="mt-2">
                    <button id="psl-compute" class="px-5 py-2 rounded-lg font-semibold bg-green-600 text-white hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 shadow-sm">Compute</button>
                </div>
                <div id="psl-words-table" class="mb-3"></div>
                <div id="psl-open" class="mb-6"></div>
                <div id="psl-words" class="mb-4"></div>
                <div id="psl-summary" class="mb-4"></div>
                <div class="flex flex-wrap items-center justify-start gap-4 mb-6">
                    <div class="flex flex-wrap gap-3">
                        <button id="psl-import" title="Import matrices from other tools"
                            class="px-4 py-2 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition-all duration-200 bg-emerald-100 text-emerald-800 hover:bg-emerald-200 dark:bg-emerald-900/30 dark:text-emerald-300 dark:hover:bg-emerald-900/50">Import</button>
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="psl-wordlen" class="text-sm text-gray-600 dark:text-gray-400">Word length</label>
                        <input id="psl-wordlen" type="number" min="1" value="4" class="w-20 px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md text-sm">
                    </div>
                </div>
                <div id="psl-out" class="space-y-6 bg-gray-100 dark:bg-gray-900/50 p-4 sm:p-6 rounded-xl border border-gray-200 dark:border-gray-700/50 min-h-[200px]"></div>
            `;
            root.appendChild(card);
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([card]).catch(() => {});
            }

            const el = id => card.querySelector(id);
            const out = el('#psl-out');
            const summary = el('#psl-summary');
            const matrixList = el('#psl-matrix-list');
            const wordsTableEl = el('#psl-words-table');
            const openEl = el('#psl-open');
            const wordsEl = el('#psl-words');
            let __facesExportData = [];

            // Load external matrices if present (each line: a b c d)
            function loadExternalMatricesIfAny() {
                const payload = getExternalMatricesPayload();
                if (!payload) return false;
                let loaded = 0;
                // Clear any existing forms
                matrixList.innerHTML = '';
                const lines = payload.split('\n').map(s => s.trim()).filter(Boolean);
                for (const line of lines) {
                    let toks;
                    if (line.includes(',')) {
                        toks = line.split(',').map(s => s.trim());
                    } else {
                        // Fallback: whitespace‑separated ONLY if exactly 4 tokens appear (to avoid splitting inside complex literals like "1 + 2i")
                        const ws = line.trim().split(/\s+/);
                        toks = (ws.length === 4) ? ws : null;
                    }
                    if (!toks || toks.length !== 4) continue;
                    addMatrixForm({ a: toks[0], b: toks[1], c: toks[2], d: toks[3] });
                    loaded++;
                }
                // If loaded via localStorage handoff, clear it once
                try {
                    const srcHash = (window.location.hash || '');
                    if (srcHash.includes('source=psl2c_matrices')) {
                        localStorage.removeItem('psl2c_matrices');
                    }
                } catch (e) {}
                return loaded > 0;
            }

            function addMatrixForm(values = {}) {
                const formWrapper = document.createElement('div');
                formWrapper.className = "matrix-form p-4 border dark:border-gray-600 rounded-xl relative bg-gray-50 dark:bg-gray-800/50 transition-all duration-300";

                const defaultValues = { a: '1', b: '1', c: '0', d: '1', ...values };

                formWrapper.innerHTML = `
                    <button class="remove-matrix absolute -top-2 -right-2 h-7 w-7 flex items-center justify-center bg-red-500 text-white rounded-full hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 text-sm font-bold" aria-label="Remove Matrix">&times;</button>
                    <div class="flex justify-center">
                        <div class="relative inline-block">
                            <div class="grid grid-cols-2 gap-1 font-mono w-full max-w-xs">
                                ${Object.keys(defaultValues).map(label => `
                                <div>
                                    <input data-entry="${label}" type="text" value="${defaultValues[label]}" class="auto-ch w-auto min-w-[9ch] max-w-full px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-white text-sm transition-[width]">
                                </div>`).join('')}
                            </div>
                        </div>
                    </div>
                `;
                matrixList.appendChild(formWrapper);
                // Auto-size inputs based on content length (grow with text)
                const chMin = 9, chMax = 40;
                const inputs = formWrapper.querySelectorAll('input[data-entry]');
                inputs.forEach(inp => {
                  function resize() {
                    const len = Math.max(inp.value.length, inp.placeholder ? inp.placeholder.length : 0, chMin);
                    const clamped = Math.min(Math.max(len, chMin), chMax);
                    inp.style.width = clamped + 'ch';
                  }
                  inp.addEventListener('input', resize);
                  // Initial sizing
                  resize();
                });
            }

            function readInputs() {
                const forms = matrixList.querySelectorAll('.matrix-form');
                return Array.from(forms).map(form => {
                    const a = __parseComplex(form.querySelector('[data-entry="a"]').value);
                    const b = __parseComplex(form.querySelector('[data-entry="b"]').value);
                    const c = __parseComplex(form.querySelector('[data-entry="c"]').value);
                    const d = __parseComplex(form.querySelector('[data-entry="d"]').value);
                    return [[a, b], [c, d]];
                });
            }

            function render() {
                try {
                    const matrices = readInputs();
                    if (matrices.length === 0) {
                        out.innerHTML = `<p class="text-center text-gray-500 dark:text-gray-400 py-8">Add a matrix to see the calculation.</p>`;
                        summary.innerHTML = '';
                        if (wordsTableEl) wordsTableEl.innerHTML = '';
                        if (openEl) openEl.innerHTML = '';
                        if (wordsEl) wordsEl.innerHTML = '';
                        return;
                    }

                    // 1) Declare accumulator array before building resultsHTML
                    const allCovectorLines = [];

                    const resultsHTML = matrices.map((g, index) => {
                        const [a, b, c, d] = [g[0][0], g[0][1], g[1][0], g[1][1]];

                        const ad = cMul(a, d);
                        const bc = cMul(b, c);
                        const det = cSub(ad, bc);
                        const detMagSq = det.re * det.re + det.im * det.im;

                        const detString = `det = ${det.re.toFixed(4)} ${det.im < 0 ? '-' : '+'} ${Math.abs(det.im).toFixed(4)}i`;
                        const detClass = Math.abs(detMagSq - 1) > 0.01 ? 'text-red-500 dark:text-red-400' : 'text-green-600 dark:text-green-400';

                        const M = PSL2CtoSO31(a, b, c, d);
                        const Mfmt = __formatMatrix4(M);
                        let covectorSection = '';
                        try {
                            const auto = sDF_autoFromSO31(M);
                            const sdf = auto.row;
                            const pivot = auto.pivot;
                            const sdfFmt = __formatRow(sdf);
                            allCovectorLines.push(sdfFmt.join(', '));
                            covectorSection = `
                                <div>
                                    <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Covector</h4>
                                    <div class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3">
                                        <span class="text-base text-gray-800 dark:text-gray-200">\\([ ${sdfFmt.join(',\\; ')} ]\\)</span>
                                    </div>
                                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">Calculated using pivot vector \\(e_{${pivot}}\\).</p>
                                </div>`;
                        } catch (e) {
                            covectorSection = `
                                <div>
                                    <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Covector</h4>
                                    <div class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3">
                                        <span class="text-sm text-gray-700 dark:text-gray-300">No covector (g fixes all basis vectors).</span>
                                    </div>
                                </div>`;
                        }

                        return `
                        <div class="p-4 rounded-xl bg-white dark:bg-gray-800/50 border border-gray-200 dark:border-gray-700/80">
                            <div class="flex flex-wrap justify-between items-center gap-2 mb-4">
                                <h3 class="text-lg font-semibold text-gray-800 dark:text-white">Matrix ${index + 1}</h3>
                            </div>
                            <div class="space-y-4">
                                <div>
                                    <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">SO⁺(3,1) Matrix</h4>
                                    <div class="overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700">
                                        <table class="min-w-full text-right text-sm font-mono">
                                            <tbody class="bg-gray-50 dark:bg-gray-900/50 divide-y divide-gray-200 dark:divide-gray-700">
                                                ${Mfmt.map(r => `
                                                    <tr class="dark:hover:bg-gray-700/50 hover:bg-gray-100">${r.map(x => `
                                                        <td class="px-4 py-3 whitespace-nowrap">${x}</td>`).join('')}
                                                    </tr>`).join('')}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                                ${covectorSection}
                            </div>
                        </div>
                        `;
                    }).join('');

                    // --- Words ≤ L and stdGenerators output ---
                    let wordsSectionHTML = '';
                    let wordsTableOnlyHTML = '';
                    try {
                        const L = Math.max(1, parseInt(card.querySelector('#psl-wordlen')?.value || '4', 10));
                        const wordObjs = generateWords2x2Complex(matrices, L);
                        // Compute sDF for each enumerated word (if defined)
                        const wordWithSdf = wordObjs.map((w) => {
                            try {
                                const A = w.m; // [[a,b],[c,d]] complex entries
                                const M = PSL2CtoSO31(A[0][0], A[0][1], A[1][0], A[1][1]);
                                const { row } = sDF_autoFromSO31(M);
                                const sdfFmt = __formatRow(row).join(', ');
                                // Include a compact one-line display of the 2x2 complex matrix for the "matrix" column
                                const matStr = __formatMat2LineSimple(A);
                                return { word: w.word, sdf: `[ ${sdfFmt} ]`, matStr };
                            } catch (_) {
                                return { word: w.word, sdf: '—', matStr: __formatMat2LineSimple(w.m) }; // keep matrix for display even if sDF missing
                            }
                        });

                        // Covector lines for copy-paste (remove brackets)
                        const covectorLinesConsidered = wordWithSdf
                            .map(w => (w.sdf && w.sdf !== '—') ? w.sdf.replace(/^\[\s*|\s*\]$/g,'') : null)
                            .filter(Boolean);
                        const covectorsBoxHTML = `
                            <div class="mt-4">
                              <div class="flex items-center justify-between mb-2">
                                <h4 class="text-md font-medium text-gray-700 dark:text-gray-300">Covectors for words</h4>
                                <button id="copy-words-covectors" class="px-2 py-1 text-xs rounded bg-indigo-600 text-white hover:bg-indigo-700">Copy</button>
                              </div>
                              <div id="covectors-scroll" class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3 border border-gray-200 dark:border-gray-700 max-h-48 overflow-y-auto">
                                <pre class="font-mono text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap" id="words-covectors-pre">${covectorLinesConsidered.join('\n')}</pre>
                              </div>
                            </div>`;

                        const wordListHTML = wordWithSdf.map((w,i)=>
                            `<div class='font-mono text-xs sm:text-sm'>${i+1}. ${w.word}  </div>`
                        ).join('');
                        const wordsConsideredHTML = `
                            <div class="mt-4">
                              <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Words considered (≤ ${L})</h4>
                              <div id="words-list-scroll" class="max-h-48 overflow-y-auto bg-gray-50 dark:bg-gray-900/50 border border-gray-200 dark:border-gray-700 rounded-lg p-2">
                                ${wordListHTML}
                              </div>
                            </div>`;

                        // --- NEW: Determine face‑defining words by scanning the computed covectors ---
                        // Build (word, row[4]) pairs only for words that produced an sDF
                        const pairs = wordWithSdf
                          .filter(w => w.sdf && w.sdf !== '—')
                          .map(w => {
                            // w.sdf looks like "[ a, b, c, d ]"; strip brackets then parse
                            const rowStr = w.sdf.replace(/^\s*\[\s*|\s*\]\s*$/g, '');
                            const toks = rowStr.split(',').map(s => parseFloat(s.trim()));
                            if (toks.length !== 4 || toks.some(v => !Number.isFinite(v))) return null;
                            return { word: w.word, row: toks, matStr: w.matStr };
                          })
                          .filter(Boolean);

                        // Input rows for sDFsupport
                        const rowsForSupport = pairs.map(p => p.row);
                        const idxs = filterFaceDefiningCovectorsCone(rowsForSupport, { eps: 1e-9, initBox: 1e6 });
                        // Build candidate faces
                        const rawFaces = idxs.map((idx) => ({ index: idx, word: pairs[idx].word, sdf: rowsForSupport[idx], matStr: pairs[idx].matStr }));

                        // Helper: normalize half-space key (uses global __hsKey)
                        function hsKeyFromRow(row){ return __hsKey([row[0], row[1], row[2], row[3]]); }

                        // Helper: word cost = number of generator symbols (favor shorter words);
                        // prefer base generators in ties
                        function wordCost(w){
                          if (!w) return 1e9;
                          // tokens are joined by \u22C5, so count them; base words like g1, g2 have no dot
                          const dots = (w.match(/\u22C5/g)||[]).length;
                          const baseBonus = (/^(g1|g2|g1\^\{-1\}|g2\^\{-1\})$/).test(w) ? -0.5 : 0; // prefer S,T,T^{-1} style
                          return dots + 1 + baseBonus; // length ~ number of factors
                        }

                        // Group by normalized wall and pick best representative per group
                        const groupMap = new Map();
                        for (const f of rawFaces){
                          const key = hsKeyFromRow(f.sdf);
                          const prev = groupMap.get(key);
                          if (!prev) { groupMap.set(key, f); continue; }
                          const cNew = wordCost(f.word), cOld = wordCost(prev.word);
                          if (cNew < cOld) groupMap.set(key, f);
                        }
                        const facesFromCovectors = Array.from(groupMap.values());
                        __facesExportData = facesFromCovectors.map(f => ({ sdf: f.sdf, word: f.word, matStr: f.matStr }));

                        // --- New: Face-defining covectors output box ---
                        const facesOutputLines = facesFromCovectors.map(f => __formatRow(f.sdf).join(', '));
                        const facesOutputHTML = `
                          <div class="mt-4">
                            <div class="flex items-center justify-between mb-2">
                              <h5 class="text-sm font-medium text-gray-700 dark:text-gray-300">Face‑defining covectors (output)</h5>
                              <button id="copy-faces-output" class="px-2 py-1 text-xs rounded bg-indigo-600 text-white hover:bg-indigo-700">Copy</button>
                            </div>
                            <div class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3 border border-gray-200 dark:border-gray-700 max-h-48 overflow-y-auto">
                              <pre class="font-mono text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap" id="faces-output-pre">${facesOutputLines.join('\n')}</pre>
                            </div>
                          </div>
                        `;

                        const rows = facesFromCovectors.map((f, i)=>{
                          const sdfFmt = __formatRow(f.sdf).join(', ');
                          let matHTML = '';
                          if (f.matStr) {
                            const vals = f.matStr.replace(/[()]/g, '').trim().split(/\s+/);
                            if (vals.length === 4) {
                              matHTML = `
                                <table class="text-xs font-mono border-collapse" style="display:inline-table;">
                                  <tr><td class="px-1">${vals[0]}</td><td class="px-1">${vals[1]}</td></tr>
                                  <tr><td class="px-1">${vals[2]}</td><td class="px-1">${vals[3]}</td></tr>
                                </table>`;
                            } else {
                              matHTML = `<span class="font-mono text-xs">${f.matStr}</span>`;
                            }
                          }
                          return `
                              <tr class="border-b border-gray-200 dark:border-gray-700">
                                <td class="px-3 py-2 font-mono text-xs sm:text-sm">${i+1}</td>
                                <td class="px-3 py-2 font-mono text-xs sm:text-sm whitespace-pre">${f.word || ''}</td>
                                <td class="px-3 py-2 font-mono text-xs sm:text-sm">( ${sdfFmt} )</td>
                                <td class="px-3 py-2">${matHTML}</td>
                              </tr>`;
                        }).join('');

                        wordsTableOnlyHTML = `
                          <div class="mt-2">
                            <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Face‑defining words (≤ ${L})</h4>
                            <div class="overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700">
                              <table class="min-w-full text-left text-sm">
                                <thead class="bg-gray-100 dark:bg-gray-900/60">
                                  <tr>
                                    <th class="px-3 py-2">#</th>
                                    <th class="px-3 py-2">word</th>
                                    <th class="px-3 py-2">sDF (a,b,c,d)</th>
                                    <th class="px-3 py-2">matrix</th>
                                  </tr>
                                </thead>
                                <tbody class="bg-white dark:bg-gray-800/40">
                                  ${rows || '<tr><td class="px-3 py-2" colspan="4">No faces detected.</td></tr>'}
                                </tbody>
                              </table>
                            </div>
                          </div>`;

                        wordsSectionHTML = `
                            <div class="text-sm text-gray-600 dark:text-gray-400 mb-2 mt-2">
                              Covectors computed: <span class="font-mono">${pairs.length}</span>; Faces: <span class="font-mono">${facesFromCovectors.length}</span>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                              ${wordsConsideredHTML}
                              ${covectorsBoxHTML}
                            </div>
                            <div class="text-xs text-gray-600 dark:text-gray-400 mt-2 mb-1">
                              Face-defining covectors (<span class="font-mono">${facesOutputLines.length}</span>):
                            </div>
                            ${facesOutputHTML}
                        `;
                    } catch (e) {
                        wordsTableOnlyHTML = '';
                        wordsSectionHTML = `<div class="mt-6 text-sm text-red-600 dark:text-red-400">Word enumeration failed: ${e.message}</div>`;
                    }

                    // 3) Summary section: only "All covectors"
                    const summaryHTML = `
                        <div class="mt-6">
                            <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">All covectors</h4>
                            <div class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3 border border-gray-200 dark:border-gray-700">
                                <pre class="font-mono text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${allCovectorLines.join('\n')}</pre>
                            </div>
                        </div>
                    `;

                    // Open polyhedron button goes in #psl-open
                    const openBtnHTML = `
                        <div class="mt-2">
                            <button id="open-poincare"
                                class="px-4 py-2 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition-all duration-200 bg-emerald-600 text-white hover:bg-emerald-700 focus:ring-emerald-500 shadow-sm hover:shadow-md">
                                Open polyhedron in Poincare
                            </button>
                        </div>
                    `;

                    // Set all output containers
                    summary.innerHTML = summaryHTML;
                    out.innerHTML = resultsHTML;
                    if (wordsTableEl) wordsTableEl.innerHTML = wordsTableOnlyHTML;
                    if (openEl) openEl.innerHTML = openBtnHTML;
                    if (wordsEl) wordsEl.innerHTML = wordsSectionHTML;

                    // Open polyhedron button event
                    const openBtn = card.querySelector('#open-poincare');
                    if (openBtn) {
                        openBtn.addEventListener('click', () => {
                            // Legacy payload: prefer the face-defining covectors (one per line); fallback to all covectors
                            const facesText = (card.querySelector('#faces-output-pre')?.textContent || '').trim();
                            let payload = facesText;
                            if (!payload) {
                              payload = (Array.isArray(allCovectorLines) ? allCovectorLines.join('\n') : '').trim();
                            }
                            // Store legacy text for backward compatibility
                            try {
                                localStorage.setItem('poincare_input', payload);
                            } catch (e) { /* ignore storage errors */ }

                            // New: include per-face metadata for poincare.html (word and 2x2 group element)
                            // We export to both localStorage and a URL parameter ?faces=
                            const facesData = (__facesExportData || []).map((f, i) => ({
                                index: i + 1,
                                sdf: Array.isArray(f.sdf) ? f.sdf : [],
                                word: f.word || '',
                                matrix: f.matStr || ''
                            }));
                            const facesJson = JSON.stringify({
                                faces: facesData,
                                schema: "PSL2CtoSO31.export.v1",
                                note: "sDF=(a,b,c,d). matrix is the 2x2 complex element as a compact string; word uses \\u22C5 as a separator."
                            });

                            try { localStorage.setItem('poincare_faces', facesJson); } catch (e) { /* ignore */ }

                            const b64Vectors = btoa(payload);
                            let url = `poincare.html?vectors=${encodeURIComponent(b64Vectors)}#source=poincare_input`;
                            try {
                                const b64Faces = btoa(facesJson);
                                url = `poincare.html?vectors=${encodeURIComponent(b64Vectors)}&faces=${encodeURIComponent(b64Faces)}#source=poincare_input`;
                            } catch (e) {
                                // If base64 of faces fails for any reason, fall back to vectors-only URL
                            }

                            window.location.href = url;
                        });
                    }
                    // Attach copy handler for covectors for words
                    const copyCovBtn2 = card.querySelector('#copy-words-covectors');
                    if (copyCovBtn2) copyCovBtn2.addEventListener('click', async () => {
                        try {
                            const text = (card.querySelector('#words-covectors-pre')?.textContent || '').trim();
                            await navigator.clipboard.writeText(text);
                            copyCovBtn2.textContent = 'Copied!';
                            setTimeout(() => (copyCovBtn2.textContent = 'Copy'), 1200);
                        } catch (_) {}
                    });
                    // Attach copy handler for face-defining covectors output
                    const copyFacesBtn = card.querySelector('#copy-faces-output');
                    if (copyFacesBtn) copyFacesBtn.addEventListener('click', async () => {
                        try {
                            const text = (card.querySelector('#faces-output-pre')?.textContent || '').trim();
                            await navigator.clipboard.writeText(text);
                            copyFacesBtn.textContent = 'Copied!';
                            setTimeout(() => (copyFacesBtn.textContent = 'Copy'), 1200);
                        } catch (_) {}
                    });
                    // Sync scrolling between the two boxes
                    (function(){
                      const a = card.querySelector('#covectors-scroll');
                      const b = card.querySelector('#words-list-scroll');
                      if (!a || !b) return;
                      let syncing = false;
                      const sync = (src, dst) => {
                        if (syncing) return;
                        syncing = true;
                        dst.scrollTop = src.scrollTop;
                        syncing = false;
                      };
                      a.addEventListener('scroll', () => sync(a, b), { passive: true });
                      b.addEventListener('scroll', () => sync(b, a), { passive: true });
                    })();
                    if (window.MathJax && window.MathJax.typesetPromise) {
                        MathJax.typesetPromise([
                          wordsTableEl,
                          card.querySelector('#psl-open'),
                          wordsEl,
                          summary,
                          out
                        ]).catch(() => {});
                    }

                } catch (e) {
                    summary.innerHTML = '';
                    out.innerHTML = `<div class="text-red-500 dark:text-red-400 p-4 bg-red-100 dark:bg-red-900/50 rounded-lg">${e.message}</div>`;
                    if (wordsTableEl) wordsTableEl.innerHTML = '';
                    if (openEl) openEl.innerHTML = '';
                    if (wordsEl) wordsEl.innerHTML = '';
                }
            }

            // Event Listeners
            el('#psl-add').onclick = () => addMatrixForm();
            
            matrixList.addEventListener('click', e => {
                if (e.target.closest('.remove-matrix')) {
                    e.target.closest('.matrix-form').remove();
                }
            });

            // Disable automatic computation on input or matrix add/remove
            // matrixList.addEventListener('input', render);
            // card.addEventListener('input', (e)=>{
            //     if (e.target && e.target.id === 'psl-wordlen') render();
            // });

            // Only compute when "Compute" button is clicked
            const computeBtn = el('#psl-compute');
            if (computeBtn) computeBtn.addEventListener('click', render);

            // Import button handler
            const importBtn = el('#psl-import');
            if (importBtn) importBtn.onclick = () => {
                if (!loadExternalMatricesIfAny()) {
                    alert('No external matrices found. Another page can set localStorage key "psl2c_matrices" or pass ?matrices=...');
                }
            };

            // Initial state: try to load from external payload; otherwise add a default form
            if (!loadExternalMatricesIfAny()) {
                addMatrixForm({ a: '1', b: '1', c: '0', d: '1' });
                addMatrixForm({ a: '0', b: '-1', c: '1', d: '0' });
            }
        }

        // --- END: UI Generation and Event Handling ---


        // --- Initialize the application ---
        document.addEventListener('DOMContentLoaded', () => {
            // Check for system dark mode preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            attachPSL2CtoSO31Tester('#app-container');
        });

    </script>
</body>

</html>