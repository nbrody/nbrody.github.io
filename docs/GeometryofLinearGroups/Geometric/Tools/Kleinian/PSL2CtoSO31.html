<!DOCTYPE html>
<html lang="en" class="min-h-screen">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSL(2,C) to SO(3,1) Calculator</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for better typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code&display=swap"
        rel="stylesheet">
    <script>
        // Configuration for Tailwind CSS dark mode
        tailwind.config = {
            darkMode: 'class', // or 'media'
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Fira Code', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Basic styling for dark mode and layout */
        html {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$','$$'], ['\\[','\\]']],
          processEscapes: true
        },
        options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] },
        svg: { fontCache: 'global' }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body
    class="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans flex items-start justify-center p-4 overflow-y-auto">

    <div id="app-container" class="w-full max-w-screen-2xl mx-auto">
        <!-- The user interface will be generated and injected here by the script -->
    </div>

    <script>

        // Given g = [[a,b],[c,d]] in SL2(C), compute the corresponding element of SO^+(3,1)
        // via the standard action on 2x2 Hermitian matrices: H -> g H g^†.
        // We identify Minkowski vectors (x,y,z,t) with Hermitian matrices
        //   H(t,x,y,z) = [[t + z, x + i y], [x - i y, t - z]]
        // so that det(H) = - x^2 - y^2 - z^2 + t^2.
        // The resulting 4x4 real matrix Λ satisfies v' = Λ v for v ∈ R^{3,1}.

        // ------------------ Complex helpers ------------------
        function toC(z) {
            if (typeof z === 'number') return { re: z, im: 0 };
            if (z && typeof z.re === 'number' && typeof z.im === 'number') return { re: z.re, im: z.im };
            throw new Error('Complex inputs must be numbers or {re,im} objects');
        }
        function C(re, im) { return { re, im }; }
        function cAdd(z, w) { return C(z.re + w.re, z.im + w.im); }
        function cSub(z, w) { return C(z.re - w.re, z.im - w.im); }
        function cMul(z, w) { return C(z.re * w.re - z.im * w.im, z.re * w.im + z.im * w.re); }
        function cConj(z) { return C(z.re, -z.im); }

        // 2x2 complex matrix helpers
        function cMatMul2(A, B) {
            return [
                [cAdd(cMul(A[0][0], B[0][0]), cMul(A[0][1], B[1][0])),
                cAdd(cMul(A[0][0], B[0][1]), cMul(A[0][1], B[1][1]))],
                [cAdd(cMul(A[1][0], B[0][0]), cMul(A[1][1], B[1][0])),
                cAdd(cMul(A[1][0], B[0][1]), cMul(A[1][1], B[1][1]))]
            ];
        }
        function cMatAdjoint2(A) {
            return [
                [cConj(A[0][0]), cConj(A[1][0])],
                [cConj(A[0][1]), cConj(A[1][1])]
            ];
        }

        // -------- Additional Complex & 2x2 helpers (for word enumeration) --------
        function cNeg(z){ return C(-z.re, -z.im); }
        function cAbs(z){ return Math.hypot(z.re, z.im); }
        function cDiv(z,w){
            const den = w.re*w.re + w.im*w.im; if (den===0) throw new Error('Divide by zero');
            return C((z.re*w.re + z.im*w.im)/den, (z.im*w.re - z.re*w.im)/den);
        }
        function cEq(z,w, tol=1e-9){ return Math.abs(z.re-w.re)<=tol && Math.abs(z.im-w.im)<=tol; }
        function cToStr(z){
            const r = +z.re.toFixed(6), i = +z.im.toFixed(6);
            if (Math.abs(i)<1e-12) return `${r}`;
            if (Math.abs(r)<1e-12) return `${i}i`;
            return `${r}${i<0?'' : '+'}${i}i`;
        }

        function cDet2(A){ return cSub(cMul(A[0][0],A[1][1]), cMul(A[0][1],A[1][0])); }
        function cInv2(A){
            const det = cDet2(A);
            const invDet = cDiv(C(1,0), det);
            return [
                [ cMul(A[1][1],invDet), cMul(cNeg(A[0][1]),invDet) ],
                [ cMul(cNeg(A[1][0]),invDet), cMul(A[0][0],invDet) ]
            ];
        }

        function matEq2(A,B,tol=1e-9){
            for(let i=0;i<2;i++) for(let j=0;j<2;j++) if(!cEq(A[i][j],B[i][j],tol)) return false; return true;
        }
        function matKey2(A){
            // stable key for dedupe: round to 1e-9
            const f = z=>`${(+z.re.toFixed(9))}:${(+z.im.toFixed(9))}`;
            return `${f(A[0][0])}|${f(A[0][1])}|${f(A[1][0])}|${f(A[1][1])}`;
        }

        // Generate words up to length L from generators and their inverses (on 2x2 complex matrices)
        function generateWords2x2Complex(gens2x2, L){
            const initial = [];
            gens2x2.forEach((G,i)=>{
                initial.push({ m:G, word:`g${i+1}` });
                try{ initial.push({ m:cInv2(G), word:`g${i+1}^{-1}` }); }catch(_){ /* skip non-invertible */ }
            });
            const seen = new Map();
            const out = [];
            const I = [[C(1,0),C(0,0)],[C(0,0),C(1,0)]];
            const Ikey = matKey2(I);
            function pushObj(o){ const k=matKey2(o.m); if(!seen.has(k)){ seen.set(k,o); if(k!==Ikey) out.push(o);} }
            initial.forEach(pushObj);
            let frontier = initial.slice();
            for(let l=1;l<L; l++){
                const next=[];
                for(const w of frontier){
                    for(const s of initial){
                        const m = cMatMul2(w.m, s.m);
                        const obj = { m, word: `${w.word}\u22C5${s.word}` };
                        const k = matKey2(m);
                        if(!seen.has(k) && !matEq2(m,I)) { seen.set(k,obj); out.push(obj); next.push(obj);} }
                }
                frontier = next;
            }
            return out;
        }

        function __formatMat2LineSimple(A){
            return `(${cToStr(A[0][0])} ${cToStr(A[0][1])} ${cToStr(A[1][0])} ${cToStr(A[1][1])})`;
        }


        function generateGroupElements(gens, wordLength) {
                // Return [{ m: Matrix2, word: string }], excluding identity
                const elements = new Map();

                // Identity
                const I = new Matrix2(
                    new Complex(1, 0), new Complex(0, 0),
                    new Complex(0, 0), new Complex(1, 0)
                );
                const identityKey = keyFromMatrix(I);
                elements.set(identityKey, { m: I, word: 'e' });

                // Initial set: g_i and g_i^{-1}
                const initialSet = [];
                gens.forEach((g, i) => {
                    const name = `g${i + 1}`;
                    initialSet.push({ m: g, word: name });
                    const inv = g && g.inverse ? g.inverse() : null;
                    if (inv) initialSet.push({ m: inv, word: `${name}^{-1}` });
                });

                // Seed queue + map
                let queue = [];
                initialSet.forEach(obj => {
                    if (!obj || !obj.m) return;
                    const key = keyFromMatrix(obj.m);
                    if (!elements.has(key)) {
                        elements.set(key, obj);
                        queue.push(obj);
                    }
                });

                // BFS up to the requested word length
                for (let l = 1; l < (parseInt(wordLength) || 1); l++) {
                    const nextQueue = [];
                    for (const wobj of queue) {
                        for (const s of initialSet) {
                            const newM = wobj.m.multiply(s.m);
                            if (newM.isIdentity && newM.isIdentity()) continue;
                            const key = keyFromMatrix(newM);
                            if (!elements.has(key)) {
                                const newObj = { m: newM, word: wobj.word + s.word };
                                elements.set(key, newObj);
                                nextQueue.push(newObj);
                            }
                        }
                    }
                    queue = nextQueue;
                }

                // Exclude identity
                const out = [];
                for (const [k, v] of elements.entries()) {
                    if (k !== identityKey) out.push(v);
                }
                return out;
            }

        // ------------------ Minkowski <-> Hermitian ------------------
        function hermitianFromVec(v) {
            const [x, y, z, t] = v;
            return [
                [C(t + z, 0), C(x, y)],
                [C(x, -y), C(t - z, 0)]
            ];
        }
        function vecFromHermitian(H) {
            const x = H[0][1].re;
            const y = H[0][1].im;
            const z = (H[0][0].re - H[1][1].re) / 2;
            const t = (H[0][0].re + H[1][1].re) / 2;
            return [x, y, z, t];
        }

        // ------------------ Main map ------------------
        function PSL2CtoSO31(a, b, c, d) {
            const A = toC(a), B = toC(b), Cc = toC(c), D = toC(d);
            const g = [[A, B], [Cc, D]];
            const gAdj = cMatAdjoint2(g);
            const basis = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];

            const columns = basis.map(v => {
                const H = hermitianFromVec(v);
                const gHgAdj = cMatMul2(cMatMul2(g, H), gAdj);
                return vecFromHermitian(gHgAdj);
            });

            const Lambda = Array.from({ length: 4 }, (_, r) =>
                columns.map(col => {
                    const val = col[r];
                    const eps = 1e-8;
                    return Math.abs(val) < eps ? 0 : val;
                })
            );
            return Lambda;
        }

        // ------------------ sDF utilities ------------------
        const __ETA = [-1, -1, -1, +1];
        function __etaApply(v) { return [-v[0], -v[1], -v[2], v[3]]; }
        function __stdBasis(j) {
            return [0, 0, 0, 0].map((_, k) => (k === j ? 1 : 0));
        }
        function __ginv_ej(g, j) {
            // Using g^{-1} = η g^T η with η = diag(-1,-1,-1,+1).
            // Column j of g^{-1} equals: w_i = η_{ii} * g_{j i} * η_{jj}.
            const r = g[j];                 // row j of g
            const sj = (j === 3) ? 1 : -1;  // η_{jj}
            return [
                (-1) * r[0] * sj,           // η_{00} = -1
                (-1) * r[1] * sj,           // η_{11} = -1
                (-1) * r[2] * sj,           // η_{22} = -1
                (+1) * r[3] * sj            // η_{33} = +1
            ];
        }

        function sDF_autoFromSO31(g) {
            if (!Array.isArray(g) || g.length !== 4 || g.some(r => !Array.isArray(r) || r.length !== 4)) {
                throw new Error('sDF_autoFromSO31 expects a 4x4 matrix');
            }
            const eps = 1e-8;
            for (let j = 3; j >= 0; j--) {
                const s = __ETA[j];
                const w = __ginv_ej(g, j);
                const denom = s * (w[j] - 1);
                if (Math.abs(denom) < eps) {
                    continue;
                }
                const e = __stdBasis(j);
                const u = [w[0] - e[0], w[1] - e[1], w[2] - e[2], w[3] - e[3]];
                const eta_u = __etaApply(u);
                const row = eta_u;
                // Normalize sign: ensure the last nonzero coordinate is negative
                const epsSign = 1e-12;
                let lastIdx = -1;
                for (let k = 3; k >= 0; k--) {
                    if (Math.abs(row[k]) > epsSign) { lastIdx = k; break; }
                }
                if (lastIdx !== -1 && row[lastIdx] > 0) {
                    for (let k = 0; k < 4; k++) row[k] = -row[k];
                }
                return { row, pivot: j };
            }
            throw new Error('sDF undefined: g fixes all basis vectors e₀, e₁, e₂, e₃');
        }

        // Minkowski helpers (signature + + + - becomes ⟨u,v⟩ = -u_x v_x - u_y v_y - u_z v_z + u_t v_t)
        function __minkowskiDot(u, v) {
            return -(u[0]*v[0] + u[1]*v[1] + u[2]*v[2]) + u[3]*v[3];
        }
        function __etaVec(v) { return [-v[0], -v[1], -v[2], v[3]]; } // η·v
        function __norm2M(u) { return __minkowskiDot(u, u); }
        function __normalizeTimelike(u, eps=1e-12) {
            // Scale u so that ⟨u,u⟩ = +1 and t > 0 (forward sheet)
            let n2 = __norm2M(u);
            if (n2 <= eps) return null; // not timelike
            let s = 1/Math.sqrt(n2);
            let w = [u[0]*s, u[1]*s, u[2]*s, u[3]*s];
            if (w[3] < 0) w = [-w[0], -w[1], -w[2], -w[3]];
            return w;
        }
        function __projectToHyperplane(x, n) {
            // Orthogonal projection (Lorentzian metric):
            // Hyperplane H_n = { y : ⟨n, y⟩ = 0 }. For a spacelike normal n (⟨n,n⟩<0),
            // the Lorentzian orthogonal projection is x' = x - (⟨n,x⟩ / ⟨n,n⟩) * n.
            const nn = __minkowskiDot(n, n);
            if (Math.abs(nn) < 1e-16) return null; // degenerate normal
            const nx = __minkowskiDot(n, x);
            const scale = nx / nn;
            return [
                x[0] - scale * n[0],
                x[1] - scale * n[1],
                x[2] - scale * n[2],
                x[3] - scale * n[3],
            ];
        }

        // Given a list of sDFs (rows [a,b,c,d]), determine which define faces.
        // Heuristic/constructive test: for each normal n, take the Minkowski-orthogonal projection of e3 onto {⟨n,·⟩=0},
        // normalize it to the forward sheet (⟨x,x⟩=1, t>0), and check that all other planes strictly separate it.
        // Returns { indices, margins, witnesses }
        function sDFsupport(rows, opts={}) {
            const eps = opts.eps ?? 1e-9;
            const tol = opts.tol ?? 1e-8;
            const e3 = [0,0,0,1];
            const N = rows.length;
            const survivors = [];
            const margins = [];
            const witnesses = [];

            // Pre-sanitize normals: enforce last nonzero coord negative (as elsewhere), and drop obvious zeros
            const normals = rows.map(r => {
                const v = r.slice(0,4).map(x => +x);
                // If last nonzero positive, flip sign
                let lastIdx=-1; for (let k=3;k>=0;k--) if (Math.abs(v[k])>1e-14){ lastIdx=k; break; }
                if (lastIdx!==-1 && v[lastIdx]>0){ for (let k=0;k<4;k++) v[k] = -v[k]; }
                return v;
            });

            for (let i=0;i<N;i++) {
                const n = normals[i];
                // Require spacelike normal (⟨n,n⟩<0) for a proper wall in H^3
                const nn = __minkowskiDot(n,n);
                if (!(nn < -eps)) { continue; }

                // Project basepoint e3 to the wall and normalize
                let x0 = __projectToHyperplane(e3, n);
                if (!x0) continue;
                let x = __normalizeTimelike(x0, eps);
                if (!x) {
                    // Nudge e3 slightly forward if projection is lightlike
                    x0 = __projectToHyperplane([0,0,0,1.0001], n);
                    x = __normalizeTimelike(x0, eps);
                    if (!x) continue;
                }

                // Check strict separation by all other planes
                let ok = true;
                let minMargin = +Infinity;
                for (let j=0;j<N;j++) if (j!==i) {
                    const m = __minkowskiDot(normals[j], x);
                    if (m <= tol) { ok = false; break; }
                    if (m < minMargin) minMargin = m;
                }
                // Also ensure we are actually on the i-th wall (≈0)
                const onWall = Math.abs(__minkowskiDot(n, x)) <= 10*tol;
                if (ok && onWall) {
                    survivors.push(i);
                    margins.push(minMargin);
                    witnesses.push(x);
                }
            }
            return { indices: survivors, margins, witnesses };
        }

        // Given a list of PSL2(C) elements as { m: Matrix2 or 2x2 array, word?: string },
        // return only those whose sDFs define faces, including their words and covectors.
        function stdGenerators(wordObjs, opts={}) {
            const eps = opts.eps ?? 1e-9; const tol = opts.tol ?? 1e-8;
            const mats = []; const words = []; const sdfs = [];

            function toPlain2x2(M2) {
                // Accept Matrix2 or [[a,b],[c,d]] with Complex-like entries
                if (M2 && M2.a11 !== undefined) {
                    const a = M2.a11, b = M2.a12, c = M2.a21, d = M2.a22;
                    return [[a, b], [c, d]];
                }
                return M2;
            }

            for (const w of wordObjs || []) {
                try {
                    const A = toPlain2x2(w.m);
                    const M = PSL2CtoSO31(A[0][0], A[0][1], A[1][0], A[1][1]);
                    const { row } = sDF_autoFromSO31(M);
                    mats.push(A); words.push(w.word ?? ''); sdfs.push(row);
                } catch (_) { /* skip ill-defined */ }
            }
            const support = sDFsupport(sdfs, { eps, tol });
            const out = support.indices.map((idx, k) => ({
                index: idx,
                word: words[idx],
                matrix2x2: mats[idx],
                sdf: sdfs[idx],
                margin: support.margins[k],
                witness: support.witnesses[k],
            }));
            return { faces: out, sdfsAll: sdfs };
        }

        // ------------------ UI-specific helpers ------------------
        function __parseComplex(s) {
            if (typeof s === 'number') return { re: s, im: 0 };
            // Sanitize input: trim whitespace, convert to lower case, remove internal spaces
            s = (s || '').toString().trim().toLowerCase().replace(/\s/g, '');
            if (s === '') return { re: 0, im: 0 };

            // Handle special cases for 'i' and '-i'
            if (s === 'i') return { re: 0, im: 1 };
            if (s === '-i') return { re: 0, im: -1 };

            if (s.endsWith('i')) {
                const core = s.slice(0, -1);
                // Find the sign that splits real and imaginary parts.
                // We search from the right, but ignore a potential leading sign.
                const signIndex = Math.max(core.lastIndexOf('+'), core.lastIndexOf('-'));

                if (signIndex > 0) { // A sign is found in the middle (e.g., in "1+2" or "-3-4")
                    const reStr = core.substring(0, signIndex);
                    let imStr = core.substring(signIndex);

                    // Handle cases where the imaginary part is just 'i' (e.g., "1+i")
                    if (imStr === '+') imStr = '1';
                    if (imStr === '-') imStr = '-1';

                    const re = parseFloat(reStr);
                    const im = parseFloat(imStr);
                    if (!isNaN(re) && !isNaN(im)) return { re, im };

                } else { // No middle sign, so it's a pure imaginary number (e.g., "2i" or "-3.5i")
                    // Handle case of just 'i' e.g. '1+i' -> imStr will be '+', need to handle that
                    if (core === '+' || core === '') return { re: 0, im: 1 };
                    if (core === '-') return { re: 0, im: -1 };

                    const im = parseFloat(core);
                    if (!isNaN(im)) return { re: 0, im };
                }
            } else { // No 'i' at the end, so it must be a pure real number
                const re = parseFloat(s);
                if (!isNaN(re)) return { re, im: 0 };
            }

            // If none of the above worked, the format is invalid
            throw new Error(`Cannot parse complex: "${s}"`);
        }

        function __formatMatrix4(M) {
            return M.map(row => row.map(x => Math.abs(x) < 1e-12 ? "0" : +x.toFixed(6)));
        }

        function __formatRow(v) {
            return v.map(x => Math.abs(x) < 1e-12 ? "0" : +x.toFixed(6));
        }



        // --- START: UI Generation and Event Handling (Enhanced) ---

        // --- Auto-detect payload of matrices from other tools/pages ---
        function getExternalMatricesPayload() {
            // Prefer explicit URL param ?matrices= (Base64-encoded text with lines "a b c d")
            try {
                const params = new URLSearchParams(window.location.search);
                const mParam = params.get('matrices');
                if (mParam) {
                    try {
                        const decoded = atob(decodeURIComponent(mParam));
                        if (decoded && decoded.trim().length > 0) return decoded;
                    } catch (e) {
                        console.warn('Failed to decode matrices param:', e);
                    }
                }
            } catch (e) {
                console.warn('URL parsing failed:', e);
            }
            // Fallback: localStorage key written by other pages
            try {
                const ls = localStorage.getItem('psl2c_matrices');
                if (ls && ls.trim().length > 0) return ls;
            } catch (e) {
                // ignore storage access errors
            }
            return null;
        }

        /**
         * Attaches a modern UI to the specified container.
         * @param {string|HTMLElement} containerSelector - The DOM element or selector to attach the UI to.
         */
        function attachPSL2CtoSO31Tester(containerSelector) {
            const root = (typeof containerSelector === 'string') ? document.querySelector(containerSelector) : containerSelector;
            if (!root) throw new Error('attachPSL2CtoSO31Tester: container not found');
            root.innerHTML = '';

            const card = document.createElement('div');
            card.className = "bg-white dark:bg-gray-800/50 dark:backdrop-blur-sm p-6 sm:p-8 rounded-2xl shadow-lg w-full max-w-none border border-gray-200 dark:border-gray-700";

            card.innerHTML = `
                <h2 class="text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white mb-2 tracking-tight">\\(\\mathrm{PSL}_2(\\mathbb{C}) \\to \\mathrm{SO}^{+}(3,1)\\) Calculator</h2>
                <p class="text-gray-600 dark:text-gray-400 mb-6">Add matrices to the list. The calculation is performed for each matrix individually.</p>
                
                <div id="psl-matrix-list" class="flex flex-wrap gap-4 mb-4">
                    <!-- Matrix input forms will be injected here -->
                </div>
                <div id="psl-summary" class="mb-4"></div>
                <div class="flex flex-wrap items-center justify-start gap-4 mb-6">
                    <div class="flex flex-wrap gap-3">
                        <button id="psl-add" class="px-5 py-2 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition-all duration-200 bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500 shadow-sm hover:shadow-md">Add Matrix</button>
                        <button id="psl-import" title="Import matrices from other tools"
                            class="px-4 py-2 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition-all duration-200 bg-emerald-100 text-emerald-800 hover:bg-emerald-200 dark:bg-emerald-900/30 dark:text-emerald-300 dark:hover:bg-emerald-900/50">Import</button>
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="psl-wordlen" class="text-sm text-gray-600 dark:text-gray-400">Word length</label>
                        <input id="psl-wordlen" type="number" min="1" value="4" class="w-20 px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md text-sm">
                    </div>
                </div>
                <div id="psl-out" class="space-y-6 bg-gray-100 dark:bg-gray-900/50 p-4 sm:p-6 rounded-xl border border-gray-200 dark:border-gray-700/50 min-h-[200px]"></div>
            `;
            root.appendChild(card);
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([card]).catch(() => {});
            }

            const el = id => card.querySelector(id);
            const out = el('#psl-out');
            const summary = el('#psl-summary');
            const matrixList = el('#psl-matrix-list');

            // Load external matrices if present (each line: a b c d)
            function loadExternalMatricesIfAny() {
                const payload = getExternalMatricesPayload();
                if (!payload) return false;
                let loaded = 0;
                // Clear any existing forms
                matrixList.innerHTML = '';
                const lines = payload.split('\n').map(s => s.trim()).filter(Boolean);
                for (const line of lines) {
                    let toks;
                    if (line.includes(',')) {
                        toks = line.split(',').map(s => s.trim());
                    } else {
                        // Fallback: whitespace‑separated ONLY if exactly 4 tokens appear (to avoid splitting inside complex literals like "1 + 2i")
                        const ws = line.trim().split(/\s+/);
                        toks = (ws.length === 4) ? ws : null;
                    }
                    if (!toks || toks.length !== 4) continue;
                    addMatrixForm({ a: toks[0], b: toks[1], c: toks[2], d: toks[3] });
                    loaded++;
                }
                // If loaded via localStorage handoff, clear it once
                try {
                    const srcHash = (window.location.hash || '');
                    if (srcHash.includes('source=psl2c_matrices')) {
                        localStorage.removeItem('psl2c_matrices');
                    }
                } catch (e) {}
                return loaded > 0;
            }

            function addMatrixForm(values = {}) {
                const formWrapper = document.createElement('div');
                formWrapper.className = "matrix-form p-4 border dark:border-gray-600 rounded-xl relative bg-gray-50 dark:bg-gray-800/50 transition-all duration-300";

                const defaultValues = { a: '1', b: '1', c: '0', d: '1', ...values };

                formWrapper.innerHTML = `
                    <button class="remove-matrix absolute -top-2 -right-2 h-7 w-7 flex items-center justify-center bg-red-500 text-white rounded-full hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 text-sm font-bold" aria-label="Remove Matrix">&times;</button>
                    <div class="flex justify-center">
                        <div class="relative inline-block">
                            <div class="grid grid-cols-2 gap-1 font-mono w-full max-w-xs">
                                ${Object.keys(defaultValues).map(label => `
                                <div>
                                    <input data-entry="${label}" type="text" value="${defaultValues[label]}" class="auto-ch w-auto min-w-[9ch] max-w-full px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 dark:text-white text-sm transition-[width]">
                                </div>`).join('')}
                            </div>
                        </div>
                    </div>
                `;
                matrixList.appendChild(formWrapper);
                // Auto-size inputs based on content length (grow with text)
                const chMin = 9, chMax = 40;
                const inputs = formWrapper.querySelectorAll('input[data-entry]');
                inputs.forEach(inp => {
                  function resize() {
                    const len = Math.max(inp.value.length, inp.placeholder ? inp.placeholder.length : 0, chMin);
                    const clamped = Math.min(Math.max(len, chMin), chMax);
                    inp.style.width = clamped + 'ch';
                  }
                  inp.addEventListener('input', resize);
                  // Initial sizing
                  resize();
                });
                render();
            }

            function readInputs() {
                const forms = matrixList.querySelectorAll('.matrix-form');
                return Array.from(forms).map(form => {
                    const a = __parseComplex(form.querySelector('[data-entry="a"]').value);
                    const b = __parseComplex(form.querySelector('[data-entry="b"]').value);
                    const c = __parseComplex(form.querySelector('[data-entry="c"]').value);
                    const d = __parseComplex(form.querySelector('[data-entry="d"]').value);
                    return [[a, b], [c, d]];
                });
            }

            function render() {
                try {
                    const matrices = readInputs();
                    if (matrices.length === 0) {
                        out.innerHTML = `<p class="text-center text-gray-500 dark:text-gray-400 py-8">Add a matrix to see the calculation.</p>`;
                        summary.innerHTML = '';
                        return;
                    }

                    // 1) Declare accumulator array before building resultsHTML
                    const allCovectorLines = [];

                    const resultsHTML = matrices.map((g, index) => {
                        const [a, b, c, d] = [g[0][0], g[0][1], g[1][0], g[1][1]];

                        const ad = cMul(a, d);
                        const bc = cMul(b, c);
                        const det = cSub(ad, bc);
                        const detMagSq = det.re * det.re + det.im * det.im;

                        const detString = `det = ${det.re.toFixed(4)} ${det.im < 0 ? '-' : '+'} ${Math.abs(det.im).toFixed(4)}i`;
                        const detClass = Math.abs(detMagSq - 1) > 0.01 ? 'text-red-500 dark:text-red-400' : 'text-green-600 dark:text-green-400';

                        const M = PSL2CtoSO31(a, b, c, d);
                        const Mfmt = __formatMatrix4(M);
                        let covectorSection = '';
                        try {
                            const auto = sDF_autoFromSO31(M);
                            const sdf = auto.row;
                            const pivot = auto.pivot;
                            const sdfFmt = __formatRow(sdf);
                            allCovectorLines.push(sdfFmt.join(', '));
                            covectorSection = `
                                <div>
                                    <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Covector</h4>
                                    <div class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3">
                                        <span class="text-base text-gray-800 dark:text-gray-200">\\([ ${sdfFmt.join(',\\; ')} ]\\)</span>
                                    </div>
                                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">Calculated using pivot vector \\(e_{${pivot}}\\).</p>
                                </div>`;
                        } catch (e) {
                            covectorSection = `
                                <div>
                                    <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Covector</h4>
                                    <div class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3">
                                        <span class="text-sm text-gray-700 dark:text-gray-300">No covector (g fixes all basis vectors).</span>
                                    </div>
                                </div>`;
                        }

                        return `
                        <div class="p-4 rounded-xl bg-white dark:bg-gray-800/50 border border-gray-200 dark:border-gray-700/80">
                            <div class="flex flex-wrap justify-between items-center gap-2 mb-4">
                                <h3 class="text-lg font-semibold text-gray-800 dark:text-white">Matrix ${index + 1}</h3>
                            </div>
                            <div class="space-y-4">
                                <div>
                                    <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">SO⁺(3,1) Matrix</h4>
                                    <div class="overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700">
                                        <table class="min-w-full text-right text-sm font-mono">
                                            <tbody class="bg-gray-50 dark:bg-gray-900/50 divide-y divide-gray-200 dark:divide-gray-700">
                                                ${Mfmt.map(r => `
                                                    <tr class="dark:hover:bg-gray-700/50 hover:bg-gray-100">${r.map(x => `
                                                        <td class="px-4 py-3 whitespace-nowrap">${x}</td>`).join('')}
                                                    </tr>`).join('')}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                                ${covectorSection}
                            </div>
                        </div>
                        `;
                    }).join('');

                    // --- Words ≤ L and stdGenerators output ---
                    let wordsSectionHTML = '';
                    try {
                        const L = Math.max(1, parseInt(card.querySelector('#psl-wordlen')?.value || '4', 10));
                        const wordObjs = generateWords2x2Complex(matrices, L);
                        // Compute sDF for each enumerated word (if defined)
                        const wordWithSdf = wordObjs.map((w) => {
                            try {
                                const A = w.m; // [[a,b],[c,d]] complex entries
                                const M = PSL2CtoSO31(A[0][0], A[0][1], A[1][0], A[1][1]);
                                const { row } = sDF_autoFromSO31(M);
                                const sdfFmt = __formatRow(row).join(', ');
                                return { word: w.word, sdf: `[ ${sdfFmt} ]` };
                            } catch (_) {
                                return { word: w.word, sdf: '—' }; // no sDF (e.g., fixes all basis vectors)
                            }
                        });

                        // Covector lines for copy-paste (remove brackets)
                        const covectorLinesConsidered = wordWithSdf
                            .map(w => (w.sdf && w.sdf !== '—') ? w.sdf.replace(/^\[\s*|\s*\]$/g,'') : null)
                            .filter(Boolean);
                        const covectorsBoxHTML = `
                            <div class="mt-4">
                              <div class="flex items-center justify-between mb-2">
                                <h4 class="text-md font-medium text-gray-700 dark:text-gray-300">Covectors for words (copy‑paste)</h4>
                                <button id="copy-words-covectors" class="px-2 py-1 text-xs rounded bg-indigo-600 text-white hover:bg-indigo-700">Copy</button>
                              </div>
                              <div class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3 border border-gray-200 dark:border-gray-700">
                                <pre class="font-mono text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap" id="words-covectors-pre">${covectorLinesConsidered.join('\n')}</pre>
                              </div>
                            </div>`;

                        const wordListHTML = wordWithSdf.map((w,i)=>
                            `<div class='font-mono text-xs sm:text-sm'>${i+1}. ${w.word}  \u2192  ${w.sdf}</div>`
                        ).join('');
                        const wordsConsideredHTML = `
                            <div class="mt-4">
                              <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Words considered (≤ ${L})</h4>
                              <div class="max-h-48 overflow-y-auto bg-gray-50 dark:bg-gray-900/50 border border-gray-200 dark:border-gray-700 rounded-lg p-2">
                                ${wordListHTML}
                              </div>
                            </div>`;

                        // --- NEW: Determine face‑defining words by scanning the computed covectors ---
                        // Build (word, row[4]) pairs only for words that produced an sDF
                        const pairs = wordWithSdf
                          .filter(w => w.sdf && w.sdf !== '—')
                          .map(w => {
                            // w.sdf looks like "[ a, b, c, d ]"; strip brackets then parse
                            const rowStr = w.sdf.replace(/^\s*\[\s*|\s*\]\s*$/g, '');
                            const toks = rowStr.split(',').map(s => parseFloat(s.trim()));
                            if (toks.length !== 4 || toks.some(v => !Number.isFinite(v))) return null;
                            return { word: w.word, row: toks };
                          })
                          .filter(Boolean);

                        // Input rows for sDFsupport
                        const rowsForSupport = pairs.map(p => p.row);
                        const supportFromCovectors = sDFsupport(rowsForSupport, { eps: 1e-9, tol: 1e-8 });
                        const facesFromCovectors = (supportFromCovectors.indices || []).map((idx, k) => ({
                          index: idx,
                          word: pairs[idx].word,
                          sdf: rowsForSupport[idx],
                          margin: supportFromCovectors.margins[k],
                        }));

                        const rows = facesFromCovectors.map((f, i)=>{
                          const sdfFmt = __formatRow(f.sdf).join(', ');
                          return `
                              <tr class="border-b border-gray-200 dark:border-gray-700">
                                <td class="px-3 py-2 font-mono text-xs sm:text-sm">${i+1}</td>
                                <td class="px-3 py-2 font-mono text-xs sm:text-sm whitespace-pre">${f.word || ''}</td>
                                <td class="px-3 py-2 font-mono text-xs sm:text-sm">[ ${sdfFmt} ]</td>
                                <td class="px-3 py-2 font-mono text-xs sm:text-sm">${(f.margin!==undefined? f.margin.toFixed(6):'')}</td>
                              </tr>`;
                        }).join('');

                        wordsSectionHTML = `
                          <div class="mt-6">
                            <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Face‑defining words (≤ ${L})</h4>
                            <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">
                              Covectors computed: <span class="font-mono">${pairs.length}</span>; Faces: <span class="font-mono">${facesFromCovectors.length}</span>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                              ${wordsConsideredHTML}
                              ${covectorsBoxHTML}
                            </div>
                            <div class="overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700 mt-3">
                              <table class="min-w-full text-left text-sm">
                                <thead class="bg-gray-100 dark:bg-gray-900/60">
                                  <tr>
                                    <th class="px-3 py-2">#</th>
                                    <th class="px-3 py-2">word</th>
                                    <th class="px-3 py-2">sDF [a,b,c,d]</th>
                                    <th class="px-3 py-2">margin</th>
                                  </tr>
                                </thead>
                                <tbody class="bg-white dark:bg-gray-800/40">
                                  ${rows || '<tr><td class="px-3 py-2" colspan="4">No faces detected.</td></tr>'}
                                </tbody>
                              </table>
                            </div>
                          </div>`;
                    } catch (e) {
                        wordsSectionHTML = `<div class="mt-6 text-sm text-red-600 dark:text-red-400">Word enumeration failed: ${e.message}</div>`;
                    }

                    // 3) Append summary section after resultsHTML and before MathJax typeset
                    const summaryHTML = `
                        <div class="mt-6">
                            <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">All covectors</h4>
                            <div class="bg-gray-100 dark:bg-gray-900/70 rounded-lg p-3 border border-gray-200 dark:border-gray-700">
                                <pre class="font-mono text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">${allCovectorLines.join('\n')}</pre>
                            </div>
                        </div>
                    ` + wordsSectionHTML;

                    // Build "Open polyhedron in Poincare" button (uses the x,y,z,t box content)
                    const openBtnHTML = `
                        <div class="mt-4">
                            <button id="open-poincare"
                                class="px-4 py-2 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 transition-all duration-200 bg-emerald-600 text-white hover:bg-emerald-700 focus:ring-emerald-500 shadow-sm hover:shadow-md">
                                Open polyhedron in Poincare
                            </button>
                        </div>
                    `;
                    summary.innerHTML = summaryHTML + openBtnHTML;
                    out.innerHTML = resultsHTML;
                    const openBtn = summary.querySelector('#open-poincare');
                    if (openBtn) {
                        openBtn.addEventListener('click', () => {
                            // Use the x,y, z, t order content as the payload
                            const payload = allCovectorLines.join('\n');
                            try {
                                // Save to localStorage for robust transfer
                                localStorage.setItem('poincare_input', payload);
                            } catch (e) {
                                // ignore storage errors (e.g., private mode)
                            }
                            // Also include a URL parameter with a base64-encoded copy
                            const b64 = btoa(payload);
                            const url = `poincare.html?vectors=${encodeURIComponent(b64)}#source=poincare_input`;
                            window.location.href = url;
                        });
                    }
                    // Attach copy handler for covectors for words
                    const copyCovBtn2 = summary.querySelector('#copy-words-covectors');
                    if (copyCovBtn2) copyCovBtn2.addEventListener('click', async () => {
                        try {
                            const text = (summary.querySelector('#words-covectors-pre')?.textContent || '').trim();
                            await navigator.clipboard.writeText(text);
                            copyCovBtn2.textContent = 'Copied!';
                            setTimeout(() => (copyCovBtn2.textContent = 'Copy'), 1200);
                        } catch (_) {}
                    });
                    if (window.MathJax && window.MathJax.typesetPromise) {
                        MathJax.typesetPromise([summary, out]).catch(() => {});
                    }

                } catch (e) {
                    summary.innerHTML = '';
                    out.innerHTML = `<div class="text-red-500 dark:text-red-400 p-4 bg-red-100 dark:bg-red-900/50 rounded-lg">${e.message}</div>`;
                }
            }

            // Event Listeners
            el('#psl-add').onclick = () => addMatrixForm();
            
            matrixList.addEventListener('click', e => {
                if (e.target.closest('.remove-matrix')) {
                    e.target.closest('.matrix-form').remove();
                    render();
                }
            });

            matrixList.addEventListener('input', render);

            card.addEventListener('input', (e)=>{
                if (e.target && e.target.id === 'psl-wordlen') render();
            });

            // Import button handler
            const importBtn = el('#psl-import');
            if (importBtn) importBtn.onclick = () => {
                if (!loadExternalMatricesIfAny()) {
                    alert('No external matrices found. Another page can set localStorage key "psl2c_matrices" or pass ?matrices=...');
                }
            };

            // Initial state: try to load from external payload; otherwise add a default form
            if (!loadExternalMatricesIfAny()) {
                addMatrixForm({ a: '1', b: '1', c: '0', d: '1' });
                addMatrixForm({ a: '0', b: '-1', c: '1', d: '0' });
            }
        }

        // --- END: UI Generation and Event Handling ---


        // --- Initialize the application ---
        document.addEventListener('DOMContentLoaded', () => {
            // Check for system dark mode preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            attachPSL2CtoSO31Tester('#app-container');
        });

    </script>
</body>

</html>