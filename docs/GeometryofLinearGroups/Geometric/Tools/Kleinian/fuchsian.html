<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Modular Group on the Poincaré Disk — Ray-Marched</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #0b0b10;
            color: #e8e8ef;
            font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        }

        #wrap {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-rows: auto 1fr;
        }

        header {
            display: flex;
            gap: .75rem;
            align-items: center;
            padding: .5rem .75rem;
            background: #0f0f16;
            border-bottom: 1px solid #1b1b24;
            position: relative;
            z-index: 1;
        }

        header h1 {
            font-size: 14px;
            font-weight: 600;
            margin: 0;
            color: #b9c2ff;
            letter-spacing: .2px;
        }

        .spacer {
            flex: 1;
        }

        .ctrl {
            display: flex;
            align-items: center;
            gap: .4rem;
            color: #cfcfe8;
        }

        .ctrl label {
            opacity: .85;
        }

        .ctrl input[type="range"] {
            width: 160px;
        }

        .btn {
            background: #1b1b28;
            border: 1px solid #29293a;
            color: #e8e8ef;
            border-radius: 8px;
            padding: .45rem .7rem;
            cursor: pointer;
        }

        .btn:hover {
            background: #222235;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #canvas.dragging {
            cursor: grabbing;
        }

        .hint {
            opacity: .7;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div id="wrap">
        <header>
            <h1>PSL(2,ℤ) on the Poincaré disk</h1>
            <div class="spacer"></div>
            <div class="ctrl"><label>Iter:</label><input id="iter" type="range" min="4" max="100" value="28"></div>
            <div class="ctrl"><label>Line:</label><input id="thick" type="range" min="1" max="40" value="16"></div>
            <button id="reset" class="btn">Reset view</button>
            <button id="save" class="btn" title="Save PNG">Save</button>
        </header>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // ——— WebGL2 setup ————————————————————————————————————————————————————————
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { antialias: true, preserveDrawingBuffer: true });
        if (!gl) { alert('WebGL2 not available'); throw new Error('WebGL2 required'); }

        const DPR = Math.max(1, window.devicePixelRatio || 1);
        function resize() {
            const w = canvas.clientWidth, h = canvas.clientHeight;
            canvas.width = Math.round(w * DPR);
            canvas.height = Math.round(h * DPR);
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        new ResizeObserver(resize).observe(canvas);

        // ——— Shaders ————————————————————————————————————————————————————————————————
        const vertSrc = `#version 300 es
precision highp float;
layout(location=0) in vec2 a_pos;
void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }`;

        const fragSrc = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform vec2  uRes;
uniform float uTime;
uniform float uZoom;      // world units per screen unit (smaller => zoom in)
uniform vec2  uCenter;    // world center
uniform int   uIters;     // max folding steps
uniform float uThickness; // line thickness knob (in screen px-ish)

// ————————————————————————————————————————————————————————————————
// Complex helpers
// Represent complex numbers as vec2 (x = Re, y = Im)
// ————————————————————————————————————————————————————————————————
vec2 c_add(vec2 a, vec2 b){ return a + b; }
vec2 c_sub(vec2 a, vec2 b){ return a - b; }
vec2 c_mul(vec2 a, vec2 b){ return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }
vec2 c_div(vec2 a, vec2 b){ float d = dot(b,b); return vec2(a.x*b.x + a.y*b.x, a.y*b.x - a.x*b.y) / d; }
float c_abs(vec2 a){ return length(a); }

// Cayley transform: disk -> upper half-plane
// w = i * (1+z) / (1-z)
vec2 disk_to_uhp(vec2 z){
    vec2 iC = vec2(0.0, 1.0);
    return c_mul(iC, c_div(c_add(vec2(1.0,0.0), z), c_sub(vec2(1.0,0.0), z)));
}

// Derivative magnitude |dw/dz| for Cayley at z (disk coord)
// dw/dz = i * 2 / (1 - z)^2  => |dw/dz| = 2 / |1 - z|^2
float cayley_scale(vec2 z){
    vec2 denom = c_sub(vec2(1.0,0.0), z);
    float denom2 = dot(denom,denom); // |1 - z|^2
    return 2.0 / max(denom2, 1e-18);
}

// Modular fold in the UHP for PSL(2,Z)
// Steps per iteration:
// 1) translate to center real part into [-1/2, 1/2]
// 2) if inside unit circle, apply S: w -> -1/w
// Track cumulative scale from chain rule (translations have |dw/dz|=1,
// inversion has |dw/dz| = 1/|w|^2 using the pre-image w before inversion).
struct DEOut { float dist; float shade; };

DEOut modularDE(vec2 w0, int maxSteps, float baseScale)
{
    vec2 w = w0;               // point in UHP
    float scale = baseScale;   // cumulative |dw/d(pixel)|
    float shade = 0.0;         // simple orbit counter for color

    for (int i=0; i<256; ++i) {
        if (i >= maxSteps) break;
        bool did = false;

        // (1) translate by nearest integer to land in the standard strip
        float n = floor(w.x + 0.5);
        if (abs(n) > 0.0) {
            w.x -= n; // w -> w - n
            did = true;
            shade += 0.25;
        }

        // (2) reflect across unit circle if inside
        float r = length(w);
        if (r < 1.0) {
            // S: w -> -1/w
            float s = 1.0 / max(r*r, 1e-18); // |dS/dw|
            w = - vec2(w.x, -w.y) / (r*r);   // -conj(w)/|w|^2 == -1/w for UHP (since w is real+imag)
            scale *= s;
            did = true;
            shade += 1.0;
        }

        if (!did) break; // in fundamental domain now
    }

    // Local Euclidean distance to the three boundaries in UHP
    float d1 = abs(w.x - 0.5);  // line Re w = 1/2
    float d2 = abs(w.x + 0.5);  // line Re w = -1/2
    float d3 = abs(length(w) - 1.0); // circle |w|=1
    float local = min(d3, min(d1, d2));

    float dist = local / max(scale, 1e-18);
    return DEOut(dist, shade);
}

vec3 palette(float t) {
    // Soft blue-magenta palette
    vec3 a = vec3(0.16, 0.12, 0.28);
    vec3 b = vec3(0.46, 0.60, 0.95);
    vec3 c = vec3(0.80, 0.25, 0.40);
    vec3 d = vec3(0.00, 0.85, 0.75);
    return a + b*cos(6.28318*(c*t + d));
}

void main(){
    // Pixel -> world coords in the DISK (keep aspect)
    vec2 uv = (gl_FragCoord.xy - 0.5*uRes) / uRes.y; // NDC preserving aspect
    vec2 z  = uv / uZoom + uCenter;                  // world coords in disk model

    // Mask outside the unit disk (just vignette to black)
    float R = length(z);
    if (R > 1.02) { fragColor = vec4(0.0); return; }

    // Map disk -> UHP with Cayley, track base scale
    float base = cayley_scale(z);
    vec2 w = disk_to_uhp(z);

    // Distance estimator by folding into the PSL(2,Z) fundamental domain
    DEOut de = modularDE(w, uIters, base);

    // Convert a thickness slider (in px) into a world-space AA width.
    float px = 1.0 / (uRes.y * uZoom);
    float thickness = (uThickness * 0.03) * px; // tweak factor
    float aa = fwidth(de.dist) + 0.75*px;

    // Line mask near geodesics of the fundamental tessellation
    float line = 1.0 - smoothstep(thickness, thickness + aa, de.dist);

    // Background inside disk + mild vignette
    float r2 = dot(uv, uv);
    vec3 bg = mix(vec3(0.04,0.05,0.07), vec3(0.015,0.018,0.030), smoothstep(0.0, 0.9, r2));

    // Orbit-tinted ink
    vec3 ink = palette(0.08*de.shade + 0.02*uTime);
    ink = mix(ink, vec3(0.98), 0.12);

    // Combine & slight glow
    vec3 col = mix(bg, ink, line);
    float glow = exp(-25.0 * max(de.dist - thickness, 0.0) / px);
    col += 0.02 * glow * ink;

    // Clip hard at unit circle of the DISK
    float diskMask = smoothstep(1.02, 1.0, R);
    col *= diskMask;

    fragColor = vec4(col, 1.0);
}
`;

        // ——— Program & VAO ————————————————————————————————————————————————————————
        function compile(gl, type, src) {
            const sh = gl.createShader(type);
            gl.shaderSource(sh, src);
            gl.compileShader(sh);
            if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
                const info = gl.getShaderInfoLog(sh);
                console.error(info);
                throw new Error('Shader compile failed');
            }
            return sh;
        }
        const vs = compile(gl, gl.VERTEX_SHADER, vertSrc);
        const fs = compile(gl, gl.FRAGMENT_SHADER, fragSrc);

        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            const info = gl.getProgramInfoLog(prog);
            console.error(info);
            throw new Error('Program link failed');
        }
        gl.useProgram(prog);

        // Fullscreen triangle
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 3, -1, -1, 3
        ]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // Uniform locations
        const uRes = gl.getUniformLocation(prog, 'uRes');
        const uTime = gl.getUniformLocation(prog, 'uTime');
        const uZoom = gl.getUniformLocation(prog, 'uZoom');
        const uCenter = gl.getUniformLocation(prog, 'uCenter');
        const uIters = gl.getUniformLocation(prog, 'uIters');
        const uThick = gl.getUniformLocation(prog, 'uThickness');
        // (no longer using uUseUnitInv, uUseRInv, uRInv)

        // ——— Interaction: pan/zoom, controls ————————————————————————————————
        let zoom = 1.0;
        let center = { x: 0.0, y: 0.0 };
        let t0 = performance.now();

        const iterEl = document.getElementById('iter');
        const thickEl = document.getElementById('thick');
        const resetBtn = document.getElementById('reset');
        const saveBtn = document.getElementById('save');

        resetBtn.onclick = () => { zoom = 0.95; center.x = 0.0; center.y = 0.0; };
        saveBtn.onclick = () => {
            const link = document.createElement('a');
            link.download = 'psl2z_disk.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        };

        let dragging = false, lastX = 0, lastY = 0;
        canvas.addEventListener('pointerdown', (e) => {
            dragging = true;
            lastX = e.clientX; lastY = e.clientY;
            canvas.setPointerCapture(e.pointerId);
            canvas.classList.add('dragging');
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!dragging) return;
            // Convert CSS pixel delta -> device pixels -> world units
            const dxDev = (e.clientX - lastX) * DPR;
            const dyDev = (e.clientY - lastY) * DPR;
            const worldDX = dxDev / (canvas.height * zoom);
            const worldDY = dyDev / (canvas.height * zoom);
            center.x -= worldDX;
            center.y += worldDY;
            lastX = e.clientX; lastY = e.clientY;
        });

        function endDrag(e) {
            dragging = false;
            canvas.classList.remove('dragging');
            try { canvas.releasePointerCapture(e.pointerId); } catch (_) { }
        }
        canvas.addEventListener('pointerup', endDrag);
        canvas.addEventListener('pointercancel', endDrag);

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            // Zoom around mouse position
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * DPR;
            const my = (e.clientY - rect.top) * DPR;
            const uvx = (mx - 0.5 * canvas.width) / canvas.height;
            const uvy = (my - 0.5 * canvas.height) / canvas.height;

            const worldBefore = { x: uvx / zoom + center.x, y: uvy / zoom + center.y };
            const factor = Math.exp(-e.deltaY * 0.0015);
            const newZoom = zoom * factor;
            // Prevent collapse to 0; keep huge range but enforce a tiny floor
            zoom = Math.max(1e-8, newZoom);
            const worldAfter = { x: uvx / zoom + center.x, y: uvy / zoom + center.y };
            center.x += (worldBefore.x - worldAfter.x);
            center.y += (worldBefore.y - worldAfter.y);
        }, { passive: false });

        // ——— Render loop ————————————————————————————————————————————————————————
        function draw() {
            resize();
            gl.useProgram(prog);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uTime, (performance.now() - t0) * 0.001);
            gl.uniform1f(uZoom, zoom);
            gl.uniform2f(uCenter, center.x, center.y);
            gl.uniform1i(uIters, parseInt(iterEl.value, 10));
            gl.uniform1f(uThick, parseFloat(thickEl.value));
            // (no longer setting uUseUnitInv, uUseRInv, uRInv)
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(draw);
        }
        resetBtn.click(); // set a nice default view
        draw();
    </script>
</body>

</html>