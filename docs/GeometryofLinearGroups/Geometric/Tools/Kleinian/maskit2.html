<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fractal Explorer (Riley Slice)</title>
    <!--
      This page renders an approximation to the limit set of a Kleinian group
      (the soâ€‘called Riley slice) in an interactive way.  The original
      implementation shipped with this project attempted to test membership
      of every point in the canvas by exhaustively walking a tree of
      generators; although mathematically correct, that approach quickly
      becomes intractable for even modest resolutions.  The rewritten
      implementation below replaces the escapeâ€‘time approach with a
      stochastic orbit algorithm: random words in the two generator group
      are sampled, the resulting MÃ¶bius transformations are applied to a
      fixed base point, and their images are accumulated onto a pixel grid.
      The accumulated counts form a density map which we then colour using
      a simple palette.  This yields a faithful and responsive depiction
      of the limit set while permitting interactive panning and zooming.
    -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŒ€</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        /* Simple spinning loader to indicate when the worker is
           computing the next frame. */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden flex flex-col h-screen">

    <!-- Main Content -->
    <main class="flex-grow relative w-full h-full">
        <canvas id="fractalCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        
        <!-- Loading Indicator -->
        <div id="loader" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 hidden flex-col items-center gap-2">
            <div class="loader"></div>
            <p class="text-gray-300">Rendering...</p>
        </div>
    </main>

    <!-- Control Panel -->
    <div class="bg-gray-800/80 backdrop-blur-sm p-4 w-full flex-shrink-0">
        <div class="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4 items-center">
            
            <!-- Mouse Position -->
            <div class="text-sm">
                <p class="font-bold text-gray-300">Cursor Position (Âµ)</p>
                <p id="mouseCoords" class="font-mono text-cyan-400">-</p>
            </div>

            <!-- Viewport Info -->
            <div class="text-sm">
                <p class="font-bold text-gray-300">View Center</p>
                <p id="viewCenter" class="font-mono text-green-400">-</p>
            </div>

            <!-- Parameter Âµ Input -->
            <div class="text-sm">
                <p class="font-bold text-gray-300">Parameter Âµ</p>
                <div class="flex gap-3 items-end">
                    <div class="flex flex-col">
                        <label for="muReal" class="text-xs text-gray-400">Re</label>
                        <input type="number" id="muReal" value="1.85" step="0.01" class="w-20 px-2 py-1 rounded text-black" />
                    </div>
                    <div class="flex flex-col">
                        <label for="muImag" class="text-xs text-gray-400">Im</label>
                        <input type="number" id="muImag" value="0.15" step="0.01" class="w-20 px-2 py-1 rounded text-black" />
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="md:col-span-1 lg:col-span-2 flex flex-col sm:flex-row gap-4 items-center justify-end">
                <!-- Maximum depth limit input -->
                <div class="w-full sm:w-auto flex items-center gap-3">
                    <label for="maxDepthInput" class="text-sm font-medium whitespace-nowrap">Max Depth:</label>
                    <input type="number" id="maxDepthInput" min="1" step="1" value="12" class="w-24 h-8 text-black rounded px-2 py-1" />
                </div>
                <!-- Depth slider -->
                <div class="w-full sm:w-auto flex items-center gap-3">
                    <label for="qualitySlider" class="text-sm font-medium whitespace-nowrap">Depth:</label>
                    <input type="range" id="qualitySlider" min="1" max="12" value="8" step="1" class="w-full sm:w-32 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer" />
                    <span id="qualityValue" class="text-sm font-bold w-8 text-right">8</span>
                </div>
                <button id="resetButton" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Reset View
                </button>
            </div>

        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const mouseCoordsEl = document.getElementById('mouseCoords');
        const viewCenterEl = document.getElementById('viewCenter');
        const qualitySlider = document.getElementById('qualitySlider');
        const qualityValueEl = document.getElementById('qualityValue');
        const resetButton = document.getElementById('resetButton');
        const loader = document.getElementById('loader');
        // Inputs for the complex parameter Âµ (mu) and maximum depth limit
        const muRealInput = document.getElementById('muReal');
        const muImagInput = document.getElementById('muImag');
        const maxDepthInput = document.getElementById('maxDepthInput');

        // --- Global State ---
        let view = {
            center: { re: 0.0, im: 0.0 },
            scale: 4.0 // half of the side length of the viewport
        };
        let maxDepth = 8; // controls the length of sampled words and the sampling density (current slider value)
        // Âµ parameter as a complex number (initialised from the input fields)
        let mu = {
            re: parseFloat(muRealInput.value),
            im: parseFloat(muImagInput.value)
        };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let renderTimeout;
        let isRendering = false;
        let worker;

        // --- Drawing and Rendering ---
        function drawFractal() {
            // terminate any existing render in progress
            if (isRendering) {
                if (worker) worker.terminate();
            }
            isRendering = true;
            loader.classList.remove('hidden');
            loader.classList.add('flex');

            // create a new worker on the fly.  The worker receives
            // configuration from the main thread and performs the heavy
            // computation of sampling random group words, projecting them
            // onto the complex plane, and building a density map.
            worker = new Worker(URL.createObjectURL(new Blob([`
                // --- Worker Code ---
                // Define some basic complex arithmetic helpers.
                const complex = {
                    add: (c1, c2) => ({ re: c1.re + c2.re, im: c1.im + c2.im }),
                    sub: (c1, c2) => ({ re: c1.re - c2.re, im: c1.im - c2.im }),
                    mul: (c1, c2) => ({
                        re: c1.re * c2.re - c1.im * c2.im,
                        im: c1.re * c2.im + c1.im * c2.re
                    }),
                    div: (c1, c2) => {
                        const denom = c2.re * c2.re + c2.im * c2.im;
                        return {
                            re: (c1.re * c2.re + c1.im * c2.im) / denom,
                            im: (c1.im * c2.re - c1.re * c2.im) / denom
                        };
                    }
                };
                // Multiply two 2Ã—2 complex matrices represented as an
                // array [a,b,c,d] where the matrix is [[a,b],[c,d]].
                const mat_mul = (m1, m2) => {
                    const a = complex.add(complex.mul(m1[0], m2[0]), complex.mul(m1[1], m2[2]));
                    const b = complex.add(complex.mul(m1[0], m2[1]), complex.mul(m1[1], m2[3]));
                    const c = complex.add(complex.mul(m1[2], m2[0]), complex.mul(m1[3], m2[2]));
                    const d = complex.add(complex.mul(m1[2], m2[1]), complex.mul(m1[3], m2[3]));
                    return [a, b, c, d];
                };

                self.onmessage = function(e) {
                    // Destructure incoming parameters, including the Âµ parameter
                    const { width, height, view, maxDepth, mu } = e.data;
                    const imageData = new Uint8ClampedArray(width * height * 4);
                    const aspect = width / height;

                    // Fill the background with a dark colour ahead of time.
                    for (let i = 0; i < width * height; i++) {
                        const idx = i * 4;
                        imageData[idx] = 15;
                        imageData[idx + 1] = 25;
                        imageData[idx + 2] = 40;
                        imageData[idx + 3] = 255;
                    }

                    // Define the generator matrices for the group.  These are
                    // MÃ¶bius transformations acting on the Riemann sphere.  We
                    // include both generators and their inverses.  The
                    // parameter \u03BC (mu) determines the Riley slice; here it is
                    // determined by the current view's centre (the cursor
                    // location) to allow the user to explore different
                    // Kleinian groups dynamically.
                    // Use a fixed complex parameter for the Kleinian group.  This
                    // constant determines the shape of the limit set.  Values
                    // with a nonâ€‘zero imaginary part yield rich fractal
                    // structure; feel free to experiment with different
                    // parameters.  For example {re: -0.5, im: 0.6} produces
                    // a classical Riley/Maskit slice.
                    const MA  = [ {re:1, im:0}, {re:1, im:0}, {re:0, im:0}, {re:1, im:0} ];
                    const MA_inv = [ {re:1, im:0}, {re:-1, im:0}, {re:0, im:0}, {re:1, im:0} ];
                    const MB  = [ {re:mu.re, im:mu.im}, {re:0, im:-1}, {re:0, im:-1}, {re:0, im:0} ];
                    const MB_inv = [ {re:0, im:0}, {re:0, im:1}, {re:0, im:1}, {re:mu.re, im:mu.im} ];
                    const gens = [ MA, MB, MA_inv, MB_inv ];
                    // The index of the inverse of each generator.  This
                    // prevents immediate cancellation when constructing random
                    // words (e.g. A followed by A\u207B\u00b9 should be skipped).
                    const inv_map = [2, 3, 0, 1];

                    // Determine how many random orbits to sample.  We scale
                    // the number of samples with the resolution and the
                    // requested depth.  Larger depths yield more detailed
                    // renderings; smaller depths render more quickly.
                    let sampleCount = Math.floor(width * height * 0.15 * (maxDepth / 8));
                    if (sampleCount < 30000) sampleCount = 30000;

                    // Accumulate visit counts for each pixel.  We use a
                    // 32â€‘bit integer array to store counts; this avoids
                    // overflow for typical sampling densities.
                    const counts = new Uint32Array(width * height);
                    let maxCount = 0;

                    // For each sample, build a random word of length
                    // maxDepth, multiply out the corresponding matrix and
                    // evaluate it at z0=0.  The resulting image of 0 under
                    // the MÃ¶bius transformation is b/d (where the matrix
                    // elements are [a,b,c,d]).  Points are then mapped into
                    // pixel coordinates using the current view parameters.
                    for (let s = 0; s < sampleCount; s++) {
                        // Begin with the identity matrix.
                        let M = [ {re:1, im:0}, {re:0, im:0}, {re:0, im:0}, {re:1, im:0} ];
                        // Choose an initial generator at random.  We don't
                        // worry about immediate inverses for the first step.
                        let last_gen_idx = Math.floor(Math.random() * 4);
                        M = mat_mul(M, gens[last_gen_idx]);
                        // Grow the word to the desired depth, avoiding
                        // immediate inverses.
                        for (let k = 1; k < maxDepth; k++) {
                            // Generate a random index in [0,3] but skip the
                            // inverse of the last generator.  We perform a
                            // simple rejection sampling loop here; since there
                            // are only four generators, the expected number of
                            // iterations is very small.
                            let idx;
                            do {
                                idx = Math.floor(Math.random() * 4);
                            } while (idx === inv_map[last_gen_idx]);
                            M = mat_mul(M, gens[idx]);
                            last_gen_idx = idx;
                        }
                        // Evaluate the transformation at z0 = 0.  For a
                        // matrix [a,b,c,d], the action on z is (a*z + b)/(c*z + d).
                        const b = M[1];
                        const d = M[3];
                        // Avoid division by a nearâ€‘zero denominator; skip
                        // samples that map to infinity (the point at infinity
                        // does not contribute to the limit set in the affine
                        // plane).
                        const denom = d.re * d.re + d.im * d.im;
                        if (denom === 0) continue;
                        const z_re = (b.re * d.re + b.im * d.im) / denom;
                        const z_im = (b.im * d.re - b.re * d.im) / denom;
                        // Map the complex point into pixel space.
                        let px = ( (z_re - view.center.re) / (view.scale * aspect) + 0.5 ) * width;
                        let py = ( 0.5 - (z_im - view.center.im) / view.scale ) * height;
                        // Round down to integer pixel indices.
                        px = Math.floor(px);
                        py = Math.floor(py);
                        if (px >= 0 && px < width && py >= 0 && py < height) {
                            const idx = py * width + px;
                            const newCount = ++counts[idx];
                            if (newCount > maxCount) maxCount = newCount;
                        }
                    }

                    // Colour the pixels based on their visit counts.  We use a
                    // simple powerâ€‘law scaling to map counts into an
                    // intensity between 0 and 1.  This emphasises detail in
                    // sparsely populated regions while preventing a few
                    // heavily hit pixels from washing out the image.  Pixels
                    // that are never visited remain at the background colour.
                    for (let i = 0; i < width * height; i++) {
                        const count = counts[i];
                        if (count > 0) {
                            const t = Math.pow(count / maxCount, 0.3);
                            const r = 210 * t;
                            const g = 230 * t;
                            const b = 255;
                            const idx = i * 4;
                            imageData[idx] = r;
                            imageData[idx + 1] = g;
                            imageData[idx + 2] = b;
                            // alpha remains 255
                        }
                    }

                    postMessage(imageData);
                };
            `], { type: 'application/javascript' })));

            worker.onmessage = (e) => {
                const imgData = new ImageData(e.data, canvas.width, canvas.height);
                ctx.putImageData(imgData, 0, 0);
                isRendering = false;
                loader.classList.add('hidden');
                loader.classList.remove('flex');
                worker = null;
            };

            worker.onerror = (e) => {
                console.error('Worker error:', e);
                isRendering = false;
                loader.classList.add('hidden');
                loader.classList.remove('flex');
                worker = null;
            };

            worker.postMessage({
                width: canvas.width,
                height: canvas.height,
                view: view,
                maxDepth: maxDepth,
                mu: mu
            });
        }

        // --- UI and Event Handlers ---
        function updateUI() {
            viewCenterEl.textContent = `Re: ${view.center.re.toFixed(4)}, Im: ${view.center.im.toFixed(4)}`;
            qualityValueEl.textContent = maxDepth;
        }
        
        function pixelToComplex(x, y) {
            const aspect = canvas.width / canvas.height;
            return {
                re: view.center.re + (x / canvas.width - 0.5) * view.scale * aspect,
                im: view.center.im - (y / canvas.height - 0.5) * view.scale
            };
        }

        function handleResize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            // Kick off a render after resizing; we debounce later.
            requestRender();
        }

        function requestRender() {
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(drawFractal, 100);
        }

        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            panStart.x = e.clientX;
            panStart.y = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const c = pixelToComplex(e.clientX - rect.left, e.clientY - rect.top);
            mouseCoordsEl.textContent = `Re: ${c.re.toFixed(4)}, Im: ${c.im.toFixed(4)}`;

            if (isPanning) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                const aspect = canvas.width / canvas.height;

                view.center.re -= (dx / canvas.width) * view.scale * aspect;
                view.center.im += (dy / canvas.height) * view.scale;

                panStart.x = e.clientX;
                panStart.y = e.clientY;
                
                updateUI();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isPanning) {
                isPanning = false;
                requestRender();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            mouseCoordsEl.textContent = '-';
            if (isPanning) {
                isPanning = false;
                requestRender();
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.15;
            const rect = canvas.getBoundingClientRect();
            const mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            const c_before = pixelToComplex(mousePos.x, mousePos.y);

            if (e.deltaY < 0) {
                view.scale /= zoomFactor;
            } else {
                view.scale *= zoomFactor;
            }

            const c_after = pixelToComplex(mousePos.x, mousePos.y);
            view.center.re += c_before.re - c_after.re;
            view.center.im += c_before.im - c_after.im;

            updateUI();
            requestRender();
        });

        qualitySlider.addEventListener('input', (e) => {
            maxDepth = parseInt(e.target.value);
            updateUI();
        });
        
        qualitySlider.addEventListener('change', () => {
            requestRender();
        });

        // When the maximum depth input changes, update the slider's range accordingly.
        maxDepthInput.addEventListener('change', () => {
            const newMax = parseInt(maxDepthInput.value);
            if (!isNaN(newMax) && newMax > 0) {
                // Update the slider's maximum allowed value
                qualitySlider.max = newMax;
                // If the current depth exceeds the new maximum, clamp it
                if (parseInt(qualitySlider.value) > newMax) {
                    qualitySlider.value = newMax;
                    maxDepth = newMax;
                }
                updateUI();
                requestRender();
            }
        });

        // Update the Âµ parameter whenever its inputs change and re-render.
        function updateMuParam() {
            const reVal = parseFloat(muRealInput.value);
            const imVal = parseFloat(muImagInput.value);
            if (!isNaN(reVal) && !isNaN(imVal)) {
                mu.re = reVal;
                mu.im = imVal;
                requestRender();
            }
        }
        muRealInput.addEventListener('change', updateMuParam);
        muImagInput.addEventListener('change', updateMuParam);

        resetButton.addEventListener('click', () => {
            // Reset view parameters
            view.center = { re: 0.0, im: 0.0 };
            view.scale = 4.0;
            // Reset the maximum depth input and slider range
            maxDepthInput.value = 12;
            qualitySlider.min = 1;
            qualitySlider.max = 12;
            // Reset the slider's current value (depth)
            qualitySlider.value = 8;
            maxDepth = 8;
            // Reset the Âµ parameter to its defaults
            muRealInput.value = 1.85;
            muImagInput.value = 0.15;
            mu.re = parseFloat(muRealInput.value);
            mu.im = parseFloat(muImagInput.value);
            updateUI();
            requestRender();
        });

        // --- Initialization ---
        function init() {
            window.addEventListener('resize', handleResize);
            handleResize();
            updateUI();
        }

        init();
    </script>
</body>
</html>