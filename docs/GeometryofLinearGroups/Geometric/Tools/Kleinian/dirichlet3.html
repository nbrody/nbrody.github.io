<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dirichlet Polyhedron Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
      #viewer { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
      /* Control panel */
      #controlPanel {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 320px;
        background: rgba(255,255,255,0.9);
        border-radius: 6px;
        padding: 12px;
        font-size: 13px;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        max-height: 50vh;
        overflow-y: auto;
      }
      #controlPanel h3 { margin: 4px 0 8px; font-size: 15px; }
      #controlPanel label { display: block; margin-top: 8px; font-weight: bold; line-height: 1.2; }
      .matrix-bracket { display: inline-block; font-size: 48px; font-weight: normal; line-height: 48px; vertical-align: middle; margin: 0 4px; }
      .matrix-grid-inline { display: inline-grid; grid-template-columns: repeat(2, 40px); grid-template-rows: repeat(2, 30px); grid-gap: 4px; vertical-align: middle; margin: 0 4px; }
      .matrix-grid-inline input { width: 40px; height: 30px; padding: 2px; font-size: 13px; text-align: center; }
      #controlPanel input[type="number"] { width: calc(100% - 12px); margin-top: 4px; padding: 4px; font-size: 13px; }
      #controlPanel button { margin-top: 12px; width: 100%; padding: 6px; font-size: 13px; cursor: pointer; }
      .matrix-block { margin-bottom: 8px; }
      /* Toggle hide/show control panel */
      #controlPanel.hidden { width: 40px; height: 40px; padding: 0; overflow: hidden; background: rgba(255,255,255,0.9); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
      .toggle-btn { position: absolute; top: 10px; right: 10px; width: 24px; height: 24px; background: none; border: none; font-size: 18px; line-height: 1; cursor: pointer; z-index: 12; }
      /* message box */
      #message-box { position: absolute; left: 50%; transform: translateX(-50%); top: 12px; background: rgba(33, 150, 243, 0.15); color: #0b5394; padding: 6px 10px; border-radius: 6px; font-size: 12px; z-index: 20; display: none; }
      #message-box.error { background: rgba(244, 67, 54, 0.15); color: #b71c1c; }
    </style>
</head>
<body class="bg-gray-900">
    <div id="viewer"></div>

    <button id="toggleControlPanelBtn" class="toggle-btn" aria-label="Hide panel">☰</button>
    <div id="controlPanel">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <h3 style="margin: 0;">Dirichlet Polyhedron</h3>
        <div style="display:flex; align-items:center; gap:6px;">
          <button id="prevPageBtn" title="Previous" style="padding: 2px 6px; font-size: 11px; width: 28px;">◀</button>
          <button id="nextPageBtn" title="Next" style="padding: 2px 6px; font-size: 11px; width: 28px;">▶</button>
          <button id="resetViewBtn" style="padding: 2px 6px; font-size: 11px; width: 100px; margin-left:6px;">Default view</button>
        </div>
      </div>
      <div id="panelPage1">
        <div id="matrixInputs"></div>
        <div style="display: flex; gap: 8px; margin-top: 12px;">
          <button id="addMatrixBtn">Add Matrix</button>
          <button id="updateGroupBtn">Update</button>
        </div>

        <label for="Lparam" style="display: flex; align-items: center; justify-content: space-between;">
          Word length:
          <input id="Lparam" type="number" value="4" min="1" step="1" style="width: 60px; margin-left: 10px;" />
        </label>

        <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 12px;">
          <label for="groupSelector" style="margin: 0;">Predefined group:</label>
          <select id="groupSelector" style="flex-grow: 1; margin: 0 6px;">
            <option value="">-- Select --</option>
            <option value="0">Modular group</option>
            <option value="1">Triangle group</option>
            <option value="2">Borromean-like</option>
            <option value="3">Z[i] congruence</option>
            <option value="4">Random example</option>
          </select>
          <button id="newExampleBtn" style="padding: 0px 6px; font-size: 10px; min-width: unset; width: auto; height: 20px; line-height: 20px;">??</button>
        </div>

        <button id="showStabilizerBtn" style="margin-top: 10px; width: 100%; padding: 6px; font-size: 13px; cursor: pointer;">Show stabilizer</button>
        <div id="stabilizerOutput" style="margin-top:8px; max-height: 160px; overflow: auto; background: #f8fafc; border: 1px solid #e5e7eb; padding: 6px; border-radius: 4px; word-break: break-word;"></div>

        <button id="printStdGensBtn" style="margin-top: 10px; width: 100%; padding: 6px; font-size: 13px; cursor: pointer;">Print standard generators</button>
        <div id="stdGensOutput" style="margin-top:8px; max-height: 160px; overflow: auto; background: #f8fafc; border: 1px solid #e5e7eb; padding: 6px; border-radius: 4px; word-break: break-word;"></div>
      </div>
      <div id="panelPage2" style="display:none;">
        <h4 style="margin: 8px 0 6px; font-size: 14px;">Display options</h4>
        <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
            <input id="toggleDelaunay" type="checkbox" />
            Show Delaunay edges (neighbors of o)
        </label>
        <label style="display:flex; align-items:center; gap:8px; margin-top:6px;">
            <input id="toggleOrbit" type="checkbox" />
            Show orbit of o
        </label>
        <label style="display:flex; align-items:center; gap:8px; margin-top:6px;">
            <input id="toggleWalls" type="checkbox" checked />
            Show walls
        </label>
      </div>
    </div>
    <div id="message-box"></div>

    <script type="module">
        // --- THREE.js Setup ---
        let scene, camera, renderer, controls;
        let polyhedronGroup = new THREE.Group();
        let delaunayGroup = new THREE.Group();
        let orbitGroup = new THREE.Group();
        const viewer = document.getElementById('viewer');
        const basepoint = new THREE.Vector3(0, 0, 1);
        let currentPage = 1;
        const NUM_PAGES = 2;

        function updatePanelPage() {
          const p1 = document.getElementById('panelPage1');
          const p2 = document.getElementById('panelPage2');
          if (p1 && p2) {
            p1.style.display = (currentPage === 1) ? '' : 'none';
            p2.style.display = (currentPage === NUM_PAGES) ? '' : 'none';
          }
          // Gray/disable pager arrows at bounds
          const prevBtn = document.getElementById('prevPageBtn');
          const nextBtn = document.getElementById('nextPageBtn');
          if (prevBtn) {
            const atStart = currentPage === 1;
            prevBtn.disabled = atStart;
            prevBtn.style.color = atStart ? '#9ca3af' : '';
            prevBtn.style.opacity = atStart ? '0.6' : '';
            prevBtn.style.cursor = atStart ? 'default' : 'pointer';
          }
          if (nextBtn) {
            const atEnd = currentPage === NUM_PAGES;
            nextBtn.disabled = atEnd;
            nextBtn.style.color = atEnd ? '#9ca3af' : '';
            nextBtn.style.opacity = atEnd ? '0.6' : '';
            nextBtn.style.cursor = atEnd ? 'default' : 'pointer';
          }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, -5, 3);
            camera.up.set(0, 0, 1);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.localClippingEnabled = true;
            renderer.clippingPlanes = [ new THREE.Plane(new THREE.Vector3(0, 0, 1), 0) ];
            viewer.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.copy(basepoint);
            const ambientLight = new THREE.AmbientLight(0xcccccc, 1.0);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(2, 3, 5);
            scene.add(directionalLight);
            const basepointGeom = new THREE.SphereGeometry(0.1, 16, 16);
            const basepointMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const basepointMesh = new THREE.Mesh(basepointGeom, basepointMat);
            basepointMesh.position.copy(basepoint);
            scene.add(basepointMesh);
            scene.add(polyhedronGroup);
            scene.add(delaunayGroup);
            scene.add(orbitGroup);
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- Complex Number and Matrix Logic ---
        class Complex {
            constructor(re = 0, im = 0) { this.re = re; this.im = im; }
            add(z) { return new Complex(this.re + z.re, this.im + z.im); }
            sub(z) { return new Complex(this.re - z.re, this.im - z.im); }
            mul(z) { return new Complex(this.re * z.re - this.im * z.im, this.re * z.im + this.im * z.re); }
            div(z) {
                const denom = z.re * z.re + z.im * z.im;
                if (denom === 0) return new Complex(Infinity, Infinity);
                return new Complex((this.re * z.re + this.im * z.im) / denom, (this.im * z.re - this.re * z.im) / denom);
            }
            conjugate() { return new Complex(this.re, -this.im); }
            normSq() { return this.re * this.re + this.im * this.im; }
            abs() { return Math.sqrt(this.normSq()); }
            toString() {
                const formatNum = (x) => {
                    // show integers without decimals, otherwise trim trailing zeros
                    if (Math.abs(x - Math.round(x)) < 1e-9) return String(Math.round(x));
                    return String(parseFloat(x.toFixed(6)));
                };
                const reZero  = Math.abs(this.re) < 1e-9;
                const imZero  = Math.abs(this.im) < 1e-9;

                // purely real
                if (imZero) return formatNum(this.re);

                // purely imaginary
                if (reZero) {
                    const coeff = this.im === 1 ? '' : this.im === -1 ? '-' : formatNum(this.im);
                    return `${coeff}i`;
                }

                // generic complex number
                const rePart = formatNum(this.re);
                const imAbs  = Math.abs(this.im);
                const imPart = imAbs === 1 ? 'i' : `${formatNum(imAbs)}i`;
                const sign   = this.im < 0 ? '-' : '+';
                return `${rePart} ${sign} ${imPart}`;
            }
        }
        // ---- Expression parser for complex inputs ----
        // Supports: +, -, *, /, ^ (integer powers), parentheses, sqrt(...), and i
        // Examples: "1/2", "(1+sqrt(2))/2", "-i/3", "((1+sqrt(5))/2)^2", "3 - (1+i)/3"
        function parseComplex(str) {
          if (!str || typeof str !== 'string') return new Complex(0, 0);
          // Normalize & insert implicit multiplications like "2i", ")(", ")i", "2(" or "2sqrt("
          let s = str.trim();
          // Replace unicode minus and normalize spaces
          s = s.replace(/\u2212/g, '-').replace(/\s+/g, ''); 
          // Canonicalize standalone i variants
          s = s.replace(/^i$/, '1*i')
               .replace(/^-i$/, '-1*i')
               .replace(/\+i/g, '+1*i')
               .replace(/-i/g, '-1*i');
          // Insert implicit multiplication between: number/close-paren and (i | sqrt | '(')
          s = s
            .replace(/(\d|\))(?=i|\(|sqrt\()/g, '$1*')
            .replace(/(i|\))(?=\()/g, '$1*'); // e.g., "i(1+1)"

          // Tokenizer
          const TOK = { NUM:'NUM', I:'I', SQRT:'SQRT', PLUS:'PLUS', MINUS:'MINUS', MUL:'MUL', DIV:'DIV', POW:'POW', LP:'LP', RP:'RP', EOF:'EOF' };
          const tokens = [];
          for (let i = 0; i < s.length; ) {
            const c = s[i];
            if (/\d/.test(c) || (c === '.' && /\d/.test(s[i+1] || ''))) {
              let j = i + 1;
              while (j < s.length && /[\d.]/.test(s[j])) j++;
              tokens.push({ t: TOK.NUM, v: parseFloat(s.slice(i, j)) });
              i = j; continue;
            }
            if (c === 'i') { tokens.push({ t: TOK.I }); i++; continue; }
            if (c === '+') { tokens.push({ t: TOK.PLUS }); i++; continue; }
            if (c === '-') { tokens.push({ t: TOK.MINUS }); i++; continue; }
            if (c === '*') { tokens.push({ t: TOK.MUL }); i++; continue; }
            if (c === '/') { tokens.push({ t: TOK.DIV }); i++; continue; }
            if (c === '^') { tokens.push({ t: TOK.POW }); i++; continue; }
            if (c === '(') { tokens.push({ t: TOK.LP }); i++; continue; }
            if (c === ')') { tokens.push({ t: TOK.RP }); i++; continue; }
            if (c === 's' && s.slice(i, i+4) === 'sqrt') {
              tokens.push({ t: TOK.SQRT }); i += 4; continue;
            }
            // Unknown character -> error: return NaN complex
            return new Complex(NaN, NaN);
          }
          tokens.push({ t: TOK.EOF });

          // Parser helpers
          let pos = 0;
          const peek = () => tokens[pos];
          const eat = (type) => {
            if (tokens[pos].t === type) { pos++; return true; }
            return false;
          };

          function complex(re, im=0) { return new Complex(re, im); }
          function cadd(a,b){ return new Complex(a.re+b.re, a.im+b.im); }
          function csub(a,b){ return new Complex(a.re-b.re, a.im-b.im); }
          function cmul(a,b){ return a.mul(b); }
          function cdiv(a,b){ return a.div(b); }
          function cpowInt(a, n) {
            if (!Number.isFinite(n) || Math.floor(n) !== n) return new Complex(NaN, NaN);
            if (n === 0) return new Complex(1,0);
            if (n < 0) {
              const inv = a.div(new Complex(1,0)); // ensure Complex
              const ai = a.inverse ? a.inverse() : null;
              const denom = a.re*a.re + a.im*a.im;
              if (denom === 0) return new Complex(Infinity, Infinity);
              const invc = new Complex(a.re/denom, -a.im/denom);
              return cpowInt(invc, -n);
            }
            let r = new Complex(1,0), base = new Complex(a.re, a.im), k = n;
            while (k > 0) {
              if (k & 1) r = cmul(r, base);
              base = cmul(base, base);
              k >>= 1;
            }
            return r;
          }

          // Grammar:
          // expr   := term (('+'|'-') term)*
          // term   := factor (('*'|'/') factor)*
          // factor := unary ('^' unary)*  // right-assoc via loop capturing last
          // unary  := ('+'|'-') unary | primary
          // primary:= NUM | 'i' | 'sqrt' '(' expr ')' | '(' expr ')'

          function parsePrimary() {
            if (eat(TOK.NUM)) {
              return complex(tokens[pos-1].v, 0);
            }
            if (eat(TOK.I)) {
              return complex(0, 1);
            }
            if (eat(TOK.SQRT)) {
              if (!eat(TOK.LP)) return complex(NaN, NaN);
              const inner = parseExpr();
              if (!eat(TOK.RP)) return complex(NaN, NaN);
              // sqrt only for (almost) real nonnegative values
              if (Math.abs(inner.im) < 1e-12) {
                const val = inner.re;
                if (val >= -1e-12) return complex(Math.sqrt(Math.max(0, val)), 0);
              }
              // Fallback: principal sqrt of complex
              const r = Math.hypot(inner.re, inner.im);
              const theta = Math.atan2(inner.im, inner.re);
              const rootR = Math.sqrt(r);
              const half = theta/2;
              return complex(rootR * Math.cos(half), rootR * Math.sin(half));
            }
            if (eat(TOK.LP)) {
              const e = parseExpr();
              if (!eat(TOK.RP)) return complex(NaN, NaN);
              return e;
            }
            // Unexpected token
            return complex(NaN, NaN);
          }

          function parseUnary() {
            if (eat(TOK.PLUS)) return parseUnary();
            if (eat(TOK.MINUS)) {
              const u = parseUnary();
              return complex(-u.re, -u.im);
            }
            return parsePrimary();
          }

          function parseFactor() {
            // Right-associative power
            let base = parseUnary();
            while (eat(TOK.POW)) {
              const exponent = parseUnary();
              // We only support ^ with integer real exponents
              if (Math.abs(exponent.im) > 1e-12 || Math.abs(exponent.re - Math.round(exponent.re)) > 1e-12) {
                // Non-integer or complex exponent -> use principal complex power via exp(log)
                const r = Math.hypot(base.re, base.im);
                const theta = Math.atan2(base.im, base.re);
                const lnz = new Complex(Math.log(r), theta);
                const expArg = cmul(lnz, exponent);
                const mag = Math.exp(expArg.re);
                base = complex(mag * Math.cos(expArg.im), mag * Math.sin(expArg.im));
              } else {
                base = cpowInt(base, Math.round(exponent.re));
              }
            }
            return base;
          }

          function parseTerm() {
            let v = parseFactor();
            for (;;) {
              if (eat(TOK.MUL)) v = cmul(v, parseFactor());
              else if (eat(TOK.DIV)) v = cdiv(v, parseFactor());
              else break;
            }
            return v;
          }

          function parseExpr() {
            let v = parseTerm();
            for (;;) {
              if (eat(TOK.PLUS)) v = cadd(v, parseTerm());
              else if (eat(TOK.MINUS)) v = csub(v, parseTerm());
              else break;
            }
            return v;
          }

          const result = parseExpr();
          // If trailing tokens remain before EOF, treat as error
          if (peek().t !== TOK.EOF) return new Complex(NaN, NaN);
          // Clean tiny zeros
          const re = Math.abs(result.re) < 1e-12 ? 0 : result.re;
          const im = Math.abs(result.im) < 1e-12 ? 0 : result.im;
          return new Complex(re, im);
        }
        class Matrix2 {
            constructor(a, b, c, d) { this.a = a; this.b = b; this.c = c; this.d = d; }
            multiply(m) { return new Matrix2(this.a.mul(m.a).add(this.b.mul(m.c)), this.a.mul(m.b).add(this.b.mul(m.d)), this.c.mul(m.a).add(this.d.mul(m.c)), this.c.mul(m.b).add(this.d.mul(m.d))); }
            inverse() {
                const det = this.a.mul(this.d).sub(this.b.mul(this.c));
                if (det.normSq() === 0) return null;
                const invDet = new Complex(1, 0).div(det);
                return new Matrix2(this.d.mul(invDet), this.b.mul(new Complex(-1, 0)).mul(invDet), this.c.mul(new Complex(-1, 0)).mul(invDet), this.a.mul(invDet));
            }
            isIdentity() {
                return Math.abs(this.a.re - 1) < 1e-9 && Math.abs(this.a.im) < 1e-9 &&
                       Math.abs(this.b.re) < 1e-9 && Math.abs(this.b.im) < 1e-9 &&
                       Math.abs(this.c.re) < 1e-9 && Math.abs(this.c.im) < 1e-9 &&
                       Math.abs(this.d.re - 1) < 1e-9 && Math.abs(this.d.im) < 1e-9;
            }
        }

        function isClose(x, y, tol = 1e-6) { return Math.abs(x - y) < tol; }
        function isZero(z, tol = 1e-6) { return Math.abs(z.re) < tol && Math.abs(z.im) < tol; }

        // --- Global de-duplication helpers ---
        const KEY_SCALE = 1e6; // tolerance ~1e-6
        function keyFromNumber(x, scale = KEY_SCALE) { return Math.round(x * scale); }
        function keyFromVec(vec, scale = KEY_SCALE) {
          return `${keyFromNumber(vec.x, scale)}:${keyFromNumber(vec.y, scale)}:${keyFromNumber(vec.z, scale)}`;
        }
        function keyFromMatrix(m, scale = KEY_SCALE) {
          const parts = [m.a.re, m.a.im, m.b.re, m.b.im, m.c.re, m.c.im, m.d.re, m.d.im]
            .map(v => keyFromNumber(v, scale));
          return parts.join(';');
        }

        // Check if m ∈ SU(2): columns orthonormal and det ≈ 1
        function isUnitary(m, tol = 1e-6) {
          // Column norms
          const n1 = m.a.normSq() + m.c.normSq();
          const n2 = m.b.normSq() + m.d.normSq();
          // Column orthogonality: a\bar b + c\bar d ≈ 0
          const ab = m.a.mul(m.b.conjugate());
          const cd = m.c.mul(m.d.conjugate());
          const ip = new Complex(ab.re + cd.re, ab.im + cd.im); // a\bar b + c\bar d
          // det ≈ 1 (real)
          const det = m.a.mul(m.d).sub(m.b.mul(m.c));
          return isClose(n1, 1, tol) && isClose(n2, 1, tol) && isZero(ip, tol) && isClose(det.re, 1, tol) && Math.abs(det.im) < tol;
        }

        function matrixToString(m) {
          const a = m.a.toString(), b = m.b.toString(), c = m.c.toString(), d = m.d.toString();
          return `[[${a}, ${b}],\n [${c}, ${d}]]`;
        }

        // Complex/Matrix → LaTeX
        function complexToLatex(z) {
          const re = Math.abs(z.re) < 1e-9 ? 0 : z.re;
          const im = Math.abs(z.im) < 1e-9 ? 0 : z.im;
          const fmt = (v) => (Math.abs(v - Math.round(v)) < 1e-9 ? String(Math.round(v)) : String(parseFloat(v.toFixed(6))));
          if (im === 0) return fmt(re);
          if (re === 0) return im === 1 ? 'i' : (im === -1 ? '-i' : fmt(im) + 'i');
          const sign = im < 0 ? ' - ' : ' + ';
          const iabs = Math.abs(im);
          const imag = iabs === 1 ? 'i' : fmt(iabs) + 'i';
          return fmt(re) + sign + imag;
        }

        function matrixToLatex(m) {
          return `\\( \\begin{pmatrix} ${complexToLatex(m.a)} & ${complexToLatex(m.b)} \\\\ ${complexToLatex(m.c)} & ${complexToLatex(m.d)} \\end{pmatrix} \\)`;
        }

        // --- UI Logic (Limitsets-style panel) ---
        const generators = [];
        const messageBox = document.getElementById('message-box');
        function typesetMath() {
          if (window.MathJax && MathJax.typesetPromise) {
            // Only typeset the control panel where the math appears
            MathJax.typesetPromise([document.getElementById('controlPanel')]).catch(() => {});
          }
        }

        function showMessage(message, isError = false) {
          messageBox.textContent = message;
          messageBox.className = isError ? 'error' : '';
          messageBox.style.display = 'block';
          clearTimeout(showMessage._t);
          showMessage._t = setTimeout(() => { messageBox.style.display = 'none'; }, 4000);
        }

        function addMatrixInput(values=['1','0','0','1']) {
          const idx = document.querySelectorAll('#matrixInputs .matrix-block').length;
          const container = document.createElement('div');
          container.className = 'matrix-block';
          container.innerHTML = `
            <div style="display:flex;align-items:center;">
              <label style="flex-grow:1;">
                <span class="matrix-label">\\( g_{${idx+1}} = \\)</span>
                <span class="matrix-bracket">(</span>
                <span class="matrix-grid-inline">
                  <input type="text" value="${values[0]}" />
                  <input type="text" value="${values[1]}" />
                  <input type="text" value="${values[2]}" />
                  <input type="text" value="${values[3]}" />
                </span>
                <span class="matrix-bracket">)</span>
              </label>
              <button class="delete-matrix-btn" style="margin-left:8px;width:26px;height:30px;">✖</button>
            </div>`;
          container.querySelector('.delete-matrix-btn').addEventListener('click', () => {
            container.remove();
            const labels = document.querySelectorAll('#matrixInputs .matrix-label');
            labels.forEach((lbl,i)=>{ lbl.innerHTML = `\\( g_{${i+1}} = \\)`; });
            typesetMath();
          });
          document.getElementById('matrixInputs').appendChild(container);
          const labels = document.querySelectorAll('#matrixInputs .matrix-label');
          labels.forEach((lbl,i)=>{ lbl.innerHTML = `\\( g_{${i+1}} = \\)`; });
          typesetMath();
        }

        function rebuildGeneratorsFromUI() {
          generators.length = 0;
          const blocks = document.querySelectorAll('#matrixInputs .matrix-block');
          for (const block of blocks) {
            const ins = block.querySelectorAll('input');
            const a = parseComplex(ins[0].value);
            const b = parseComplex(ins[1].value);
            const c = parseComplex(ins[2].value);
            const d = parseComplex(ins[3].value);
            const det = a.mul(d).sub(b.mul(c));
            // Enforce det ≈ 1 (PSL(2, C))
            if (Math.abs(det.re - 1) > 1e-4 || Math.abs(det.im) > 1e-4) {
              showMessage('Determinant should be 1 (up to numerical error).', true);
              continue;
            }
            generators.push(new Matrix2(a, b, c, d));
          }
        }

        function setExample(example) {
          document.getElementById('matrixInputs').innerHTML = '';
          example.forEach(vals => addMatrixInput(vals));
          typesetMath();
        }

        const exampleLibrary = [
          // Apollonian Gasket
          [ ['1','1+i','0','1'], ['0','-1','1','0'] ],
          // Triangle-like
          [ ['1','2i','0','1'], ['1','-1','1','1'] ],
          // Borromean-like
          [ ['1','2','0','1'], ['1','i','0','1'], ['1','0','-1-i','1'] ],
          // Z[i] congruence
          [ ['1','2','0','1'], ['1','2i','0','1'], ['0','-1','1','0'] ],
          // Random placeholder (same as triangle)
          [ ['2','-2','0','1/2'], ['3','4','2','3'] ]
        ];

        function setupPanelUI() {
          document.getElementById('addMatrixBtn').addEventListener('click', () => addMatrixInput());
          document.getElementById('updateGroupBtn').addEventListener('click', () => { 
            rebuildGeneratorsFromUI(); 
            generateAndDrawPolyhedron();
            showMessage(`Generated polyhedron for word length ${document.getElementById('Lparam').value}.`);
          });
          document.getElementById('Lparam').addEventListener('change', () => {
            rebuildGeneratorsFromUI();
            generateAndDrawPolyhedron();
          });
          document.getElementById('groupSelector').addEventListener('change', (e) => {
            const idx = parseInt(e.target.value, 10);
            if (!isNaN(idx)) {
              setExample(exampleLibrary[idx]);
              rebuildGeneratorsFromUI();
              generateAndDrawPolyhedron();
              typesetMath();
            }
          });
          document.getElementById('newExampleBtn').addEventListener('click', () => {
            const rand = exampleLibrary[Math.floor(Math.random()*exampleLibrary.length)];
            setExample(rand);
            rebuildGeneratorsFromUI();
            generateAndDrawPolyhedron();
            typesetMath();
          });
          document.getElementById('toggleControlPanelBtn').addEventListener('click', () => {
            const panel = document.getElementById('controlPanel');
            panel.classList.toggle('hidden');
            document.getElementById('toggleControlPanelBtn').setAttribute(
              'aria-label', panel.classList.contains('hidden') ? 'Show panel' : 'Hide panel'
            );
          });
          document.getElementById('resetViewBtn').addEventListener('click', () => {
            camera.position.set(0, -5, 3);
            controls.target.set(0, 0, 1);
            controls.update();
          });
          // --- Show stabilizer button logic ---
          const stabBtn = document.getElementById('showStabilizerBtn');
          if (stabBtn) stabBtn.addEventListener('click', () => {
            rebuildGeneratorsFromUI();
            const L = parseInt((document.getElementById('Lparam') || { value: 1 }).value) || 1;
            const groupElements = generateGroupElements(generators, L);
            const su2 = groupElements.filter(g => isUnitary(g));

            // Ensure the identity matrix is included in the SU(2) list
            const I = new Matrix2(
              new Complex(1, 0), new Complex(0, 0),
              new Complex(0, 0), new Complex(1, 0)
            );
            const hasIdentity = su2.some(m => typeof m.isIdentity === 'function' && m.isIdentity());
            if (!hasIdentity) su2.unshift(I);

            const out = document.getElementById('stabilizerOutput');
            if (!out) return;
            if (su2.length === 0) {
              out.textContent = 'No SU(2) elements found among generated words.';
            } else {
              out.textContent = su2.map((m, i) => `g_${i+1} ∈ SU(2):\n${matrixToString(m)}`).join('\n\n');
            }
            showMessage(`Stabilizer elements found: ${su2.length}.`);
          });

          // --- Print standard generators (Delaunay neighbors) ---
          const stdBtn = document.getElementById('printStdGensBtn');
          if (stdBtn) stdBtn.addEventListener('click', () => {
            rebuildGeneratorsFromUI();
            const L = parseInt((document.getElementById('Lparam') || { value: 1 }).value) || 1;
            const groupElements = generateGroupElements(generators, L);
            const neighbors = computeDelaunayNeighbors(groupElements);
            const out = document.getElementById('stdGensOutput');
            if (!out) return;
            if (!neighbors || neighbors.length === 0) {
              out.textContent = 'No Delaunay neighbors found. Increase word length or adjust generators.';
            } else {
              const items = neighbors.map((obj, i) => `${i+1}. ${matrixToLatex(obj.g)}`);
              out.innerHTML = items.join('<br/><br/>');
              if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([document.getElementById('controlPanel')]).catch(() => {});
              }
            }
            showMessage(`Printed ${neighbors.length} standard generators (Delaunay neighbors).`);
          });
          // --- Pager controls ---
          const prevBtn = document.getElementById('prevPageBtn');
          const nextBtn = document.getElementById('nextPageBtn');
          if (prevBtn) prevBtn.addEventListener('click', () => {
            if (currentPage <= 1) return;
            currentPage = Math.max(1, currentPage - 1);
            updatePanelPage();
            typesetMath();
          });
          if (nextBtn) nextBtn.addEventListener('click', () => {
            if (currentPage >= NUM_PAGES) return;
            currentPage = Math.min(NUM_PAGES, currentPage + 1);
            updatePanelPage();
            typesetMath();
          });
          updatePanelPage();
        }

        // --- Hyperbolic Geometry & Drawing ---
        function clearGroup(group){
          while (group.children.length > 0) {
            const obj = group.children[0];
            group.remove(obj);
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (obj.material.dispose) obj.material.dispose();
              // handle arrays of materials
              if (Array.isArray(obj.material)) obj.material.forEach(m=>m && m.dispose && m.dispose());
            }
          }
        }

        function clearDelaunay(){ clearGroup(delaunayGroup); }
        function clearOrbit(){ clearGroup(orbitGroup); }

        // Hyperbolic distance in upper half-space H^3 with height = z > 0
        function hDist(p, q) {
          const dx = p.x - q.x, dy = p.y - q.y, dz = p.z - q.z;
          const num = dx*dx + dy*dy + dz*dz;
          const den = 2 * p.z * q.z;
          const c = 1 + num / den;
          return Math.acosh(Math.max(1, c));
        }
        
        function clearPolyhedron(){ clearGroup(polyhedronGroup); }
        function generateGroupElements(gens, wordLength) {
            const elements = new Map();
            const initialSet = [...gens];
            gens.forEach(g => {
                const inv = g.inverse();
                if (inv) initialSet.push(inv);
            });

            let queue = [...initialSet];
            const I = new Matrix2(new Complex(1,0), new Complex(0,0), new Complex(0,0), new Complex(1,0));
            const identityKey = keyFromMatrix(I);
            elements.set(identityKey, I);
            
            queue.forEach(g => {
                const key = keyFromMatrix(g);
                elements.set(key, g);
            });

            for (let l = 1; l < wordLength; l++) {
                const nextQueue = [];
                for (const word of queue) {
                    for (const g of initialSet) {
                        const newWord = word.multiply(g);
                        if (newWord.isIdentity()) continue;
                        const key = keyFromMatrix(newWord);
                        if (!elements.has(key)) {
                            elements.set(key, newWord);
                            nextQueue.push(newWord);
                        }
                    }
                }
                queue = nextQueue;
            }
            
            const out = Array.from(elements.entries())
              .filter(([k, _]) => k !== identityKey)
              .map(([_, v]) => v);
            return out;
        }
        // Image of the basepoint o=(0,0,1) under m in PSL(2,C)
        // For m = [a b; c d], we have: m·o = ( (a\bar c + b\bar d) / (|c|^2 + |d|^2),  1 / (|c|^2 + |d|^2) )
        // We map (u, t) to THREE as (x, y, z) = (Re(u), Im(u), t).
        function imageOfBasepoint(m) {
            const cAbs2 = m.c.normSq();
            const dAbs2 = m.d.normSq();
            const denom = cAbs2 + dAbs2; // real scalar > 0
            if (denom === 0) return { u: new Complex(0,0), t: Infinity };
            const a_conj_c = m.a.mul(m.c.conjugate());
            const b_conj_d = m.b.mul(m.d.conjugate());
            const u = a_conj_c.add(b_conj_d);
            // divide complex by real scalar
            const invDen = 1.0 / denom;
            const uScaled = new Complex(u.re * invDen, u.im * invDen);
            const t = invDen;
            return { u: uScaled, t: t };
        }

        function computeOrbitPoints(groupElements) {
            // return only images g·o (exclude the original basepoint which is already drawn)
            const pts = [];
            for (const g of groupElements) {
                const p = imageOfBasepoint(g); // orbit uses g·o (not g^{-1}·o)
                if (!isFinite(p.t) || p.t <= 0) continue;
                // Skip if numerically equal to the basepoint
                if (Math.abs(p.u.re) < 1e-12 && Math.abs(p.u.im) < 1e-12 && Math.abs(p.t - 1) < 1e-12) continue;
                pts.push(new THREE.Vector3(p.u.re, p.u.im, p.t));
            }
            return pts;
        }

        // Draw the Dirichlet bisector (perpendicular bisector in H^3) between basepoint o=(0,0,1) and p=(u,t)
        // The bisector is a hemisphere (center on t=0) or, in the limiting case t≈1, a vertical plane.
        function drawBisector(p, q, material) {
          // p, q are THREE.Vector3 with z>0; default q is the basepoint o=(0,0,1)
          if (!p) return;
          q = q || basepoint;

          const xp = p.x, yp = p.y, zp = p.z;
          const xq = q.x, yq = q.y, zq = q.z;

          const eps = 1e-9;

          // If heights are equal, the bisector is a vertical plane (normal in xy-plane)
          if (Math.abs(zp - zq) < eps) {
            const nx = xq - xp;
            const ny = yq - yp;
            const n = new THREE.Vector3(nx, ny, 0);
            if (n.length() < eps) return; // degenerate
            n.normalize();

            // Use Euclidean mid-height and solve n_x x + n_y y = d for a point on the plane
            const Sp = xp*xp + yp*yp + zp*zp;
            const Sq = xq*xq + yq*yq + zq*zq;
            const d = (Sq - Sp) / 2; // n_x x + n_y y = d
            const nlen2 = (xq - xp)*(xq - xp) + (yq - yp)*(yq - yp);
            const scale = nlen2 < eps ? 0 : d / nlen2;
            const pointOnPlane = new THREE.Vector3((xq - xp) * scale, (yq - yp) * scale, (zp + zq) / 2);

            const planeGeom = new THREE.PlaneGeometry(40, 40);
            const planeMesh = new THREE.Mesh(planeGeom, material);
            // Start from a plane with normal along +z, rotate it so its normal is n (in xy plane)
            planeMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), n);
            planeMesh.position.copy(pointOnPlane);
            polyhedronGroup.add(planeMesh);
            return;
          }

          // Hemisphere orthogonal to boundary (center on z=0)
          // From equality of hyperbolic distances: z_q |(x,y) - p_xy|^2 = z_p |(x,y) - q_xy|^2
          const denom = (zq - zp);
          const cx = (zq * xp - zp * xq) / denom;
          const cy = (zq * yp - zp * yq) / denom;
          const cz = 0;

          const Sp = xp*xp + yp*yp + zp*zp;
          const Sq = xq*xq + yq*yq + zq*zq;
          const c2 = cx*cx + cy*cy + cz*cz;
          const r2 = c2 - (zq * Sp - zp * Sq) / denom;
          if (!(r2 > eps)) return; // invalid/degenerate
          const r = Math.sqrt(r2);

          // Build a hemisphere whose flat face lies in z=0 and dome extends into z>0.
          const geometry = new THREE.SphereGeometry(r, 64, 32, 0);
          const hemisphere = new THREE.Mesh(geometry, material);
          // Rotate so the hemisphere opens along +z instead of +y
          hemisphere.rotation.x = -Math.PI / 2;
          hemisphere.position.set(cx, cy, 0);
          polyhedronGroup.add(hemisphere);
        }

        function samplePointsOnBisector(u, t, maxSamples = 160) {
          // (x, y, z) = (Re u, Im u, t). Boundary is z=0. Basepoint o=(0,0,1).
          const pts = [];
          const eps = 1e-9;

          // If t ≈ 1, the bisector between o and p is a vertical plane in z, with normal in the xy-plane
          if (Math.abs(t - 1.0) < eps) {
            const n = new THREE.Vector3(u.re, u.im, 0);
            if (n.length() < eps) return pts;
            n.normalize();
            const tmp = Math.abs(n.z) < 0.9 ? new THREE.Vector3(0,0,1) : new THREE.Vector3(1,0,0);
            const b1 = new THREE.Vector3().crossVectors(n, tmp).normalize();
            const b2 = new THREE.Vector3().crossVectors(n, b1).normalize();
            const center = new THREE.Vector3(u.re/2, u.im/2, 1);
            const R = 2.5, steps = Math.max(4, Math.floor(Math.sqrt(maxSamples)));
            for (let i = -steps; i <= steps; i++) {
              for (let j = -steps; j <= steps; j++) {
                const s = i/steps, t2 = j/steps;
                const p = new THREE.Vector3().copy(center)
                  .addScaledVector(b1, R*s)
                  .addScaledVector(b2, R*t2);
                if (p.z > eps) pts.push(p);
              }
            }
            return pts;
          }

          // Hemisphere case (center on z=0, orthogonal to boundary)
          const oneMinusT = 1 - t;
          if (Math.abs(oneMinusT) < eps) return pts;
          const cx = u.re / oneMinusT, cy = u.im / oneMinusT;
          const r2 = t * (1 + (u.re*u.re + u.im*u.im) / (oneMinusT*oneMinusT));
          if (r2 <= eps) return pts;
          const r = Math.sqrt(r2);
          const center = new THREE.Vector3(cx, cy, 0);

          const rings = Math.max(6, Math.floor(Math.sqrt(maxSamples)));
          const segs  = rings * 2;
          for (let i = 1; i <= rings; i++) {
            const phi = (i / (rings+1)) * Math.PI/2; // cap at z>=0
            const z   = r * Math.cos(phi);
            const rho = r * Math.sin(phi);
            for (let j = 0; j < segs; j++) {
              const theta = (2*Math.PI * j)/segs;
              const x = center.x + rho * Math.cos(theta);
              const y = center.y + rho * Math.sin(theta);
              const p = new THREE.Vector3(x, y, z);
              if (p.z > eps) pts.push(p);
            }
          }
          return pts;
        }

        function computeDelaunayNeighbors(groupElements) {
          const orbit = [basepoint];
          const invs  = [];

          for (const g of groupElements) {
              const inv = g.inverse();
              if (!inv) continue;
              const p = imageOfBasepoint(inv);
              if (!isFinite(p.t) || p.t <= 0) continue;
              const v = new THREE.Vector3(p.u.re, p.u.im, p.t);
              orbit.push(v);
              invs.push({ u: p.u, t: p.t, v , g });
          }

          const neighborsMap = new Map();
          for (const item of invs) {
              const samples = samplePointsOnBisector(item.u, item.t, 160);
              let contributes = false;
              for (const s of samples) {
                  const d0 = hDist(basepoint, s);
                  const d1 = hDist(item.v, s);
                  if (Math.abs(d0 - d1) > 2e-3) continue; // near bisector
                  let ok = true;
                  for (let k = 1; k < orbit.length; k++) {
                      const dk = hDist(orbit[k], s);
                      if (dk < d0 - 2e-3) { ok = false; break; }
                  }
                  if (ok) { contributes = true; break; }
              }
              if (contributes) {
                  const key = keyFromVec(item.v); // global helper
                  if (!neighborsMap.has(key)) {
                      neighborsMap.set(key, { v: item.v, g: item.g });
                  }
              }
          }
          return Array.from(neighborsMap.values());
        }

        function drawDelaunayEdges(neighbors) {
          clearDelaunay();
          const material = new THREE.LineBasicMaterial({ linewidth: 2 });
          for (const v of neighbors) {
              const vv = (v && v.v) ? v.v : v;
              const geom = new THREE.BufferGeometry().setFromPoints([basepoint, vv]);
              const line = new THREE.Line(geom, material);
              delaunayGroup.add(line);
          }
        }

        function drawOrbitPoints(points) {
            clearOrbit();
            if (!points || points.length === 0) return;

            // Render orbit as copies of the yellow basepoint sphere
            const sphereGeom = new THREE.SphereGeometry(0.02, 16, 16);
            const sphereMat  = new THREE.MeshStandardMaterial({ color: 0xffebab });
            const mesh = new THREE.InstancedMesh(sphereGeom, sphereMat, points.length);
            const m = new THREE.Matrix4();
            for (let i = 0; i < points.length; i++) {
                m.makeTranslation(points[i].x, points[i].y, points[i].z);
                mesh.setMatrixAt(i, m);
            }
            mesh.instanceMatrix.needsUpdate = true;
            orbitGroup.add(mesh);
        }

        function generateAndDrawPolyhedron() {
            clearPolyhedron();
            clearDelaunay();
            clearOrbit();
            const showWalls = document.getElementById('toggleWalls')?.checked ?? true;
            const wordLength = parseInt(document.getElementById('Lparam').value) || 1;
            const groupElements = generateGroupElements(generators, wordLength);
            const neighbors = computeDelaunayNeighbors(groupElements);

            if (showWalls) {
                // Draw walls only for Delaunay neighbors
                neighbors.forEach((obj, i) => {
                    const g = obj.g;
                    const inv = g.inverse();
                    if (!inv) return;
                    const col = new THREE.Color().setHSL(i / Math.max(1, neighbors.length), 0.65, 0.58);
                    const material = new THREE.MeshStandardMaterial({
                        color: col,
                        transparent: true,
                        opacity: 0.35,
                        side: THREE.DoubleSide,
                        metalness: 0.2,
                        roughness: 0.6
                    });

                    const p = imageOfBasepoint(inv); // p = {u: Complex, t: number}
                    if (!isFinite(p.t) || p.t <= 0) return;
                    if (Math.abs(p.u.re) < 1e-12 && Math.abs(p.u.im) < 1e-12 && Math.abs(p.t - 1) < 1e-12) return;

                    const pVec = new THREE.Vector3(p.u.re, p.u.im, p.t);
                    drawBisector(pVec, undefined, material); // q defaults to basepoint (0,0,1)
                });
            }
            const showOrbit = document.getElementById('toggleOrbit')?.checked;
            if (showOrbit) {
                const orbitPts = computeOrbitPoints(groupElements);
                drawOrbitPoints(orbitPts);
                } else {
                clearOrbit();
            }
            const showDel = document.getElementById('toggleDelaunay')?.checked;
            if (showDel) {
                drawDelaunayEdges(neighbors);
            } else {
                clearDelaunay();
            }
        }
        

        // --- Init ---
        init();
        // Setup panel and defaults
        setupPanelUI();
        const delCb = document.getElementById('toggleDelaunay');
            if (delCb) delCb.addEventListener('change', () => {
            rebuildGeneratorsFromUI();
            generateAndDrawPolyhedron();
            });
        const orbCb = document.getElementById('toggleOrbit');
            if (orbCb) orbCb.addEventListener('change', () => {
            rebuildGeneratorsFromUI();
            generateAndDrawPolyhedron();
            });
        const wallsCb = document.getElementById('toggleWalls');
            if (wallsCb) wallsCb.addEventListener('change', () => {
            rebuildGeneratorsFromUI();
            generateAndDrawPolyhedron();
            });
        setExample(exampleLibrary[0]); // Modular group by default
        rebuildGeneratorsFromUI();
        typesetMath();
        // Sync initial word length
        document.getElementById('Lparam').value = 4;
        generateAndDrawPolyhedron();
 
    </script>
</body>
</html>