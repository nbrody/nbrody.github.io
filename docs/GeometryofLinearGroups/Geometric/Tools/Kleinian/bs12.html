<!DOCTYPE html>
<html lang="en">

<head>
    <title>Cayley Graph for BS(1,2)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            background-color: #111;
            color: #fff;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            color: #fff;
        }
    </style>
</head>

<body>
    <div id="info">Cayley Graph for BS(1,2) - Vertices and Edges</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.171.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.171.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;

        // --- Configuration ---
        const config = {
            zRange: [-2, 1],
            yRange: [-3, 3],
            xRange: [-3, 3],
            vertexColor: 0xffd700, // Gold
            edgeColor: 0xcccccc,   // Light gray
            backgroundColor: 0x111111,
            cameraTarget: new THREE.Vector3(0, 4, 2)
        };
        // ---------------------

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(config.backgroundColor);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 8, 12);
            camera.lookAt(config.cameraTarget);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.copy(config.cameraTarget);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);

            createCayleyGraph();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createCayleyGraph() {
            const vertexPositions = [];
            const edgePoints = [];
            const vertexMap = new Map();

            // Helper to convert (x,y,z) index to a 3D point
            function getPosition(x, y, z) {
                const zPow = Math.pow(2, z);
                return new THREE.Vector3(
                    zPow * x,
                    zPow + Math.pow(2, z + 1) * y,
                    zPow
                );
            }

            // Main loop to generate vertices and edges
            for (let z = config.zRange[0]; z <= config.zRange[1]; z++) {
                for (let y = config.yRange[0]; y <= config.yRange[1]; y++) {
                    for (let x = config.xRange[0]; x <= config.xRange[1]; x++) {

                        const p1 = getPosition(x, y, z);
                        vertexPositions.push(p1);

                        // --- Define 4 neighbors and draw edges ---

                        // Neighbor 1: action of 'a'
                        const p_a = getPosition(x + 1, y, z);
                        edgePoints.push(p1, p_a);

                        // Neighbor 2: action of 'a_inverse' (will be drawn by neighbor)

                        // Neighbor 3: action of 'b'
                        const y_mod_2 = ((y % 2) + 2) % 2;
                        const y_parent = Math.floor(y / 2);
                        const p_b = getPosition(2 * x + y_mod_2, y_parent, z + 1);
                        edgePoints.push(p1, p_b);

                        // Neighbor 4: action of 'b_inverse' (will be drawn by neighbor)
                    }
                }
            }

            // --- Create Vertex Meshes (Spheres) ---
            const vertexGeometry = new THREE.SphereGeometry(0.1, 16, 8);
            const vertexMaterial = new THREE.MeshBasicMaterial({ color: config.vertexColor });
            vertexPositions.forEach(pos => {
                const vertexSphere = new THREE.Mesh(vertexGeometry, vertexMaterial);
                vertexSphere.position.copy(pos);
                scene.add(vertexSphere);
            });

            // --- Create Edge Meshes (Lines) ---
            const edgeGeometry = new THREE.BufferGeometry().setFromPoints(edgePoints);
            const edgeMaterial = new THREE.LineBasicMaterial({ color: config.edgeColor });
            const edgeLines = new THREE.LineSegments(edgeGeometry, edgeMaterial);
            scene.add(edgeLines);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>