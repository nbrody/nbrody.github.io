<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Roots of SL(2,Z[t]) Matrices</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            --bg-color: #111827;
            --card-color: #1f2937;
            --text-color: #f3f4f6;
            --primary-color: #3b82f6;
            --border-color: #374151;
        }

        .math {
            font-family: 'Computer Modern', 'serif';
        }

        canvas {
            background: linear-gradient(145deg, #2a3a4a, #1a232f);
            cursor: move;
        }

        .root-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            pointer-events: none;
            display: none;
            white-space: nowrap;
        }
    </style>
</head>

<body class="bg-[--bg-color] text-[--text-color] min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">

        <!-- Controls and Information Panel -->
        <div
            class="bg-[--card-color] p-6 rounded-2xl shadow-lg border border-[--border-color] lg:col-span-1 flex flex-col h-full max-h-[90vh]">
            <div class="flex-shrink-0">
                <h1 class="text-2xl font-bold text-white mb-2">Matrix Root Explorer</h1>
                <p class="text-gray-400 mb-4">Visualizing the complex roots of the top-right entries of matrices
                    generated by <span class="math text-blue-400">S</span> and <span
                        class="math text-blue-400">T(t)</span>.</p>

                <div class="space-y-2 text-sm text-gray-300 mb-6">
                    <p><span class="math font-semibold text-blue-400">S</span> = <span class="math">[[0, -1], [1,
                            0]]</span> (Rotation)</p>
                    <p><span class="math font-semibold text-blue-400">T(t)</span> = <span class="math">[[1, t], [0,
                            1]]</span> (Shear)</p>
                </div>

                <div class="space-y-4">
                    <div>
                        <label for="depth" class="block text-sm font-medium text-gray-300 mb-1">Generation Depth</label>
                        <input type="number" id="depth" value="4" min="1" max="26"
                            class="w-full bg-gray-700 border border-[--border-color] rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-[--primary-color] focus:border-[--primary-color] transition">
                    </div>
                    <button id="generateBtn"
                        class="w-full bg-[--primary-color] text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600 transition-all shadow-md">
                        Generate and Plot Roots
                    </button>
                </div>
                <div id="status" class="mt-4 text-sm text-gray-400 h-5"></div>
            </div>

            <div class="mt-6 border-t border-[--border-color] pt-4 overflow-y-auto flex-grow">
                <h2 class="text-lg font-semibold mb-2">Polynomials & Roots</h2>
                <div id="polynomialsList" class="text-sm space-y-3 pr-2">
                    <p class="text-gray-500">Results will appear here...</p>
                </div>
            </div>
        </div>

        <!-- Canvas and Visualization -->
        <div
            class="bg-[--card-color] p-6 rounded-2xl shadow-lg border border-[--border-color] lg:col-span-2 flex flex-col items-center justify-center h-full max-h-[90vh]">
            <h2 class="text-xl font-bold text-white mb-4">Complex Plane Visualization</h2>
            <div class="w-full aspect-square relative">
                <canvas id="complexCanvas" class="w-full h-full rounded-lg border border-[--border-color]"></canvas>
                <div id="tooltip" class="root-tooltip"></div>
            </div>
        </div>

    </div>

    <script>
        // --- Polynomial Mathematics Library ---
        // A compact library for polynomial operations and root finding.
        // Based on public domain implementations.
        const Poly = {
            // Represents polynomial as an array of coefficients from highest to lowest degree.
            // e.g., t^2 + 1 is [1, 0, 1]

            // Basic operations
            add: (p1, p2) => {
                const d1 = p1.length - 1;
                const d2 = p2.length - 1;
                const dMax = Math.max(d1, d2);
                const result = new Array(dMax + 1).fill(0);
                for (let i = 0; i <= d1; i++) result[i + dMax - d1] += p1[i];
                for (let i = 0; i <= d2; i++) result[i + dMax - d2] += p2[i];
                return Poly.trim(result);
            },

            multiply: (p1, p2) => {
                if (p1.length === 1 && p1[0] === 0) return [0];
                if (p2.length === 1 && p2[0] === 0) return [0];
                const d1 = p1.length - 1;
                const d2 = p2.length - 1;
                const result = new Array(d1 + d2 + 1).fill(0);
                for (let i = 0; i <= d1; i++) {
                    for (let j = 0; j <= d2; j++) {
                        result[i + j] += p1[i] * p2[j];
                    }
                }
                return Poly.trim(result);
            },

            trim: (p) => {
                let i = 0;
                while (i < p.length - 1 && p[i] === 0) i++;
                return p.slice(i);
            },

            toString: (p) => {
                if (p.length === 0 || (p.length === 1 && p[0] === 0)) return "0";
                const d = p.length - 1;
                let s = "";
                for (let i = 0; i <= d; i++) {
                    const coeff = p[i];
                    if (coeff === 0) continue;
                    const power = d - i;

                    if (i > 0 && coeff > 0) s += " + ";
                    else if (i > 0 && coeff < 0) s += " - ";
                    else if (coeff < 0) s += "-";


                    const absCoeff = Math.abs(coeff);
                    if (absCoeff !== 1 || power === 0) s += absCoeff;

                    if (power > 0) s += "t";
                    if (power > 1) s += "^" + power;
                }
                return s;
            },

            // Durand-Kerner method for finding complex roots
            findRoots: (p_in) => {
                let p = [...p_in];
                const degree = p.length - 1;
                if (degree < 1) return [];

                // Normalize (make monic)
                const leadCoeff = p[0];
                if (leadCoeff !== 1) {
                    p = p.map(c => c / leadCoeff);
                }

                if (degree === 1) return [{ re: -p[1], im: 0 }];
                if (degree === 2) { // Quadratic formula
                    const [a, b, c] = p;
                    const discriminant = b * b - 4 * a * c;
                    if (discriminant >= 0) {
                        return [
                            { re: (-b + Math.sqrt(discriminant)) / (2 * a), im: 0 },
                            { re: (-b - Math.sqrt(discriminant)) / (2 * a), im: 0 }
                        ];
                    } else {
                        const sqrtDisc = Math.sqrt(-discriminant);
                        return [
                            { re: -b / (2 * a), im: sqrtDisc / (2 * a) },
                            { re: -b / (2 * a), im: -sqrtDisc / (2 * a) }
                        ];
                    }
                }

                // Initial guess for roots
                let roots = [];
                let r = { re: 0.4, im: 0.9 };
                for (let i = 0; i < degree; i++) {
                    roots.push({
                        re: Math.pow(r.re, i) * (i % 2 === 0 ? 1 : -1),
                        im: Math.pow(r.im, i) * (i % 4 < 2 ? 1 : -1)
                    });
                }

                const MAX_ITER = 100;
                const TOLERANCE = 1e-9;

                for (let iter = 0; iter < MAX_ITER; iter++) {
                    let maxChange = 0;
                    let newRoots = roots.map(root => ({ ...root }));

                    for (let i = 0; i < degree; i++) {
                        let p_val = { re: p[0], im: 0 };
                        for (let k = 1; k <= degree; k++) {
                            p_val = {
                                re: p_val.re * roots[i].re - p_val.im * roots[i].im + p[k],
                                im: p_val.re * roots[i].im + p_val.im * roots[i].re
                            };
                        }

                        let denominator = { re: 1, im: 0 };
                        for (let j = 0; j < degree; j++) {
                            if (i === j) continue;
                            const diff = { re: roots[i].re - roots[j].re, im: roots[i].im - roots[j].im };
                            denominator = {
                                re: denominator.re * diff.re - denominator.im * diff.im,
                                im: denominator.re * diff.im + denominator.im * diff.re
                            };
                        }

                        const den_mag_sq = denominator.re * denominator.re + denominator.im * denominator.im;
                        if (den_mag_sq === 0) continue;
                        const correction = {
                            re: (p_val.re * denominator.re + p_val.im * denominator.im) / den_mag_sq,
                            im: (p_val.im * denominator.re - p_val.re * denominator.im) / den_mag_sq
                        };

                        newRoots[i].re -= correction.re;
                        newRoots[i].im -= correction.im;

                        const change = correction.re * correction.re + correction.im * correction.im;
                        if (change > maxChange) maxChange = change;
                    }
                    roots = newRoots;
                    if (Math.sqrt(maxChange) < TOLERANCE) break;
                }
                return roots;
            }
        };

        // --- Matrix Generation and Main App Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            const generateBtn = document.getElementById('generateBtn');
            const depthInput = document.getElementById('depth');
            const statusDiv = document.getElementById('status');
            const polynomialsListDiv = document.getElementById('polynomialsList');
            const canvas = document.getElementById('complexCanvas');
            const tooltip = document.getElementById('tooltip');
            const ctx = canvas.getContext('2d');

            let roots = [];
            let transform = { scale: 100, x: 0, y: 0 };
            let isDragging = false;
            let lastMousePos = { x: 0, y: 0 };

            // Base matrices represented by their polynomial entries
            const ID = [[[1], [0]], [[0], [1]]];
            const S = [[[0], [-1]], [[1], [0]]];
            const S_INV = [[[0], [1]], [[-1], [0]]];
            const T = [[[1], [1, 0]], [[0], [1]]]; // t is [1, 0]
            const T_INV = [[[1], [-1, 0]], [[0], [1]]];

            const generators = [S, T, S_INV, T_INV];

            const matrixToString = (m) => JSON.stringify(m);

            const multiplyMatrices = (m1, m2) => {
                const a = m1[0][0], b = m1[0][1], c = m1[1][0], d = m1[1][1];
                const e = m2[0][0], f = m2[0][1], g = m2[1][0], h = m2[1][1];
                // ae + bg, af + bh
                // ce + dg, cf + dh
                return [
                    [Poly.add(Poly.multiply(a, e), Poly.multiply(b, g)), Poly.add(Poly.multiply(a, f), Poly.multiply(b, h))],
                    [Poly.add(Poly.multiply(c, e), Poly.multiply(d, g)), Poly.add(Poly.multiply(c, f), Poly.multiply(d, h))]
                ];
            };

            const generateMatrices = (depth) => {
                let currentGen = new Set([matrixToString(ID)]);
                let allMatrices = new Set(currentGen);

                for (let d = 0; d < depth; d++) {
                    statusDiv.textContent = `Generating depth ${d + 1}/${depth}...`;
                    let nextGen = new Set();
                    for (const mStr of currentGen) {
                        const m = JSON.parse(mStr);
                        for (const gen of generators) {
                            const product = multiplyMatrices(m, gen);
                            const productStr = matrixToString(product);
                            if (!allMatrices.has(productStr)) {
                                nextGen.add(productStr);
                                allMatrices.add(productStr);
                            }
                        }
                    }
                    if (nextGen.size === 0) break; // No new matrices generated
                    currentGen = nextGen;
                }
                return [...allMatrices].map(mStr => JSON.parse(mStr));
            };

            const run = async () => {
                generateBtn.disabled = true;
                generateBtn.textContent = "Generating...";
                statusDiv.textContent = 'Starting generation...';
                polynomialsListDiv.innerHTML = '<p class="text-gray-500">Calculating...</p>';

                // Use a timeout to allow UI to update before heavy computation
                await new Promise(resolve => setTimeout(resolve, 50));

                const depth = parseInt(depthInput.value);
                const matrices = generateMatrices(depth);

                statusDiv.textContent = `Found ${matrices.length} matrices. Extracting polynomials...`;
                await new Promise(resolve => setTimeout(resolve, 50));

                const polyMap = new Map();
                matrices.forEach(m => {
                    const poly = m[0][1]; // Top-right entry
                    const polyStr = Poly.toString(poly);
                    if (!polyMap.has(polyStr)) {
                        polyMap.set(polyStr, poly);
                    }
                });

                statusDiv.textContent = `Found ${polyMap.size} unique polynomials. Finding roots...`;
                await new Promise(resolve => setTimeout(resolve, 50));

                const allRoots = [];
                const polyData = [];
                for (const [polyStr, poly] of polyMap.entries()) {
                    if (poly.length <= 1) continue; // Skip constant polynomials
                    const polyRoots = Poly.findRoots(poly);
                    polyData.push({ str: polyStr, roots: polyRoots });
                    allRoots.push(...polyRoots);
                }

                roots = allRoots;
                displayPolynomials(polyData);
                autoZoom();
                draw();

                statusDiv.textContent = `Done. Found ${roots.length} roots from ${polyMap.size} polynomials.`;
                generateBtn.disabled = false;
                generateBtn.textContent = "Generate and Plot Roots";
            };

            generateBtn.addEventListener('click', run);

            const displayPolynomials = (polyData) => {
                polyData.sort((a, b) => (a.str.length - b.str.length) || a.str.localeCompare(b.str));
                polynomialsListDiv.innerHTML = polyData.map(p => {
                    const rootsStr = p.roots.map(r => {
                        const re = r.re.toFixed(3);
                        const im = Math.abs(r.im).toFixed(3);
                        if (Math.abs(r.im) < 1e-6) return `<span>${re}</span>`;
                        return `<span>${re} ${r.im > 0 ? '+' : '-'} ${im}i</span>`;
                    }).join(', ');
                    return `<div class="p-2 bg-gray-800 rounded-md">
                                <p class="font-mono text-blue-300">${p.str}</p>
                                <p class="text-xs text-gray-400 break-words">${rootsStr}</p>
                            </div>`;
                }).join('');
            };

            // --- Canvas Drawing and Interaction ---
            const resizeCanvas = () => {
                const size = canvas.parentElement.clientWidth;
                canvas.width = size * window.devicePixelRatio;
                canvas.height = size * window.devicePixelRatio;
                canvas.style.width = `${size}px`;
                canvas.style.height = `${size}px`;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                draw();
            };

            const draw = () => {
                const w = canvas.clientWidth;
                const h = canvas.clientHeight;
                ctx.clearRect(0, 0, w, h);

                const centerX = w / 2 + transform.x;
                const centerY = h / 2 - transform.y;

                // Draw axes
                ctx.strokeStyle = '#4a5568';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(w, centerY);
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, h);
                ctx.stroke();

                // Draw unit circle
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, transform.scale, 0, 2 * Math.PI);
                ctx.stroke();

                // Draw roots
                ctx.fillStyle = 'rgba(59, 130, 246, 0.8)';
                roots.forEach(root => {
                    const x = centerX + root.re * transform.scale;
                    const y = centerY - root.im * transform.scale;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            };

            const autoZoom = () => {
                if (roots.length === 0) {
                    transform = { scale: canvas.clientWidth / 4, x: 0, y: 0 };
                    return;
                }
                let maxR = 0;
                roots.forEach(r => {
                    const mag = Math.sqrt(r.re * r.re + r.im * r.im);
                    if (mag > maxR) maxR = mag;
                });
                transform.scale = canvas.clientWidth / (2.2 * Math.max(1, maxR));
                transform.x = 0;
                transform.y = 0;
            };

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMousePos = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'move';
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'move';
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - lastMousePos.x;
                    const dy = e.clientY - lastMousePos.y;
                    transform.x += dx;
                    transform.y -= dy; // Invert Y for canvas coordinates
                    lastMousePos = { x: e.clientX, y: e.clientY };
                    draw();
                }

                // Tooltip logic
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const centerX = canvas.clientWidth / 2 + transform.x;
                const centerY = canvas.clientHeight / 2 - transform.y;

                let foundRoot = null;
                for (const root of roots) {
                    const x = centerX + root.re * transform.scale;
                    const y = centerY - root.im * transform.scale;
                    const distSq = (mouseX - x) ** 2 + (mouseY - y) ** 2;
                    if (distSq < 16) { // 4px radius
                        foundRoot = root;
                        break;
                    }
                }

                if (foundRoot) {
                    const re = foundRoot.re.toFixed(4);
                    const im_abs = Math.abs(foundRoot.im).toFixed(4);
                    tooltip.textContent = `${re} ${foundRoot.im >= 0 ? '+' : '-'} ${im_abs}i`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                } else {
                    tooltip.style.display = 'none';
                }
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

                // World coordinates of mouse before zoom
                const worldX = (mouseX - (canvas.clientWidth / 2 + transform.x)) / transform.scale;
                const worldY = (mouseY - (canvas.clientHeight / 2 - transform.y)) / -transform.scale;

                transform.scale *= zoomFactor;

                // World coordinates of mouse after zoom
                const newWorldX = (mouseX - (canvas.clientWidth / 2 + transform.x)) / transform.scale;
                const newWorldY = (mouseY - (canvas.clientHeight / 2 - transform.y)) / -transform.scale;

                // Adjust pan to keep mouse position fixed in world space
                transform.x += (newWorldX - worldX) * transform.scale;
                transform.y -= (newWorldY - worldY) * transform.scale;

                draw();
            });

            window.addEventListener('resize', resizeCanvas);

            // Initial setup
            resizeCanvas();
            run(); // Run with default depth on page load
        });

    </script>
</body>

</html>