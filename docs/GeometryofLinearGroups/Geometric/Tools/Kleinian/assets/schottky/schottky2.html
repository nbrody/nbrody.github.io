<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kleinian Group Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div id="info">
        Click and drag to rotate.
    </div>

    <script>
        // --- MAIN SCRIPT ---

        // Global variables
        let gl;
        let program;
        let resolutionLocation;
        let timeLocation;
        let mouseLocation;
        let sphereLocation;

        // The spheres are defined by a vec4: (center.x, center.y, center.z, radius)
        const spheres = [
            1.0, 1.0, 1.0, 0.8,
            -1.0, -1.0, 1.0, 0.8,
            -1.0, 1.0, -1.0, 0.8,
            1.0, -1.0, -1.0, 0.8
        ];

        // Mouse control variables
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let rotationX = 1.5;
        let rotationY = 0.5;

        function main() {
            const canvas = document.getElementById('glcanvas');
            gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL not supported!');
                return;
            }

            // --- VERTEX SHADER (Embedded) ---
            const vsSource = `
        attribute vec4 aVertexPosition;
        void main() {
            gl_Position = aVertexPosition;
        }
    `;

            // --- FRAGMENT SHADER (Embedded) ---
            const fsSource = `
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec2 u_mouse;
        uniform vec4 u_spheres[4];

        const int MAX_ITER = 12;
        const int NUM_SPHERES = 4;
        const float EPSILON = 0.001;
        const float MAX_DIST = 100.0;

        struct HitInfo {
            float dist;
            vec3 color;
            vec3 normal;
        };

        vec3 invert(vec3 p, vec4 s) {
            vec3 v = p - s.xyz;
            float r2 = s.w * s.w;
            float d2 = dot(v, v);
            return s.xyz + v * r2 / d2;
        }

        float intersectSphere(vec3 rayOrigin, vec3 rayDir, vec4 sphere) {
            vec3 oc = rayOrigin - sphere.xyz;
            float b = dot(oc, rayDir);
            float c = dot(oc, oc) - sphere.w * sphere.w;
            float h = b*b - c;
            if (h < 0.0) return -1.0;
            return -b - sqrt(h);
        }

        HitInfo map(vec3 ro, vec3 rd) {
            HitInfo result;
            result.dist = MAX_DIST;
            float scale = 1.0;

            for (int i = 0; i < MAX_ITER; i++) {
                int closestSphereIndex = -1;
                float maxRadiusSqOverDistSq = 0.0;
                
                for (int j = 0; j < NUM_SPHERES; j++) {
                    float r2 = u_spheres[j].w * u_spheres[j].w;
                    float d2 = dot(ro - u_spheres[j].xyz, ro - u_spheres[j].xyz);
                    float ratio = r2 / d2;
                    if (ratio > maxRadiusSqOverDistSq) {
                        maxRadiusSqOverDistSq = ratio;
                        closestSphereIndex = j;
                    }
                }

                if (closestSphereIndex == -1) break;

                vec4 s;
                if (closestSphereIndex == 0) s = u_spheres[0];
                else if (closestSphereIndex == 1) s = u_spheres[1];
                else if (closestSphereIndex == 2) s = u_spheres[2];
                else if (closestSphereIndex == 3) s = u_spheres[3];
                
                float r2 = s.w * s.w;
                float d2 = dot(ro - s.xyz, ro - s.xyz);
                float newScale = r2 / d2;
                
                vec3 ro_old = ro;
                ro = invert(ro_old, s);
                rd = normalize(invert(ro_old + rd, s) - ro);

                scale *= newScale;
            }

            float min_dist = MAX_DIST;
            vec3 hit_color = vec3(0.0);
            int hit_sphere_idx = -1;

            for (int j = 0; j < NUM_SPHERES; j++) {
                float d = intersectSphere(ro, rd, u_spheres[j]);
                if (d > EPSILON && d < min_dist) {
                    min_dist = d;
                    hit_sphere_idx = j;
                }
            }

            if (hit_sphere_idx > -1) {
                result.dist = min_dist * scale;
                
                if(hit_sphere_idx == 0) hit_color = vec3(0.9, 0.2, 0.2);
                else if(hit_sphere_idx == 1) hit_color = vec3(0.2, 0.9, 0.2);
                else if(hit_sphere_idx == 2) hit_color = vec3(0.2, 0.2, 0.9);
                else hit_color = vec3(0.9, 0.9, 0.2);
                result.color = hit_color;

                vec3 hit_pos_local = ro + rd * min_dist;
                vec3 normal_local;

                if (hit_sphere_idx == 0) normal_local = normalize(hit_pos_local - u_spheres[0].xyz);
                else if (hit_sphere_idx == 1) normal_local = normalize(hit_pos_local - u_spheres[1].xyz);
                else if (hit_sphere_idx == 2) normal_local = normalize(hit_pos_local - u_spheres[2].xyz);
                else normal_local = normalize(hit_pos_local - u_spheres[3].xyz);

                result.normal = -reflect(rd, normal_local);
            }

            return result;
        }

        mat3 setCamera(vec3 ro, vec3 ta, float cr) {
            vec3 cw = normalize(ta-ro);
            vec3 cp = vec3(sin(cr), cos(cr), 0.0);
            vec3 cu = normalize(cross(cw,cp));
            vec3 cv = normalize(cross(cu,cw));
            return mat3(cu, cv, cw);
        }

        void main() {
            vec2 uv = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

            float camDist = 4.0;
            vec3 ro = vec3(camDist * cos(u_mouse.x) * sin(u_mouse.y), camDist * cos(u_mouse.y), camDist * sin(u_mouse.x) * sin(u_mouse.y));
            vec3 ta = vec3(0.0, 0.0, 0.0);

            mat3 cam = setCamera(ro, ta, 0.0);
            
            vec3 rd = cam * normalize(vec3(uv, 1.0)); 

            HitInfo hit = map(ro, rd);
            vec3 col = vec3(0.0);

            if (hit.dist < MAX_DIST) {
                vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                vec3 normal = normalize(hit.normal);
                
                float diffuse = max(0.0, dot(normal, lightDir));
                col = hit.color * (diffuse * 0.8 + 0.2);
            }

            gl_FragColor = vec4(col, 1.0);
        }
    `;

            const shaderProgram = initShaderProgram(vsSource, fsSource);
            program = shaderProgram;

            resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            timeLocation = gl.getUniformLocation(program, 'u_time');
            mouseLocation = gl.getUniformLocation(program, 'u_mouse');
            sphereLocation = gl.getUniformLocation(program, 'u_spheres');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, 1, 1, 1, -1, -1, 1, -1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const positionAttributeLocation = gl.getAttribLocation(program, 'aVertexPosition');
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            canvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            document.addEventListener('mouseup', () => { isMouseDown = false; });
            document.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                rotationY += deltaX * 0.005;
                rotationX += deltaY * 0.005;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            requestAnimationFrame(render);
        }

        function render(time) {
            time *= 0.001;

            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(timeLocation, time);
            gl.uniform2f(mouseLocation, rotationY, rotationX);

            gl.uniform4fv(sphereLocation, spheres);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        // --- WebGL Helper Functions ---
        function initShaderProgram(vsSource, fsSource) {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        // Start the application
        main();

    </script>
</body>

</html>