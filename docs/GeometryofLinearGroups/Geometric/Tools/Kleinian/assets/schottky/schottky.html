<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kleinian Group Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div id="info">
        Click and drag to rotate. Scroll to zoom. Press +/- to zoom.
    </div>

    <script>
        // --- MAIN SCRIPT ---

        // Global variables
        let gl;
        let program;
        let resolutionLocation;
        let timeLocation;
        let mouseLocation;
        let sphereLocation;
        let zoomLocation;
        let zoom = 4.0;

        // The spheres are defined by a vec4: (center.x, center.y, center.z, radius)
        const spheres = [
            2.5, 2.5, 2.5, 0.6,
            -2.5, -2.5, 2.5, 0.6,
            -2.5, 2.5, -2.5, 0.6,
            2.5, -2.5, -2.5, 0.6
        ];

        // Mouse control variables
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let rotationX = 1.5;
        let rotationY = 0.5;

        function main() {
            const canvas = document.getElementById('glcanvas');
            gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL not supported!');
                return;
            }

            // --- VERTEX SHADER (Embedded) ---
            const vsSource = `
        attribute vec4 aVertexPosition;
        void main() {
            gl_Position = aVertexPosition;
        }
    `;

            // --- FRAGMENT SHADER (Embedded) ---
            const fsSource = `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
        #else
        precision mediump float;
        #endif
        precision mediump int;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec2 u_mouse;
        uniform float u_zoom;
        uniform vec4 u_spheres[4];

        // Helper to avoid dynamic indexing of u_spheres in WebGL1/GLSL ES 1.00
        vec4 sphereAt(int i){
            if(i==0) return u_spheres[0];
            if(i==1) return u_spheres[1];
            if(i==2) return u_spheres[2];
            return u_spheres[3];
        }

        const int MAX_ITER = 12;
        const int NUM_SPHERES = 4;
        const float EPSILON = 0.001;
        const float MAX_DIST = 100.0;

        struct HitInfo {
            float dist;
            vec3 color;
            vec3 normal;
        };

        vec3 invert(vec3 p, vec4 s) {
            vec3 v = p - s.xyz;
            float r2 = s.w * s.w;
            float d2 = dot(v, v);
            return s.xyz + v * r2 / d2;
        }

        float intersectSphere(vec3 rayOrigin, vec3 rayDir, vec4 sphere) {
            vec3 oc = rayOrigin - sphere.xyz;
            float b = dot(oc, rayDir);
            float c = dot(oc, oc) - sphere.w * sphere.w;
            float h = b*b - c;
            if (h < 0.0) return -1.0;
            return -b - sqrt(h);
        }

        HitInfo map(vec3 ro, vec3 rd) {
            HitInfo result;
            result.dist = MAX_DIST;
            float scale = 1.0;

            // Track the last inversion index so we can color by generator
            int lastIdx = -1;

            // Perform sphere inversions; choose sphere based on a point along the ray
            for (int i = 0; i < MAX_ITER; i++) {
                // Sample a point one unit along the current ray; depends on pixel (rd)
                vec3 p = ro + rd;

                int closestSphereIndex = 0;
                float bestRatio = -1.0;

                // Pick the sphere with largest r^2 / |p - c|^2 at this pixel
                for (int j = 0; j < NUM_SPHERES; j++) {
                    vec4 sj = sphereAt(j);
                    float r2_j = sj.w * sj.w;
                    float d2_j = dot(p - sj.xyz, p - sj.xyz);
                    float ratio = r2_j / d2_j;
                    if (ratio > bestRatio) {
                        bestRatio = ratio;
                        closestSphereIndex = j;
                    }
                }

                lastIdx = closestSphereIndex;
                vec4 s = sphereAt(closestSphereIndex);

                // Update scale using p (the actually sampled point)
                float r2 = s.w * s.w;
                float d2 = dot(p - s.xyz, p - s.xyz);
                float newScale = r2 / d2;

                // Invert origin and a point along the ray, then rebuild rd
                vec3 ro_old = ro;
                vec3 q_old  = ro + rd;    // a second point defining the ray

                ro = invert(ro_old, s);
                vec3 q = invert(q_old,  s);
                rd = normalize(q - ro);

                scale *= newScale;
            }

            // After inversions, do a real intersection test for lighting
            float min_dist = MAX_DIST;
            int hit_sphere_idx = -1;

            for (int j = 0; j < NUM_SPHERES; j++) {
                float d = intersectSphere(ro, rd, sphereAt(j));
                if (d > EPSILON && d < min_dist) {
                    min_dist = d;
                    hit_sphere_idx = j;
                }
            }

            if (hit_sphere_idx > -1) {
                result.dist = min_dist * scale;

                // Color by the last inversion index, not by the intersected sphere
                vec3 hit_color;
                if(lastIdx == 0)      hit_color = vec3(0.9, 0.2, 0.2);
                else if(lastIdx == 1) hit_color = vec3(0.2, 0.9, 0.2);
                else if(lastIdx == 2) hit_color = vec3(0.2, 0.2, 0.9);
                else                  hit_color = vec3(0.9, 0.9, 0.2);
                result.color = hit_color;

                // Normal from the actually intersected sphere for decent lighting
                vec3 hit_pos_local = ro + rd * min_dist;
                vec4 hs = sphereAt(hit_sphere_idx);
                vec3 normal_local = normalize(hit_pos_local - hs.xyz);

                // Reflect for a slightly crisper look
                result.normal = -reflect(rd, normal_local);
            }

            return result;
        }

        mat3 setCamera(vec3 ro, vec3 ta, float cr) {
            vec3 cw = normalize(ta-ro);
            vec3 cp = vec3(sin(cr), cos(cr), 0.0);
            vec3 cu = normalize(cross(cw,cp));
            vec3 cv = normalize(cross(cu,cw));
            return mat3(cu, cv, cw);
        }

        void main() {
            vec2 uv = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

            float camDist = u_zoom;
            vec3 ro = vec3(camDist * cos(u_mouse.x) * sin(u_mouse.y), camDist * cos(u_mouse.y), camDist * sin(u_mouse.x) * sin(u_mouse.y));
            vec3 ta = vec3(0.0, 0.0, 0.0);

            mat3 cam = setCamera(ro, ta, 0.0);
            
            vec3 rd = cam * normalize(vec3(uv, 1.0)); 

            HitInfo hit = map(ro, rd);
            vec3 col = vec3(0.0);

            if (hit.dist < MAX_DIST) {
                vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                vec3 normal = normalize(hit.normal);
                
                float diffuse = max(0.0, dot(normal, lightDir));
                col = hit.color * (diffuse * 0.8 + 0.2);
            }

            gl_FragColor = vec4(col, 1.0);
        }
    `;

            const shaderProgram = initShaderProgram(vsSource, fsSource);
            program = shaderProgram;

            resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            timeLocation = gl.getUniformLocation(program, 'u_time');
            mouseLocation = gl.getUniformLocation(program, 'u_mouse');
            sphereLocation = gl.getUniformLocation(program, 'u_spheres');
            zoomLocation = gl.getUniformLocation(program, 'u_zoom');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, 1, 1, 1, -1, -1, 1, -1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const positionAttributeLocation = gl.getAttribLocation(program, 'aVertexPosition');
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            canvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            document.addEventListener('mouseup', () => { isMouseDown = false; });
            document.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                rotationY += deltaX * 0.005;
                rotationX += deltaY * 0.005;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            // Zoom with wheel/trackpad
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                // Use an exponential scale for smooth zooming
                const factor = Math.exp(e.deltaY * 0.001);
                zoom *= factor;
                // Clamp zoom range
                zoom = Math.max(0.5, Math.min(50.0, zoom));
            }, { passive: false });

            // Zoom with keyboard +/- (and =/_ variants)
            window.addEventListener('keydown', (e) => {
                if (e.key === '+' || e.key === '=') {
                    zoom /= 1.1;
                } else if (e.key === '-' || e.key === '_') {
                    zoom *= 1.1;
                }
                zoom = Math.max(0.5, Math.min(50.0, zoom));
            });

            requestAnimationFrame(render);
        }

        function render(time) {
            time *= 0.001;

            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(timeLocation, time);
            gl.uniform2f(mouseLocation, rotationY, rotationX);
            gl.uniform1f(zoomLocation, zoom);

            gl.uniform4fv(sphereLocation, spheres);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        // --- WebGL Helper Functions ---
        function initShaderProgram(vsSource, fsSource) {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
            if (!vertexShader || !fragmentShader) {
                console.error('Shader creation failed. vertexShader:', !!vertexShader, 'fragmentShader:', !!fragmentShader);
                return null;
            }
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const log = gl.getShaderInfoLog(shader) || '(no log)';
                console.error('\n==== SHADER COMPILE ERROR ====' );
                console.error('Type:', type === gl.VERTEX_SHADER ? 'VERTEX' : 'FRAGMENT');
                console.error('Info Log:', log);
                // Print the shader source with line numbers for easier debugging
                const numbered = source.split('\n').map((l, i) => `${(i+1).toString().padStart(4,' ')}: ${l}`).join('\n');
                console.error('Source with line numbers:\n' + numbered);
                alert('An error occurred compiling the ' + (type === gl.VERTEX_SHADER ? 'VERTEX' : 'FRAGMENT') + ' shader. Check the console for details.');
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        // Start the application
        main();

    </script>
</body>

</html>