<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farey Polynomial Roots</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        .controls label {
            margin-right: 10px;
            font-weight: bold;
        }
        .controls input {
            width: 60px;
            padding: 5px;
            font-size: 16px;
        }
        .controls button {
            padding: 8px 20px;
            margin-left: 10px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        .controls button:hover {
            background: #764ba2;
        }
        canvas {
            border: 2px solid #ddd;
            display: block;
            margin: 20px auto;
            background: white;
            cursor: crosshair;
        }
        #info {
            min-height: 60px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin-top: 20px;
            text-align: center;
            font-size: 14px;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive Farey Polynomial Root Visualization</h1>
        <div class="controls">
            <label for="maxDenom">Max Denominator:</label>
            <input type="number" id="maxDenom" value="20" min="2" max="50">
            <button onclick="regenerate()">Regenerate</button>
        </div>
        <canvas id="canvas" width="600" height="600"></canvas>
        <div id="info">Hover over a root to see its polynomial P(p/q) = Q(p/q) + 2</div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="polyCount">0</div>
                <div class="stat-label">Polynomials</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="rootCount">0</div>
                <div class="stat-label">Total Roots</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="hoveredRoots">0</div>
                <div class="stat-label">Highlighted Roots</div>
            </div>
        </div>
    </div>

    <script>
        // Polynomial class for operations
        class Polynomial {
            constructor(coeffs) {
                // coeffs[i] is coefficient of x^i
                this.coeffs = coeffs.slice();
                while (this.coeffs.length > 1 && Math.abs(this.coeffs[this.coeffs.length - 1]) < 1e-10) {
                    this.coeffs.pop();
                }
            }

            static fromConstant(c) {
                return new Polynomial([c]);
            }

            add(other) {
                const maxLen = Math.max(this.coeffs.length, other.coeffs.length);
                const result = new Array(maxLen).fill(0);
                for (let i = 0; i < this.coeffs.length; i++) {
                    result[i] += this.coeffs[i];
                }
                for (let i = 0; i < other.coeffs.length; i++) {
                    result[i] += other.coeffs[i];
                }
                return new Polynomial(result);
            }

            subtract(other) {
                const maxLen = Math.max(this.coeffs.length, other.coeffs.length);
                const result = new Array(maxLen).fill(0);
                for (let i = 0; i < this.coeffs.length; i++) {
                    result[i] += this.coeffs[i];
                }
                for (let i = 0; i < other.coeffs.length; i++) {
                    result[i] -= other.coeffs[i];
                }
                return new Polynomial(result);
            }

            multiply(other) {
                const result = new Array(this.coeffs.length + other.coeffs.length - 1).fill(0);
                for (let i = 0; i < this.coeffs.length; i++) {
                    for (let j = 0; j < other.coeffs.length; j++) {
                        result[i + j] += this.coeffs[i] * other.coeffs[j];
                    }
                }
                return new Polynomial(result);
            }

            evaluate(x) {
                let result = 0;
                let power = 1;
                for (let i = 0; i < this.coeffs.length; i++) {
                    result += this.coeffs[i] * power;
                    power *= x;
                }
                return result;
            }

            derivative() {
                if (this.coeffs.length <= 1) return new Polynomial([0]);
                const result = [];
                for (let i = 1; i < this.coeffs.length; i++) {
                    result.push(i * this.coeffs[i]);
                }
                return new Polynomial(result);
            }

            toString() {
                const terms = [];
                for (let i = this.coeffs.length - 1; i >= 0; i--) {
                    if (Math.abs(this.coeffs[i]) > 1e-10) {
                        let term = '';
                        const coeff = this.coeffs[i];
                        if (i === 0) {
                            term = coeff.toFixed(0);
                        } else if (i === 1) {
                            term = `${coeff.toFixed(0)}x`;
                        } else if (coeff == 1) {   
                            term = `x^${i}`;
                        } else if (coeff == -1) {
                            term = `-x^${i}`;
                        } else {
                            term = `${coeff.toFixed(0)}x^${i}`;
                        }
                        if (coeff > 0 && terms.length > 0) {
                            term = '+' + term;
                        }
                        terms.push(term);
                    }
                }
                return terms.length > 0 ? terms.join('') : '0';
            }
        }

        // GCD for fraction reduction
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        // Check if two fractions are Farey neighbors
        function areFareyNeighbors(a, c, b, d) {
            return Math.abs(b * c - a * d) === 1;
        }

        // Generate all reduced fractions with denominator up to maxDenom
        function generateFractions(maxDenom) {
            const fractions = [];
            for (let q = 1; q <= maxDenom; q++) {
                for (let p = 0; p <= q; p++) {
                    if (gcd(p, q) === 1) {
                        fractions.push({p, q});
                    }
                }
            }
            fractions.sort((f1, f2) => f1.p * f2.q - f2.p * f1.q);
            return fractions;
        }

        // Find roots of polynomial using Newton-Raphson with multiple initial guesses
        function findRoots(poly, numGuesses = 50) {
            const roots = [];
            const derivative = poly.derivative();
            const tolerance = 1e-3;
            const maxIter = 300;

            // Try different initial guesses
            for (let i = 0; i < numGuesses; i++) {
                // Initial guesses spread across complex plane
                const angle = (2 * Math.PI * i) / numGuesses;
                const radius = i;
                let x = {re: radius * Math.cos(angle), im: radius * Math.sin(angle)};
                
                // Newton-Raphson iteration
                let converged = false;
                for (let iter = 0; iter < maxIter; iter++) {
                    const f = evaluateComplex(poly, x);
                    const df = evaluateComplex(derivative, x);
                    
                    if (Math.abs(df.re) < 1e-12 && Math.abs(df.im) < 1e-12) break;
                    
                    const delta = divideComplex(f, df);
                    x = {re: x.re - delta.re, im: x.im - delta.im};
                    
                    if (Math.sqrt(delta.re * delta.re + delta.im * delta.im) < tolerance) {
                        converged = true;
                        break;
                    }
                }
                
                if (converged) {
                    // Check if this root is new
                    let isNew = true;
                    for (const root of roots) {
                        const dist = Math.sqrt(Math.pow(root.re - x.re, 2) + Math.pow(root.im - x.im, 2));
                        if (dist < 1e-6) {
                            isNew = false;
                            break;
                        }
                    }
                    if (isNew) {
                        roots.push(x);
                    }
                }
            }
            
            return roots;
        }

        function evaluateComplex(poly, z) {
            let result = {re: 0, im: 0};
            let power = {re: 1, im: 0};
            
            for (let i = 0; i < poly.coeffs.length; i++) {
                result.re += poly.coeffs[i] * power.re;
                result.im += poly.coeffs[i] * power.im;
                
                const newPower = {
                    re: power.re * z.re - power.im * z.im,
                    im: power.re * z.im + power.im * z.re
                };
                power = newPower;
            }
            
            return result;
        }

        function divideComplex(a, b) {
            const denom = b.re * b.re + b.im * b.im;
            return {
                re: (a.re * b.re + a.im * b.im) / denom,
                im: (a.im * b.re - a.re * b.im) / denom
            };
        }

        // Main computation
        let polynomials = {};
        let allRoots = [];
        let canvas, ctx;
        let hoveredPolynomial = null;

        function computePolynomials(maxDenom) {
            polynomials = {};
            allRoots = [];
            
            // Initial conditions
            polynomials['0/1'] = new Polynomial([2, 0, -1]); // 2 - x^2
            polynomials['1/1'] = new Polynomial([2, 0, 1]); // 2 + x^2
            polynomials['1/2'] = new Polynomial([2, 0, 0, 0, 1]); // 2 + x^4
            
            const fractions = generateFractions(maxDenom);
            
            // Keep applying the recursive rule until no new polynomials can be computed
            let changed = true;
            let iterations = 0;
            const maxIterations = 100;
            
            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                
                // Try to compute each unknown fraction using all possible Farey neighbor pairs
                for (const target of fractions) {
                    const targetKey = `${target.p}/${target.q}`;
                    
                    if (polynomials[targetKey]) continue; // Already computed
                    
                    // Find all ways to express target as mediant of Farey neighbors
                    for (let i = 0; i < fractions.length; i++) {
                        for (let j = i + 1; j < fractions.length; j++) {
                            const f1 = fractions[i];
                            const f2 = fractions[j];
                            
                            // Check if f1 and f2 are Farey neighbors
                            if (!areFareyNeighbors(f1.p, f1.q, f2.p, f2.q)) continue;
                            
                            // Check if target is the mediant of f1 and f2
                            const mediant = {
                                p: f1.p + f2.p,
                                q: f1.q + f2.q
                            };
                            const g = gcd(mediant.p, mediant.q);
                            mediant.p /= g;
                            mediant.q /= g;
                            
                            if (mediant.p !== target.p || mediant.q !== target.q) continue;
                            
                            // We found that target = (f1 + f2) in lowest terms
                            const leftKey = `${f1.p}/${f1.q}`;
                            const rightKey = `${f2.p}/${f2.q}`;
                            
                            // Compute the difference fraction (b-a)/(d-c)
                            const diff = {
                                p: Math.abs(f2.p - f1.p),
                                q: Math.abs(f2.q - f1.q)
                            };
                            if (diff.q === 0) continue; // Skip if denominator is 0
                            
                            const gDiff = gcd(diff.p, diff.q);
                            diff.p /= gDiff;
                            diff.q /= gDiff;
                            const diffKey = `${diff.p}/${diff.q}`;
                            
                            // Check if we have all required polynomials
                            if (polynomials[leftKey] && polynomials[rightKey] && polynomials[diffKey]) {
                                // Q((a+b)/(c+d)) = 8 - (Q(a/c)Q(b/d) + Q((b-a)/(d-c)))
                                const product = polynomials[leftKey].multiply(polynomials[rightKey]);
                                const sum = product.add(polynomials[diffKey]);
                                polynomials[targetKey] = Polynomial.fromConstant(8).subtract(sum);
                                changed = true;
                                break; // Found a way to compute this polynomial
                            }
                        }
                        if (polynomials[targetKey]) break; // Already computed
                    }
                }
            }
            
            // Compute roots for P(p/q) = Q(p/q) + 2
            for (const key in polynomials) {
                const P = polynomials[key].add(Polynomial.fromConstant(2));
                const roots = findRoots(P);
                
                for (const root of roots) {
                    allRoots.push({
                        x: root.re,
                        y: root.im,
                        polynomial: key,
                        P: P
                    });
                }
            }
            
            // Update stats
            document.getElementById('polyCount').textContent = Object.keys(polynomials).length;
            document.getElementById('rootCount').textContent = allRoots.length;
        }

        function drawPlot() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Find bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const root of allRoots) {
                minX = Math.min(minX, root.x);
                maxX = Math.max(maxX, root.x);
                minY = Math.min(minY, root.y);
                maxY = Math.max(maxY, root.y);
            }
            
            // Add padding
            const padX = (maxX - minX) * 0.1 || 1;
            const padY = (maxY - minY) * 0.1 || 1;
            minX -= padX;
            maxX += padX;
            minY -= padY;
            maxY += padY;
            
            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            
            // X-axis
            const y0 = canvas.height - (0 - minY) / (maxY - minY) * canvas.height;
            ctx.beginPath();
            ctx.moveTo(0, y0);
            ctx.lineTo(canvas.width, y0);
            ctx.stroke();
            
            // Y-axis
            const x0 = (0 - minX) / (maxX - minX) * canvas.width;
            ctx.beginPath();
            ctx.moveTo(x0, 0);
            ctx.lineTo(x0, canvas.height);
            ctx.stroke();
            
            // Draw roots
            let highlightedCount = 0;
            for (const root of allRoots) {
                const x = (root.x - minX) / (maxX - minX) * canvas.width;
                const y = canvas.height - (root.y - minY) / (maxY - minY) * canvas.height;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                
                if (hoveredPolynomial && root.polynomial === hoveredPolynomial) {
                    ctx.fillStyle = '#ff4444';
                    ctx.strokeStyle = '#aa0000';
                    ctx.lineWidth = 2;
                    highlightedCount++;
                } else {
                    ctx.fillStyle = '#4444ff';
                    ctx.strokeStyle = '#000088';
                    ctx.lineWidth = 1;
                }
                
                ctx.fill();
                ctx.stroke();
            }
            
            document.getElementById('hoveredRoots').textContent = highlightedCount;
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Find bounds for conversion
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const root of allRoots) {
                minX = Math.min(minX, root.x);
                maxX = Math.max(maxX, root.x);
                minY = Math.min(minY, root.y);
                maxY = Math.max(maxY, root.y);
            }
            const padX = (maxX - minX) * 0.1 || 1;
            const padY = (maxY - minY) * 0.1 || 1;
            minX -= padX;
            maxX += padX;
            minY -= padY;
            maxY += padY;
            
            // Find closest root
            let closestRoot = null;
            let minDist = 15; // pixels
            
            for (const root of allRoots) {
                const x = (root.x - minX) / (maxX - minX) * canvas.width;
                const y = canvas.height - (root.y - minY) / (maxY - minY) * canvas.height;
                const dist = Math.sqrt(Math.pow(x - mouseX, 2) + Math.pow(y - mouseY, 2));
                
                if (dist < minDist) {
                    minDist = dist;
                    closestRoot = root;
                }
            }
            
            if (closestRoot) {
                hoveredPolynomial = closestRoot.polynomial;
                const info = document.getElementById('info');
                info.innerHTML = `<strong>P(${closestRoot.polynomial})</strong> = ${closestRoot.P.toString()}<br>` +
                                `Root: ${closestRoot.x.toFixed(4)} ${closestRoot.y >= 0 ? '+' : ''}${closestRoot.y.toFixed(4)}i`;
            } else {
                hoveredPolynomial = null;
                document.getElementById('info').innerHTML = 'Hover over a root to see its polynomial P(p/q) = Q(p/q) + 2';
            }
            
            drawPlot();
        }

        function regenerate() {
            const maxDenom = parseInt(document.getElementById('maxDenom').value);
            computePolynomials(maxDenom);
            drawPlot();
        }

        // Initialize
        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', function() {
                hoveredPolynomial = null;
                document.getElementById('info').innerHTML = 'Hover over a root to see its polynomial P(p/q) = Q(p/q) + 2';
                drawPlot();
            });
            
            regenerate();
        };
    </script>
</body>
</html>