<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperbolic Polyhedron Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
            color: #d1d5db; /* gray-300 */
        }
        #container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .info-panel a {
            color: #60a5fa; /* blue-400 */
            text-decoration: underline;
        }
        /* Gutter boxes for vector lines */
        #vector-gutter {
          /* allow clicking on gutter boxes */
            pointer-events: auto;
        }
        #vector-gutter .box {
          width: 12px;
          height: 24px; /* match textarea line-height (leading-6 ≈ 1.5rem = 24px) */
          cursor: pointer;
        }
        /* Pager */
        .pager-btn[disabled] {
          opacity: 0.4;
          cursor: default;
        }
        .panel-page { display: none; }
        .panel-page.active { display: block; }
    </style>
</head>
<body class="flex flex-col md:flex-row h-screen antialiased">

    
    <!-- Controls and Info Panel -->
    <div id="control-panel" class="absolute top-4 right-4 w-96 max-h-[90vh] p-6 bg-gray-800 shadow-lg flex flex-col space-y-4 overflow-y-auto rounded-lg z-40 transition-transform transform" style="transform: translateX(0);">
      <!-- Panel Header: Pager + Collapse -->
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center gap-2">
          <button id="page-left" class="pager-btn w-7 h-7 rounded border border-gray-500 text-gray-200 text-xs flex items-center justify-center" disabled>◀</button>
          <button id="page-right" class="pager-btn w-7 h-7 rounded border border-gray-500 text-gray-200 text-xs flex items-center justify-center">▶</button>
        </div>
      </div>
      <div id="page-1" class="panel-page active">
        <div>
            <h1 class="text-2xl font-bold text-white">Hyperbolic Polyhedron</h1>
            <p class="text-sm text-gray-400 mt-1">Poincaré Ball Model Visualization</p>
        </div>

        <div>
            <label for="vectors" class="block text-sm font-medium text-gray-300 mb-2">Input Vectors S = {v₁, v₂, ...}</label>
            <div id="vector-input" class="relative">
              <div id="vector-gutter" class="absolute left-0 top-0 bottom-0 w-4 bg-gray-800/60 border-r border-gray-700 overflow-hidden rounded-l-md"></div>
              <textarea id="vectors" rows="8" class="block w-full rounded-md bg-gray-700 border-gray-600 text-gray-200 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm font-mono pl-6 leading-6"></textarea>
            </div>
            <p id="error-message" class="text-red-400 text-sm mt-2 h-4"></p>
        </div>

        <div>
            <select id="example-select" class="block w-full rounded-md bg-gray-700 border-gray-600 text-gray-200 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                <option value="">-- Select an Example --</option>
                
            </select>
        </div>

        <button id="render-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 ease-in-out">
            Render Polyhedron
        </button>

        <div class="flex items-center space-x-2">
            <input id="auto-rotate" type="checkbox" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
            <label for="auto-rotate" class="text-sm text-gray-300">Auto‑rotate scene</label>
        </div>
        <div class="flex items-center space-x-2">
            <input id="toggle-boundary" type="checkbox" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500" checked>
            <label for="toggle-boundary" class="text-sm text-gray-300">Toggle boundary</label>
        </div>


        <div class="text-xs text-gray-500 pt-4 border-t border-gray-700">
            <p><strong>Controls:</strong> Drag to rotate, scroll to zoom, right-drag to pan.</p>
        </div>
      </div> <!-- end page-1 -->

      <!-- Page 2: Color Palette -->
      <div id="page-2" class="panel-page">
        <div>
          <h2 class="text-xl font-semibold text-white mb-2">Color Palette</h2>
          <p class="text-sm text-gray-400 mb-3">Choose how faces are colored. This affects both the rendering and the gutter.</p>
          <label for="palette-select" class="block text-sm font-medium text-gray-300 mb-1">Palette</label>
          <select id="palette-select" class="block w-full rounded-md bg-gray-700 border-gray-600 text-gray-200 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
            <option value="colorful" selected>colorful</option>
            <option value="vaporwave">vaporwave</option>
            <option value="uc">UC colors (blue & gold)</option>
            <option value="halloween">halloween</option>
            <option value="tie-dye">tie-dye</option>
            <option value="sunset">sunset</option>
          </select>
        </div>
      </div>

      <!-- Page 3: How it Works -->
      <div id="page-3" class="panel-page">
        <div class="info-panel text-sm text-gray-400 bg-gray-900/50 p-4 rounded-lg">
            <h2 class="font-semibold text-white mb-2">How it Works</h2>
            <p>This tool visualizes a polyhedron in the Poincaré ball model of hyperbolic 3-space.</p>
            <ol class="list-decimal list-inside mt-2 space-y-1">
                <li>Enter a set of 4D vectors <code>[x, y, z, t]</code> above.</li>
                <li>Each vector <code>v</code> must be <strong>spacelike</strong> (i.e., x²+y²+z² > t²).</li>
                <li>The final coordinate <strong>t must be nonpositive (<= 0)</strong>.</li>
            </ol>
            <p class="mt-2">The point (0,0,0,1) in Minkowski space corresponds to the center of the ball.</p>
        </div>
      </div>
    </div>

    <!-- Panel Toggle Button (kept visible even when panel is collapsed) -->
    <button id="toggle-panel-btn"
            class="fixed top-4 right-4 rounded-full w-8 h-8 flex items-center justify-center z-50 border border-gray-400 text-gray-300 hover:bg-gray-700"
            title="Collapse/Expand control panel">☰</button>

    <!-- 3D Scene Container -->
    <div id="container" class="flex-grow h-full w-full"></div>

    <!-- Shaders -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec2 vUv;
        
        // --- Uniforms
        uniform vec2 u_resolution;
        uniform mat4 u_inverseViewProjectionMatrix;
        uniform vec3 u_cameraPosition;
        uniform int u_palette_mode; // 0=colorful, 1=vaporwave, 2=uc
        
        const int MAX_PLANES = 64;
        
        // --- Spherical Boundaries (from vectors with w < 0)
        uniform int u_num_sphere_planes;
        uniform vec3 u_sphere_centers[MAX_PLANES];
        uniform float u_sphere_radii[MAX_PLANES];
        
        // --- Euclidean Planar Boundaries (from vectors with w = 0)
        uniform int u_num_euclidean_planes;
        uniform vec3 u_plane_normals[MAX_PLANES]; // Pre-oriented to point "inward"

        // --- Ray Marching Settings
        const int MAX_STEPS = 150;
        const float MAX_DIST = 10.0;
        const float HIT_THRESHOLD = 0.001;

        // --- Utilities for per-face colors
        vec3 hsv2rgb(vec3 c) {
            vec3 rgb = clamp( abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0 );
            return c.z * mix(vec3(1.0), rgb, c.y);
        }

        vec3 faceColor(float id) {
            if (u_palette_mode == 0) {
                // colorful: golden-ratio hue stepping
                float h = fract(id * 0.61803398875);
                return hsv2rgb(vec3(h, 0.6, 0.9));
            } else if (u_palette_mode == 1) {
                // vaporwave palette (8 colors)
                int k = int(mod(id, 8.0));
                if (k == 0) return vec3(0.988, 0.741, 0.961); // pink-ish
                if (k == 1) return vec3(0.776, 0.706, 0.988); // lilac
                if (k == 2) return vec3(0.600, 0.800, 0.988); // light cyan
                if (k == 3) return vec3(0.525, 0.898, 0.839); // mint
                if (k == 4) return vec3(0.988, 0.843, 0.600); // peach
                if (k == 5) return vec3(0.949, 0.600, 0.741); // rose
                if (k == 6) return vec3(0.678, 0.678, 0.988); // periwinkle
                return vec3(0.514, 0.867, 0.988);             // sky
            } else if (u_palette_mode == 3) {
                // halloween palette (4 colors): pumpkin, deep purple, slime green, charcoal
                int k = int(mod(id, 4.0));
                if (k == 0) return vec3(1.000, 0.431, 0.000); // pumpkin orange (#FF6E00)
                if (k == 1) return vec3(0.361, 0.000, 0.616); // deep purple (#5C009D)
                if (k == 2) return vec3(0.561, 0.831, 0.000); // slime green (#8FD400)
                return vec3(0.102, 0.102, 0.122);             // charcoal (#1A1A1F)
            } else if (u_palette_mode == 4) {
                // tie-dye: sinusoidal hue/sat/val variations for a psychedelic effect
                float h = fract(0.5 + 0.5 * sin(id * 2.399));
                float s = clamp(0.70 + 0.30 * sin(id * 1.113 + 1.0), 0.55, 1.0);
                float v = clamp(0.90 + 0.10 * sin(id * 0.713 + 2.0), 0.75, 1.0);
                return hsv2rgb(vec3(h, s, v));
            } else if (u_palette_mode == 5) {
                // sunset palette (16 colors, id wraps mod 16) -- randomized
                int k = int(floor(fract(sin(id * 12.9898) * 43758.5453) * 16.0));
                if (k == 0)  return vec3(0.965, 0.843, 0.647); // #f6d7a5
                if (k == 1)  return vec3(0.933, 0.831, 0.671); // #eed4ab
                if (k == 2)  return vec3(0.933, 0.686, 0.380); // #eeaf61
                if (k == 3)  return vec3(0.941, 0.627, 0.431); // #f0a06e
                if (k == 4)  return vec3(0.984, 0.565, 0.384); // #fb9062
                if (k == 5)  return vec3(0.980, 0.482, 0.369); // #fa7b5e
                if (k == 6)  return vec3(0.949, 0.416, 0.400); // #f26a66
                if (k == 7)  return vec3(0.933, 0.365, 0.424); // #ee5d6c
                if (k == 8)  return vec3(0.847, 0.329, 0.529); // #d85487
                if (k == 9)  return vec3(0.808, 0.286, 0.576); // #ce4993
                if (k == 10) return vec3(0.714, 0.224, 0.663); // #b639a9
                if (k == 11) return vec3(0.561, 0.122, 0.643); // #8f1fa4
                if (k == 12) return vec3(0.416, 0.051, 0.514); // #6a0d83
                if (k == 13) return vec3(0.310, 0.008, 0.439); // #4f0270
                if (k == 14) return vec3(0.227, 0.000, 0.357); // #3a005b
                return vec3(0.118, 0.000, 0.247);             // #1e003f
            } else {
                // uc colors: alternate UC blue & gold
                int k = int(mod(id, 2.0));
                if (k == 0) return vec3(0.000, 0.200, 0.400); // UC Blue (#003660)
                return vec3(1.000, 0.737,  0.000);             // UC Gold (#FEBC11)
            }
        }

        // Signed Distance Function with face ID reporting.
        vec2 sceneSDFWithId(vec3 p) {
            float max_dist = -MAX_DIST;
            float face_id  = -1.0;

            // 1) Spherical boundaries (IDs 0 .. u_num_sphere_planes-1)
            for (int i = 0; i < MAX_PLANES; i++) {
                if (i >= u_num_sphere_planes) break;
                float dist_to_sphere = length(p - u_sphere_centers[i]) - u_sphere_radii[i];
                float sdf = -dist_to_sphere; // inside = negative, we flip to match intersection convention used
                if (sdf > max_dist) { max_dist = sdf; face_id = float(i); }
            }

            // 2) Euclidean planar boundaries (IDs offset after spheres)
            for (int i = 0; i < MAX_PLANES; i++) {
                if (i >= u_num_euclidean_planes) break;
                float sdf = dot(p, u_plane_normals[i]);
                if (sdf > max_dist) { max_dist = sdf; face_id = float(u_num_sphere_planes + i); }
            }

            return vec2(max_dist, face_id);
        }

        vec3 getNormal(vec3 p) {
            vec2 e = vec2(HIT_THRESHOLD, 0.0);
            float d = sceneSDFWithId(p).x;
            vec3 n = d - vec3(
                sceneSDFWithId(p - e.xyy).x,
                sceneSDFWithId(p - e.yxy).x,
                sceneSDFWithId(p - e.yyx).x
            );
            return normalize(n);
        }
        
        vec3 applyLighting(vec3 color, vec3 normal, vec3 p) {
            vec3 lightPos = u_cameraPosition + vec3(0.5, 0.5, 0.5);
            vec3 lightDir = normalize(lightPos - p);
            float diff = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = diff * color;
            vec3 ambient = 0.2 * color;
            return ambient + diffuse;
        }
        
        vec2 raySphereIntersect(vec3 ro, vec3 rd, float r) {
            float b = dot(ro, rd);
            float c = dot(ro, ro) - r * r;
            float h = b*b - c;
            if (h < 0.0) return vec2(-1.0);
            h = sqrt(h);
            return vec2(-b - h, -b + h);
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy / u_resolution.xy) * 2.0 - 1.0;
            vec4 pNear = u_inverseViewProjectionMatrix * vec4(uv, -1.0, 1.0);
            vec4 pFar  = u_inverseViewProjectionMatrix * vec4(uv,  1.0, 1.0);
            vec3 ro = u_cameraPosition;
            vec3 rd = normalize(pFar.xyz / pFar.w - ro);

            vec2 t_ball = raySphereIntersect(ro, rd, 1.0);
            if (t_ball.x < 0.0 && t_ball.y < 0.0) discard;

            float t = max(0.0, t_ball.x);
            vec3 p = ro + rd * t;
            bool hit = false;
            
            for (int i = 0; i < MAX_STEPS; i++) {
                if ((t_ball.y > 0.0 && t > t_ball.y) || t > MAX_DIST) break;
                float dist = sceneSDFWithId(p).x;
                if (abs(dist) < HIT_THRESHOLD) {
                    hit = true;
                    break;
                }
                // Always move forward: outside region (dist<0) would step backwards; use abs() with a small floor.
                float step = max(abs(dist), 0.001);
                t += step;
                p = ro + rd * t;
            }
            
            if (hit) {
                float faceId = sceneSDFWithId(p).y;
                vec3 baseColor = faceColor(faceId);
                vec3 normal = getNormal(p);
                // Two-sided shading: ensure the normal faces the viewer
                if (dot(normal, -rd) < 0.0) normal = -normal;
                vec3 litColor = applyLighting(baseColor, normal, p);
                gl_FragColor = vec4(litColor, 1.0);
            } else {
                discard;
            }
        }
    </script>
    
    <!-- Main three.js Script -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        import POLYHEDRA_LIBRARY from './assets/polyhedronLibrary.js';

        // --- Auto-detect payload from other tools/pages ---
        function getExternalVectorsPayload() {
          // Prefer explicit URL param ?vectors= (Base64-encoded text)
          try {
            const params = new URLSearchParams(window.location.search);
            const vParam = params.get('vectors');
            if (vParam) {
              try {
                const decoded = atob(decodeURIComponent(vParam));
                if (decoded && decoded.trim().length > 0) return decoded;
              } catch (e) {
                console.warn('Failed to decode vectors param:', e);
              }
            }
          } catch (e) {
            console.warn('URL parsing failed:', e);
          }
          // Fallback: localStorage key written by other pages
          try {
            const ls = localStorage.getItem('poincare_input');
            if (ls && ls.trim().length > 0) return ls;
          } catch (e) {
            // ignore storage access errors
          }
          return null;
        }

        // --- UI helpers: match fragment shader colors ---
        function hsv2rgbJS(h, s, v) {
          const k = (n) => (n + h * 6) % 6;
          const f = (n) => v - v * s * Math.max(Math.min(k(n), 4 - k(n), 1), 0);
          const r = Math.round(f(5) * 255);
          const g = Math.round(f(3) * 255);
          const b = Math.round(f(1) * 255);
          return `rgb(${r}, ${g}, ${b})`;
        }
        let _paletteMode = 0; // 0=colorful, 1=vaporwave, 2=uc
        function faceColorJS(id) {
          if (_paletteMode === 0) {
            const golden = 0.61803398875;
            const hue = (id * golden) % 1;
            return hsv2rgbJS(hue, 0.6, 0.9);
          } else if (_paletteMode === 1) {
            const pal = [
              [252,189,245], [198,180,252], [153,204,252], [134,229,214],
              [252,215,153], [242,153,189], [173,173,252], [131,221,252]
            ];
            const c = pal[id % pal.length];
            return `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
          } else if (_paletteMode === 3) {
            const pal = [
              [255,110,0],   // pumpkin orange
              [92,0,157],    // deep purple
              [143,212,0],   // slime green
              [26,26,31],    // charcoal
            ];
            const c = pal[id % pal.length];
            return `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
          } else if (_paletteMode === 4) {
            const h = (0.5 + 0.5 * Math.sin(id * 2.399)) % 1;
            const s = Math.min(1, Math.max(0, 0.70 + 0.30 * Math.sin(id * 1.113 + 1.0)));
            const v = Math.min(1, Math.max(0, 0.90 + 0.10 * Math.sin(id * 0.713 + 2.0)));
            return hsv2rgbJS((h + 1) % 1, s, v);
          } else if (_paletteMode === 5) {
            const pal = [
              [246,215,165], [238,212,171], [238,175, 97], [240,160,110],
              [251,144, 98], [250,123, 94], [242,106,102], [238, 93,108],
              [216, 84,135], [206, 73,147], [182, 57,169], [143, 31,164],
              [106, 13,131], [ 79,  2,112], [ 58,  0, 91], [ 30,  0, 63]
            ];
            // Randomize sunset palette index for visual consistency with shader
            const fract = (x) => x - Math.floor(x);
            const k = Math.floor(fract(Math.sin(id * 12.9898) * 43758.5453) * pal.length);
            const c = pal[k];
            return `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
          } else {
            // UC colors alternate
            const blue = [0,51,98];    // #003262
            const gold = [253,181,21]; // #FDB515
            const c = (id % 2 === 0) ? blue : gold;
            return `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
          }
        }

        function renderGutter(lineCount, faceIds) {
          const gutter = document.getElementById('vector-gutter');
          if (!gutter) return;
          gutter.innerHTML = '';
          for (let i = 0; i < lineCount; i++) {
            const div = document.createElement('div');
            div.className = 'box';
            div.dataset.line = String(i);
            const fid = (faceIds && Number.isFinite(faceIds[i])) ? faceIds[i] : null;
            if (fid === null) {
              div.style.background = 'transparent';
              div.title = `Line ${i+1}`;
            } else {
              div.style.background = faceColorJS(fid);
              div.title = `Line ${i+1} → face ${fid}`;
            }
            gutter.appendChild(div);
          }
        }

        let scene, camera, renderer, controls, material, uniforms, boundarySphere;
        // Keep latest parsed geometry for interactivity
        let _currentSphereCenters = [];
        let _currentSphereRadii = [];
        let _currentPlaneNormals = [];
        let _currentFaceIdsByLine = [];
        function easeInOutQuad(t){ return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }
        function flyCameraToDirection(dir, durationMs=450){
          const start = performance.now();
          const startPos = camera.position.clone();
          const endPos = dir.clone().normalize().multiplyScalar(1.8); // just outside unit ball
          const target = new THREE.Vector3(0,0,0);
          controls.enabled = false;
          controls.target.copy(target);
          function step(now){
            const t = Math.min(1, (now - start)/durationMs);
            const k = easeInOutQuad(t);
            camera.position.lerpVectors(startPos, endPos, k);
            camera.lookAt(target);
            renderer.render(scene, camera);
            if (t < 1) requestAnimationFrame(step); else { controls.enabled = true; }
          }
          requestAnimationFrame(step);
        }

        function lookHeadOnAtFaceId(faceId){
          if (!Number.isFinite(faceId)) return;
          const numSpheres = _currentSphereCenters.length;
          let dir;
          if (faceId < numSpheres) {
            dir = _currentSphereCenters[faceId]?.clone();
          } else {
            const i = faceId - numSpheres;
            dir = _currentPlaneNormals[i]?.clone();
          }
          if (!dir) return;
          if (dir.lengthSq() < 1e-9) return;
          flyCameraToDirection(dir);
        }
        const MAX_PLANES_CONST = 64;
        
        const defaultVectors = [
            " 2, 0, 0, -1",
            "-2, 0, 0, -1",
            " 0, 2, 0, -1",
            " 0,-2, 0, -1",
            " 0, 0, 2, -1",
            " 0, 0,-2, -1",
        ].join('\n');

        function vectorsToTextarea(vectors) {
            return vectors.map(v => v.join(', ')).join('\n');
        }

        function init() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0, 0, 1.8);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = false; // default unchecked
            controls.autoRotateSpeed = 0.6; // tune as desired

            // Lighting for glossy boundary sphere
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(3, 3, 5);
            scene.add(dirLight);

            // Boundary of the Poincare Ball (a glossy, transparent sphere)
            const boundaryGeom = new THREE.SphereGeometry(1, 64, 64);
            const boundaryMat = new THREE.MeshPhongMaterial({
                color: 0x88aaff,
                transparent: true,
                opacity: 0.4,
                shininess: 120,
                specular: 0xffffff
            });
            boundarySphere = new THREE.Mesh(boundaryGeom, boundaryMat);
            boundarySphere.renderOrder = 0; // FIX: Render the boundary sphere first.
            boundarySphere.material.side = THREE.DoubleSide; // visible from inside/outside
            
            const initialSphereCenters = Array.from({ length: MAX_PLANES_CONST }, () => new THREE.Vector3());
            const initialSphereRadii = new Float32Array(MAX_PLANES_CONST);
            const initialPlaneNormals = Array.from({ length: MAX_PLANES_CONST }, () => new THREE.Vector3());

            uniforms = {
                u_resolution: { value: new THREE.Vector2(renderer.domElement.width, renderer.domElement.height) },
                u_cameraPosition: { value: camera.position },
                u_inverseViewProjectionMatrix: { value: new THREE.Matrix4() },
                u_num_sphere_planes: { value: 0 },
                u_sphere_centers: { value: initialSphereCenters },
                u_sphere_radii: { value: initialSphereRadii },
                u_num_euclidean_planes: { value: 0 },
                u_plane_normals: { value: initialPlaneNormals },
                u_palette_mode: { value: _paletteMode },
            };
            material = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                uniforms: uniforms,
                transparent: true,    // FIX: Allow transparency for fragments that are discarded.
                depthWrite: false,    // FIX: Don't let the quad block the wireframe behind it.
            });

            // Add boundary and quad to a group, center at origin, set camera/controls target
            const hyperbolicGroup = new THREE.Group();
            hyperbolicGroup.add(boundarySphere);

            const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
            quad.renderOrder = 1; // Render after boundary
            hyperbolicGroup.add(quad);

            // Center group at origin
            hyperbolicGroup.position.set(0, 0, 0);
            scene.add(hyperbolicGroup);

            // Ensure camera and controls are centered at origin
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);

            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('render-btn').addEventListener('click', updateFromInput);
            // Auto-load external payload if available; otherwise use defaults
            const externalPayload = getExternalVectorsPayload();
            const vectorsEl = document.getElementById('vectors');
            if (externalPayload) {
                vectorsEl.value = externalPayload;
            } else {
                vectorsEl.value = defaultVectors;
            }

            const vectorsTA = document.getElementById('vectors');
            const gutterDiv = document.getElementById('vector-gutter');
            if (vectorsTA && gutterDiv) {
              // Sync gutter scroll with textarea
              vectorsTA.addEventListener('scroll', () => {
                gutterDiv.scrollTop = vectorsTA.scrollTop;
              });
              // Rebuild gutter on input (temporary neutral color until parsed)
              vectorsTA.addEventListener('input', () => {
                const lines = vectorsTA.value.split('\n');
                renderGutter(lines.filter(l => l.trim() !== '').length);
              });
            }
            // Initial gutter based on actual textarea content
            renderGutter((vectorsEl.value || '').split('\n').filter(l => l.trim() !== '').length);

            // Click-to-focus: when a gutter box is clicked, move camera to look head-on at that face
            if (gutterDiv) {
              gutterDiv.addEventListener('click', (e) => {
                const box = e.target.closest('.box');
                if (!box) return;
                const line = parseInt(box.dataset.line, 10);
                if (!Number.isInteger(line)) return;
                const faceId = _currentFaceIdsByLine[line];
                if (faceId === undefined) return;
                lookHeadOnAtFaceId(faceId);
              });
            }

            const autoRotateCheckbox = document.getElementById('auto-rotate');
            if (autoRotateCheckbox) {
                // Keep checkbox in sync with controls
                autoRotateCheckbox.checked = controls.autoRotate;
                autoRotateCheckbox.addEventListener('change', (e) => {
                    controls.autoRotate = e.target.checked;
                });
            }

            // Boundary visibility toggle
            const boundaryToggle = document.getElementById('toggle-boundary');
            if (boundaryToggle) {
                // Initialize state
                boundarySphere.visible = boundaryToggle.checked;
                boundaryToggle.addEventListener('change', (e) => {
                    boundarySphere.visible = e.target.checked;
                });
            }

            // Populate examples dropdown
            const select = document.getElementById('example-select');
            if (POLYHEDRA_LIBRARY && Array.isArray(POLYHEDRA_LIBRARY.polyhedra)) {
                POLYHEDRA_LIBRARY.polyhedra.forEach((item, idx) => {
                    const opt = document.createElement('option');
                    opt.value = String(idx);
                    opt.textContent = item.name || `Example ${idx+1}`;
                    select.appendChild(opt);
                });
            }

            // When an example is chosen, update the textarea and render
            select.addEventListener('change', (e) => {
                const i = parseInt(e.target.value, 10);
                if (Number.isInteger(i) && POLYHEDRA_LIBRARY.polyhedra[i]) {
                    const { vectors } = POLYHEDRA_LIBRARY.polyhedra[i];
                    document.getElementById('vectors').value = vectorsToTextarea(vectors);
                    updateFromInput();
                }
            });

            // Palette selector on Page 2
            const paletteSelect = document.getElementById('palette-select');
            if (paletteSelect) {
              paletteSelect.addEventListener('change', () => {
                const v = paletteSelect.value;
                const map = { 'colorful': 0, 'vaporwave': 1, 'uc': 2, 'halloween': 3, 'tie-dye': 4, 'sunset': 5 };
                _paletteMode = map[v] ?? 0;
                uniforms.u_palette_mode.value = _paletteMode;
                // Re-render gutter with new colors
                const lines = (document.getElementById('vectors').value || '').split('\n').filter(l=>l.trim()!=='');
                renderGutter(lines.length, _currentFaceIdsByLine);
              });
            }

            // Simple 3-page pager
            let _pageIndex = 0; // 0..2
            const pages = [
              document.getElementById('page-1'),
              document.getElementById('page-2'),
              document.getElementById('page-3')
            ];
            const leftBtn = document.getElementById('page-left');
            const rightBtn = document.getElementById('page-right');
            function showPage(i){
              _pageIndex = Math.max(0, Math.min(2, i));
              pages.forEach((p, idx)=>{ if(p) p.classList.toggle('active', idx===_pageIndex); });
              if (leftBtn) leftBtn.disabled = (_pageIndex === 0);
              if (rightBtn) rightBtn.disabled = (_pageIndex === 2);
            }
            if (leftBtn) leftBtn.addEventListener('click', ()=> showPage(_pageIndex-1));
            if (rightBtn) rightBtn.addEventListener('click', ()=> showPage(_pageIndex+1));
            showPage(0);

            updateFromInput();
            animate();
        }

        function updateFromInput() {
            const vectorText = document.getElementById('vectors').value.trim();
            const lines = vectorText.split('\n').filter(line => line.trim() !== '');
            const errorMessage = document.getElementById('error-message');
            errorMessage.textContent = '';

            if (lines.length > MAX_PLANES_CONST) {
                errorMessage.textContent = `Error: Max ${MAX_PLANES_CONST} vectors allowed.`;
                renderGutter(lines.length);
                _currentSphereCenters = [];
                _currentSphereRadii = [];
                _currentPlaneNormals = [];
                _currentFaceIdsByLine = [];
                return;
            }

            const sphereCenters = [];
            const sphereRadii = [];
            const planeNormals = [];
            // Track which face each input line becomes (spheres first, then planes)
            const lineKinds = []; // 'sphere' | 'plane'
            const lineLocalIdx = []; // index within its category at time of push

            for (const line of lines) {
                const parts = line.split(',').map(s => parseFloat(s.trim()));
                if (parts.length !== 4 || parts.some(isNaN)) {
                    errorMessage.textContent = `Invalid format: "${line}"`;
                    renderGutter(lines.length);
                    _currentSphereCenters = [];
                    _currentSphereRadii = [];
                    _currentPlaneNormals = [];
                    _currentFaceIdsByLine = [];
                    return;
                }

                const v = new THREE.Vector4(...parts);
                if (v.w > 0) {
                    errorMessage.textContent = `Final coordinate must be nonpositive (w <= 0).`;
                    renderGutter(lines.length);
                    _currentSphereCenters = [];
                    _currentSphereRadii = [];
                    _currentPlaneNormals = [];
                    _currentFaceIdsByLine = [];
                    return;
                }
                
                const n = new THREE.Vector3(v.x, v.y, v.z);
                const nSq = n.lengthSq();
                const wSq = v.w * v.w;

                if (nSq <= wSq) {
                    errorMessage.textContent = `Vector is not spacelike.`;
                    renderGutter(lines.length);
                    _currentSphereCenters = [];
                    _currentSphereRadii = [];
                    _currentPlaneNormals = [];
                    _currentFaceIdsByLine = [];
                    return;
                }

                if (Math.abs(v.w) < 1e-6) { // Case: w = 0 (Euclidean plane)
                    if (n.lengthSq() < 1e-6) {
                        errorMessage.textContent = `Vector [0,0,0,0] is invalid.`;
                        renderGutter(lines.length);
                        _currentSphereCenters = [];
                        _currentSphereRadii = [];
                        _currentPlaneNormals = [];
                        _currentFaceIdsByLine = [];
                        return;
                    }
                    // The half-space is dot(n,p) >= 0. For our SDF, we need dot(p, N) <= 0.
                    // So we set N = -normalize(n).
                    planeNormals.push(n.clone().normalize().negate());
                    lineKinds.push('plane');
                    lineLocalIdx.push(planeNormals.length - 1);
                } else { // Case: w < 0 (Spherical plane)
                    sphereCenters.push(n.clone().divideScalar(v.w));
                    sphereRadii.push(Math.sqrt(nSq / wSq - 1));
                    lineKinds.push('sphere');
                    lineLocalIdx.push(sphereCenters.length - 1);
                }
            }
            
            // Map each original input line to its actual faceId in the shader
            const faceIdsByLine = [];
            const numSpheres = sphereCenters.length;
            for (let i = 0; i < lineKinds.length; i++) {
              if (lineKinds[i] === 'sphere') {
                faceIdsByLine[i] = lineLocalIdx[i];
              } else if (lineKinds[i] === 'plane') {
                faceIdsByLine[i] = numSpheres + lineLocalIdx[i];
              } else {
                faceIdsByLine[i] = undefined;
              }
            }
            // Update gutter colors to match face ordering in the shader
            renderGutter(lines.length, faceIdsByLine);
            // Persist latest parse for interactivity
            _currentSphereCenters = sphereCenters.map(v => v.clone());
            _currentSphereRadii = sphereRadii.slice();
            _currentPlaneNormals = planeNormals.map(v => v.clone());
            _currentFaceIdsByLine = faceIdsByLine.slice();

            uniforms.u_num_sphere_planes.value = sphereCenters.length;
            for (let i = 0; i < MAX_PLANES_CONST; i++) {
                uniforms.u_sphere_centers.value[i].set(0,0,0); // Clear old data
                if (i < sphereCenters.length) {
                    uniforms.u_sphere_centers.value[i].copy(sphereCenters[i]);
                    uniforms.u_sphere_radii.value[i] = sphereRadii[i];
                }
            }

            uniforms.u_num_euclidean_planes.value = planeNormals.length;
             for (let i = 0; i < MAX_PLANES_CONST; i++) {
                uniforms.u_plane_normals.value[i].set(0,0,0); // Clear old data
                if (i < planeNormals.length) {
                    uniforms.u_plane_normals.value[i].copy(planeNormals[i]);
                }
            }
            // If this session was opened with an external payload via localStorage, clear it after applying once
            try {
                const srcHash = (window.location.hash || '');
                if (srcHash.includes('source=poincare_input')) {
                    localStorage.removeItem('poincare_input');
                }
            } catch (e) {
                // ignore storage errors
            }
        }

        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            uniforms.u_resolution.value.set(renderer.domElement.width, renderer.domElement.height);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            camera.updateMatrixWorld();
            const inverseViewProjectionMatrix = new THREE.Matrix4().multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);
            uniforms.u_inverseViewProjectionMatrix.value.copy(inverseViewProjectionMatrix);
            uniforms.u_cameraPosition.value.copy(camera.position);
            renderer.render(scene, camera);
        }

        // --- Panel collapse/expand logic ---
        const panel = document.getElementById('control-panel');
        const toggleBtn = document.getElementById('toggle-panel-btn');
        let panelVisible = true;
        toggleBtn.addEventListener('click', () => {
            panelVisible = !panelVisible;
            if (panelVisible) {
                panel.style.transform = 'translateX(0)';
                toggleBtn.title = 'Collapse control panel';
            } else {
                panel.style.transform = 'translateX(110%)';
                toggleBtn.title = 'Expand control panel';
            }
        });

        init();
    </script>
</body>
</html>