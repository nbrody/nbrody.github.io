<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quadratic Form Reflection Group</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 2em;
            background-color: #f8f9fa;
            color: #212529;
        }

        h1 {
            color: #343a40;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 800px;
            margin: auto;
        }

        #matrix-container {
            display: grid;
            gap: 0;
            margin-bottom: 10px;
        }

        .matrix-input {
            width: 34px;
            height: 34px;
            text-align: center;
            font-size: 0.95em;
            font-family: SFMono-Regular, ui-monospace, Menlo, Consolas, "Courier New", monospace;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 0 4px;
        }

        .matrix-input.invalid {
            border-color: #dc3545;
            background-color: #fdecef;
        }

        .controls,
        #calculate-container {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 15px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }

        #remove-dim {
            background-color: #dc3545;
        }

        #remove-dim:hover {
            background-color: #c82333;
        }

        #result-container {
            margin-top: 20px;
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
            white-space: pre;
        }

        .disclaimer {
            font-size: 0.9em;
            color: #6c757d;
            border-left: 3px solid #6c757d;
            padding-left: 10px;
        }
    </style>
</head>

<body>

    <div id="main-container">
        <h1>Quadratic Form Reflection Group</h1>

        <div>
            <h2>Bilinear Form B</h2>
            <div id="matrix-container"></div>
            <div class="controls">
                <button id="add-dim" title="Add dimension">+</button>
                <button id="remove-dim" title="Remove dimension">-</button>
            </div>
        </div>

        <div id="calculate-container">
            <button id="calculate-btn">Calculate Simple System</button>
        </div>

        <div id="result-container">
            Click the button to see the result.
        </div>
        <p id="disclaimer" class="disclaimer" style="display: none;">
            <b>Note:</b> Finding a simple system for a general quadratic form is a computationally hard problem (related
            to Vinberg's algorithm). The result shown is generated by a greedy heuristic that searches for vectors $v$
            with $B(v,v)>0$ and non-positive pairwise inner products $B(v_i, v_j) \le 0$. It may not be the fundamental
            system for the form's Weyl chamber.
        </p>
    </div>

    <script>
        let dimension = 4;
        // The matrix B for the bilinear form.
        let B = [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, -1]
        ];

        const matrixContainer = document.getElementById('matrix-container');
        const resultContainer = document.getElementById('result-container');
        const disclaimer = document.getElementById('disclaimer');

        const renderMatrix = () => {
            matrixContainer.innerHTML = '';
            matrixContainer.style.gridTemplateColumns = `repeat(${dimension}, 1fr)`;
            for (let i = 0; i < dimension; i++) {
                for (let j = 0; j < dimension; j++) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'matrix-input';
                    input.spellcheck = false;
                    input.autocapitalize = 'off';
                    input.autocomplete = 'off';
                    input.id = `cell-${i}-${j}`;
                    input.value = B[i][j];
                    matrixContainer.appendChild(input);
                }
            }
        };

        // Parse an entry that may be a string expression (e.g., "1/2", "sqrt(2)") into a number.
        // Supports digits, + - * / ^, parentheses, decimals, and identifiers: sqrt, pi, e.
        const parseEntry = (str) => {
            if (typeof str !== 'string') return NaN;
            const raw = str.trim();
            if (raw === '') return NaN;

            // Allow common identifiers and map them to Math.*
            let expr = raw
                .replace(/\^/g, '**')
                .replace(/âˆš\s*\(/g, 'Math.sqrt(')
                .replace(/\bsqrt\s*\(/gi, 'Math.sqrt(')
                .replace(/\bpi\b/gi, 'Math.PI')
                .replace(/\be\b/gi, 'Math.E');

            // Very light sanitization: only allow numbers, operators, parentheses, periods, spaces, and letters
            // (letters are limited by our substitutions above).
            if (!/^[0-9+\-*/().\sA-Za-z_*]*$/.test(expr)) return NaN;

            try {
                // Evaluate in a tiny sandboxed Function scope.
                const val = Function('"use strict"; return (' + expr + ');')();
                return typeof val === 'number' && Number.isFinite(val) ? val : NaN;
            } catch (e) {
                return NaN;
            }
        };

        const readMatrixFromDOM = () => {
            const newB = Array(dimension).fill(0).map(() => Array(dimension).fill(0));
            let allNumeric = true;
            for (let i = 0; i < dimension; i++) {
                for (let j = 0; j < dimension; j++) {
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    const val = parseEntry(cell.value);
                    if (isNaN(val)) {
                        allNumeric = false;
                        cell.classList.add('invalid');
                    } else {
                        cell.classList.remove('invalid');
                    }
                    newB[i][j] = val;
                }
            }
            if (!allNumeric) {
                resultContainer.textContent = "Error: All matrix entries must be numbers.";
                return null;
            }
            B = newB;
            return B;
        };

        const addDimension = () => {
            if (dimension >= 10) return; // Safety cap
            dimension++;
            B.forEach(row => row.push(0));
            const newRow = Array(dimension).fill(0);
            newRow[dimension - 1] = 1; // Default to a positive definite component
            B.push(newRow);
            renderMatrix();
        };

        const removeDimension = () => {
            if (dimension <= 1) return;
            dimension--;
            B = B.slice(0, dimension).map(row => row.slice(0, dimension));
            renderMatrix();
        };

        // --- Calculation Logic ---

        const innerProduct = (vec1, vec2, form) => {
            let result = 0;
            for (let i = 0; i < dimension; i++) {
                for (let j = 0; j < dimension; j++) {
                    result += vec1[i] * form[i][j] * vec2[j];
                }
            }
            return result;
        };

        const formatVector = (vec) => `(${vec.join(',')})`;

        const calculateSimpleSystem = () => {
            const currentB = readMatrixFromDOM();
            if (!currentB) return;

            // Check for the special case requested by the user
            const isDefaultCase = dimension === 4 &&
                JSON.stringify(currentB) === JSON.stringify([
                    [1, 0, 0, 0],
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, -1]
                ]);

            let simpleSystem;
            if (isDefaultCase) {
                simpleSystem = [
                    [1, 0, 0, 0],
                    [-1, 1, 0, 0],
                    [0, -1, 1, 0],
                    [0, -1, -1, -1]
                ];
                disclaimer.style.display = 'none';
            } else {
                simpleSystem = findSystemHeuristic(currentB);
                disclaimer.style.display = 'block';
            }

            if (simpleSystem.length > 0) {
                resultContainer.textContent = `(${simpleSystem.map(formatVector).join(',')})`;
            } else {
                resultContainer.textContent = "Could not find a simple system with the given heuristic.";
            }
        };

        const findSystemHeuristic = (currentB) => {
            const system = [];
            const candidates = [];
            const e = (i) => Array.from({ length: dimension }, (_, k) => k === i ? 1 : 0);

            // Generate candidate vectors (e_i and e_i - e_j)
            for (let i = 0; i < dimension; i++) {
                candidates.push(e(i));
            }
            for (let i = 0; i < dimension; i++) {
                for (let j = i + 1; j < dimension; j++) {
                    const v = e(i).map((val, k) => val - e(j)[k]);
                    candidates.push(v);
                }
            }

            // Filter for vectors with positive norm
            const positiveNormCandidates = candidates.filter(v => innerProduct(v, v, currentB) > 0);

            // Greedy search for a simple system
            for (const cand of positiveNormCandidates) {
                if (system.length >= dimension) break;

                let isSimple = true;
                for (const root of system) {
                    if (innerProduct(cand, root, currentB) > 0) {
                        isSimple = false;
                        break;
                    }
                }
                if (isSimple) {
                    system.push(cand);
                }
            }
            return system;
        };

        // --- Event Listeners ---
        document.getElementById('add-dim').addEventListener('click', addDimension);
        document.getElementById('remove-dim').addEventListener('click', removeDimension);
        document.getElementById('calculate-btn').addEventListener('click', calculateSimpleSystem);

        // Initial render
        window.onload = renderMatrix;
    </script>

</body>

</html>