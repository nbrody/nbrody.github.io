<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Half-Space Intersection with Marching Cubes</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script type="module">  
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js';
    import { MarchingCubes } from 'https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/objects/MarchingCubes.js';

    // 1) Scene, Camera, Renderer
    const canvas   = document.getElementById('canvas');
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );
    camera.position.set( 5, 5, 5 );
    camera.lookAt( 0, 0, 0 );

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setPixelRatio( window.devicePixelRatio );

    // 2) Lights
    scene.add( new THREE.DirectionalLight( 0xffffff, 0.8 ).position.set( 1, 1, 1 ) );
    scene.add( new THREE.AmbientLight( 0x404040 ) );

    // 3) Marching Cubes parameters
    const resolution = 50;  // grid resolution
    const size       = 4;   // sampling box [-2,2] in x,y and [0,2] in z

    // map grid index to world coordinate
    function idxToCoord(i, N, min, max) {
      return min + ( i / (N - 1) ) * (max - min);
    }

    // 4) Create MarchingCubes mesh
    const material = new THREE.MeshStandardMaterial({
      color: 0x00cc88,
      side: THREE.DoubleSide,
      flatShading: false
    });
    const cubes = new MarchingCubes( resolution, material, true, true );
    cubes.isolation = 0;
    cubes.position.set( 0, 0, 0 );
    cubes.scale.set( size / 2, size / 2, size / 2 );
    scene.add( cubes );

    // 5) Fill scalar field
    function updateField() {
      const field = cubes.field;
      let ptr = 0;

      for ( let z = 0; z < resolution; z++ ) {
        const wz = idxToCoord( z, resolution, 0, 2 );
        for ( let y = 0; y < resolution; y++ ) {
          const wy = idxToCoord( y, resolution, -2, 2 );
          for ( let x = 0; x < resolution; x++ ) {
            const wx = idxToCoord( x, resolution, -2, 2 );

            // half-space functions
            const f1 = wx + 1;                   // x >= -1
            const f2 = 1 - wx;                   // x <=  1
            const f3 = wy + 1;                   // y >= -1
            const f4 = 1 - wy;                   // y <=  1
            const f5 = wz;                       // z >=  0
            const f6 = wx*wx + wy*wy + wz*wz - 1; // x^2 + y^2 + z^2 > 1

            field[ ptr++ ] = Math.min( f1, f2, f3, f4, f5, f6 );
          }
        }
      }
      cubes.reset();
      cubes.render();
    }

    // 6) Render loop
    function animate() {
      requestAnimationFrame( animate );
      updateField();
      renderer.render( scene, camera );
    }
    animate();

    // 7) Handle resize
    window.addEventListener( 'resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
    });
  </script>
</body>
</html>