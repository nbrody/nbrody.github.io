
import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
import { computeDelaunayNeighbors, imageOfBasepoint, hDist } from './dirichletUtils.js';
import { cMul, cAdd, cSub, cAbs, matInv2, matMul2, isIdentity2 } from './utils.js';

/**
 * Poincare Polyhedron Theorem Certifier
 * 
 * Verifies that the Dirichlet domain generated by a set of matrices satisfies
 * the conditions of the Poincare Polyhedron Theorem.
 */

export class PoincareCertifier {
    constructor(generators, wordLength = 3) {
        this.generators = generators;
        this.wordLength = wordLength;
        this.faces = [];
        this.vertices = [];
        this.edges = [];
        this.log = [];
    }

    addLog(msg) {
        this.log.push(msg);
        console.log(`[Certifier] ${msg}`);
    }

    async run() {
        this.addLog("Starting certification...");

        // 1. Generate candidate group elements
        this.addLog(`Generating group elements (depth ${this.wordLength})...`);
        // We need to import generateGroupElements or reimplement it. 
        // It's in dirichletUtils.js but not exported? Let's check.
        // It IS exported.
        const { generateGroupElements } = await import('./dirichletUtils.js');
        const elements = generateGroupElements(this.generators, this.wordLength);
        this.addLog(`Generated ${elements.length} candidate elements.`);

        // 2. Compute Dirichlet Domain Faces
        this.addLog("Computing Dirichlet domain faces...");
        const faceNeighbors = computeDelaunayNeighbors(elements);
        this.addLog(`Found ${faceNeighbors.length} potential faces.`);

        // 3. Convert neighbors to Bisector Spheres
        this.faces = faceNeighbors.map(n => {
            const sphere = this.bisectorToSphere(n.v); // n.v is the image of basepoint (0,0,1)
            return {
                g: n.g,
                word: n.word,
                image: n.v,
                sphere: sphere,
                id: n.word // unique ID
            };
        });

        // 4. Find Vertices (Intersection of triples of faces)
        this.addLog("Computing vertices (intersection of face triples)...");
        this.computeVertices();
        this.addLog(`Found ${this.vertices.length} vertices.`);

        // 5. Find Edges
        this.addLog("Computing edges...");
        this.computeEdges();
        this.addLog(`Found ${this.edges.length} edges.`);

        // 6. Verify Face Pairing
        this.addLog("Verifying face pairings...");
        const pairingResult = this.verifyFacePairing();
        if (!pairingResult.ok) {
            return { success: false, log: this.log, error: pairingResult.error };
        }

        // 7. Verify Edge Cycles
        this.addLog("Verifying edge cycles...");
        const cycleResult = this.verifyEdgeCycles();

        if (cycleResult.ok) {
            this.addLog("SUCCESS: Poincaré Polyhedron Theorem conditions satisfied!");
            return { success: true, log: this.log, details: cycleResult.details };
        } else {
            this.addLog("FAILURE: Edge cycle conditions not met.");
            return { success: false, log: this.log, error: cycleResult.error };
        }
    }

    // Convert bisector of (0,0,1) and p=(x,y,z) to a Sphere (center, radius) or Plane (normal, dist)
    bisectorToSphere(p) {
        const u = p.x;
        const v = p.y;
        const t = p.z;
        const pSq = u * u + v * v + t * t;

        if (Math.abs(t - 1.0) < 1e-9) {
            // Plane: 2ux + 2vy + (1 - |p|^2) = 0
            // Form: Ax + By = D
            return {
                type: 'plane',
                A: 2 * u,
                B: 2 * v,
                D: -(1 - pSq)
            };
        } else {
            // Sphere
            const factor = 1.0 / (t - 1.0);
            const cx = -u * factor;
            const cy = -v * factor;

            const term = (t - pSq) * factor;
            const rSq = cx * cx + cy * cy - term;

            return {
                type: 'sphere',
                cx: cx,
                cy: cy,
                rSq: rSq,
                K: rSq - cx * cx - cy * cy // K = r^2 - x^2 - y^2
            };
        }
    }

    computeVertices() {
        const n = this.faces.length;
        // Use a spatial hash or just brute force for now (N is small, < 100 usually)
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                for (let k = j + 1; k < n; k++) {
                    const pt = this.intersectThreeSurfaces(this.faces[i].sphere, this.faces[j].sphere, this.faces[k].sphere);
                    if (pt) {
                        // Check validity
                        if (this.isVertexValid(pt, [i, j, k])) {
                            // Deduplicate
                            let exists = false;
                            for (const v of this.vertices) {
                                if (v.point.distanceTo(pt) < 1e-4) {
                                    // Merge face indices
                                    if (!v.faces.includes(i)) v.faces.push(i);
                                    if (!v.faces.includes(j)) v.faces.push(j);
                                    if (!v.faces.includes(k)) v.faces.push(k);
                                    exists = true;
                                    break;
                                }
                            }
                            if (!exists) {
                                this.vertices.push({
                                    point: pt,
                                    faces: [i, j, k]
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    // Check if point p is in the Dirichlet domain (closer to o than to any other g(o))
    isVertexValid(p, ignoreIndices) {
        const d0 = hDist(new THREE.Vector3(0, 0, 1), p);
        // Check against all faces
        for (let i = 0; i < this.faces.length; i++) {
            if (ignoreIndices.includes(i)) continue; // On the boundary of these faces, so dist is equal
            const dFace = hDist(this.faces[i].image, p);
            if (dFace < d0 - 1e-4) return false; // Closer to another image -> outside domain
        }
        return true;
    }

    intersectThreeSurfaces(s1, s2, s3) {
        // Solve M v = b for v = [x, y, P]^T
        // Row for sphere: [-2cx, -2cy, 1] * v = K
        // Row for plane:  [A,    B,    0] * v = D

        const mat = [];
        const vec = [];

        for (const s of [s1, s2, s3]) {
            if (s.type === 'sphere') {
                mat.push([-2 * s.cx, -2 * s.cy, 1]);
                vec.push(s.K);
            } else {
                mat.push([s.A, s.B, 0]);
                vec.push(s.D);
            }
        }

        // Cramer's rule or Gaussian elimination for 3x3
        const det = this.det3x3(mat);
        if (Math.abs(det) < 1e-9) return null;

        const x = this.det3x3([
            [vec[0], mat[0][1], mat[0][2]],
            [vec[1], mat[1][1], mat[1][2]],
            [vec[2], mat[2][1], mat[2][2]]
        ]) / det;

        const y = this.det3x3([
            [mat[0][0], vec[0], mat[0][2]],
            [mat[1][0], vec[1], mat[1][2]],
            [mat[2][0], vec[2], mat[2][2]]
        ]) / det;

        const P = this.det3x3([
            [mat[0][0], mat[0][1], vec[0]],
            [mat[1][0], mat[1][1], vec[1]],
            [mat[2][0], mat[2][1], vec[2]]
        ]) / det;

        const zSq = P - x * x - y * y;
        if (zSq < -1e-9) return null;

        const z = Math.sqrt(Math.max(0, zSq));

        // If z is very small, it's an ideal vertex
        return new THREE.Vector3(x, y, z);
    }

    det3x3(m) {
        return m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
            m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
            m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
    }

    computeEdges() {
        // Edges connect vertices that share at least 2 faces
        // And the segment between them must be valid (on the intersection of those 2 faces)
        // For convex polyhedron, just connectivity is enough usually.

        for (let i = 0; i < this.vertices.length; i++) {
            for (let j = i + 1; j < this.vertices.length; j++) {
                const v1 = this.vertices[i];
                const v2 = this.vertices[j];

                // Find shared faces
                const shared = v1.faces.filter(f => v2.faces.includes(f));

                // An edge is defined by intersection of 2 faces (generically)
                // If they share 2 or more faces, they might be connected
                if (shared.length >= 2) {
                    // Check if they are actually adjacent on the 1-skeleton
                    // For each pair of shared faces, check if this edge exists
                    // A simple heuristic: if they share 2 faces, they form an edge
                    // UNLESS there's a vertex in between?
                    // Since we computed ALL vertices, if there was one in between, 
                    // we would have (v1, vMid) and (vMid, v2).
                    // So we just need to check if this is a "direct" connection.
                    // But for now, let's just collect all potential edges.
                    // We need to group them by the pair of faces they lie on.

                    // Iterate over all pairs of shared faces
                    for (let a = 0; a < shared.length; a++) {
                        for (let b = a + 1; b < shared.length; b++) {
                            const fA = shared[a];
                            const fB = shared[b];

                            // Check if this edge (fA, fB) is valid
                            // i.e. no other vertex lies on this edge between v1 and v2
                            // We can check midpoint
                            // Midpoint in hyperbolic space (geodesic)
                            // But for checking validity, Euclidean midpoint is often "okay" for convexity check
                            // if we check against all other faces.
                            // Better: check if any other vertex lies on the circle defined by fA, fB?

                            // Let's store it as a candidate.
                            // We need to link edges to form cycles.

                            this.edges.push({
                                v1: i,
                                v2: j,
                                f1: fA,
                                f2: fB
                            });
                        }
                    }
                }
            }
        }

        // Filter edges? 
        // We might have duplicates or invalid ones.
        // For a valid edge between v1 and v2 on faces fA, fB, 
        // there should be no other faces intersecting this segment.
    }

    verifyFacePairing() {
        const pairingMap = new Map(); // faceIndex -> inverseFaceIndex
        const missing = [];

        for (let i = 0; i < this.faces.length; i++) {
            const f = this.faces[i];
            const inv = f.g.inverse();
            if (!inv) {
                return { ok: false, error: `Element ${f.word} is not invertible.` };
            }

            // Find face corresponding to inv
            // We check if inv * basepoint is close to any face.image
            const invImg = imageOfBasepoint(inv);
            const invVec = new THREE.Vector3(invImg.u.re, invImg.u.im, invImg.t);

            let match = -1;
            for (let j = 0; j < this.faces.length; j++) {
                if (this.faces[j].image.distanceTo(invVec) < 1e-4) {
                    match = j;
                    break;
                }
            }

            if (match !== -1) {
                pairingMap.set(i, match);
            } else {
                missing.push(f.word);
            }
        }

        if (missing.length > 0) {
            return { ok: false, error: `Missing inverse faces for: ${missing.join(', ')}` };
        }

        this.pairingMap = pairingMap;
        return { ok: true };
    }

    verifyEdgeCycles() {
        const visitedEdges = new Set();
        const cycles = [];
        let allCyclesOk = true;
        let logDetails = "";

        // Helper to find edge containing a point
        const findEdge = (pt) => {
            for (let i = 0; i < this.edges.length; i++) {
                const e = this.edges[i];
                const v1 = this.vertices[e.v1].point;
                const v2 = this.vertices[e.v2].point;
                const mid = this.getGeodesicMidpoint(v1, v2);
                if (mid.distanceTo(pt) < 1e-3) return i;
            }
            return -1;
        };

        for (let i = 0; i < this.edges.length; i++) {
            if (visitedEdges.has(i)) continue;

            // Start new cycle
            let currentEdgeIdx = i;
            // We need to pick a direction to cross. An edge has 2 faces.
            // Let's pick f1 as the face to cross first.
            let currentFaceIdx = this.edges[currentEdgeIdx].f1;

            let totalAngle = 0;
            let cycleSteps = [];
            let cycleOk = true;
            let steps = 0;

            // We track (edgeIndex, faceIndexToCross)
            const startState = `${currentEdgeIdx}-${currentFaceIdx}`;

            do {
                visitedEdges.add(currentEdgeIdx);

                const e = this.edges[currentEdgeIdx];
                const angle = this.computeDihedralAngle(e.f1, e.f2);
                totalAngle += angle;

                // Log
                cycleSteps.push(`${this.faces[e.f1].word}∩${this.faces[e.f2].word}`);

                // 1. Get generator for the face we are crossing
                const g = this.faces[currentFaceIdx].g;
                const gInv = g.inverse();
                if (!gInv) { cycleOk = false; break; }

                // 2. Transform the edge to find the next one
                const v1 = this.vertices[e.v1].point;
                const v2 = this.vertices[e.v2].point;
                const mid = this.getGeodesicMidpoint(v1, v2);
                const nextMid = this.transformPoint(mid, gInv);

                // 3. Find which edge contains nextMid
                const nextEdgeIdx = findEdge(nextMid);
                if (nextEdgeIdx === -1) {
                    logDetails += `Cycle broken: could not find image of edge ${currentEdgeIdx} under ${this.faces[currentFaceIdx].word}^-1.\n`;
                    cycleOk = false;
                    break;
                }

                // 4. Determine the next face to cross
                // The new edge is on pairedFace (image of currentFace) and some other face.
                // We just arrived through pairedFace. We must leave through the OTHER face.
                const nextEdge = this.edges[nextEdgeIdx];
                const pairedFaceIdx = this.pairingMap.get(currentFaceIdx);

                if (nextEdge.f1 === pairedFaceIdx) {
                    currentFaceIdx = nextEdge.f2;
                } else if (nextEdge.f2 === pairedFaceIdx) {
                    currentFaceIdx = nextEdge.f1;
                } else {
                    logDetails += `Cycle logic error: next edge ${nextEdgeIdx} does not contain paired face ${pairedFaceIdx}.\n`;
                    cycleOk = false;
                    break;
                }

                currentEdgeIdx = nextEdgeIdx;
                steps++;

                // Check if closed
                if (`${currentEdgeIdx}-${currentFaceIdx}` === startState) break;
                if (steps > 50) {
                    logDetails += "Cycle too long, aborting.\n";
                    cycleOk = false;
                    break;
                }

            } while (true);

            if (cycleOk) {
                // Check angle sum
                const diff = Math.abs(totalAngle - 2 * Math.PI);
                // Also allow 2pi / k
                const k = Math.round(2 * Math.PI / totalAngle);
                const diffK = Math.abs(totalAngle * k - 2 * Math.PI);

                if (diff < 1e-3 || (k > 1 && diffK < 1e-3)) {
                    logDetails += `Cycle OK: ${cycleSteps.join(' -> ')} (Sum: ${(totalAngle * 180 / Math.PI).toFixed(1)}°)\n`;
                } else {
                    logDetails += `Cycle Angle Fail: ${cycleSteps.join(' -> ')} (Sum: ${(totalAngle * 180 / Math.PI).toFixed(1)}°, expected 360°)\n`;
                    allCyclesOk = false;
                }
            } else {
                allCyclesOk = false;
            }
        }

        return { ok: allCyclesOk, details: logDetails };
    }

    getGeodesicMidpoint(p1, p2) {
        // Euclidean midpoint is NOT geodesic midpoint, but for "contains" check it might be close enough
        // if segments are short.
        return p1.clone().add(p2).multiplyScalar(0.5);
    }

    transformPoint(p, m) {
        // Apply Mobius transformation m to point p in UHS
        const z = { re: p.x, im: p.y };
        const t = p.z;

        const a = m.a, b = m.b, c = m.c, d = m.d;

        const cz_d = c.mul(z).add(d);
        const cz_d_normSq = cz_d.normSq();
        const c_normSq = c.normSq();

        const denom = cz_d_normSq + c_normSq * t * t;
        if (denom === 0) return new THREE.Vector3(0, 0, 0); // Should not happen in UHS

        const invDenom = 1.0 / denom;

        const az_b = a.mul(z).add(b);
        const term1 = az_b.mul(cz_d.conjugate());
        const ac_conj = a.mul(c.conjugate());
        const term2 = { re: ac_conj.re * t * t, im: ac_conj.im * t * t };

        const num = term1.add(term2);

        const newZ = { re: num.re * invDenom, im: num.im * invDenom };
        const newT = t * invDenom;

        return new THREE.Vector3(newZ.re, newZ.im, newT);
    }

    computeDihedralAngle(i, j) {
        const s1 = this.faces[i].sphere;
        const s2 = this.faces[j].sphere;

        if (s1.type === 'plane' && s2.type === 'plane') {
            // N1 . N2
            const n1 = new THREE.Vector3(s1.A, s1.B, 0).normalize();
            const n2 = new THREE.Vector3(s2.A, s2.B, 0).normalize();
            return Math.PI - Math.acos(n1.dot(n2)); // Interior angle?
        } else if (s1.type === 'sphere' && s2.type === 'sphere') {
            const dSq = (s1.cx - s2.cx) ** 2 + (s1.cy - s2.cy) ** 2;
            const r1 = Math.sqrt(s1.rSq);
            const r2 = Math.sqrt(s2.rSq);
            const val = (s1.rSq + s2.rSq - dSq) / (2 * r1 * r2);
            return Math.acos(Math.max(-1, Math.min(1, val)));
        } else {
            // Sphere and Plane
            const sp = s1.type === 'sphere' ? s1 : s2;
            const pl = s1.type === 'plane' ? s1 : s2;

            // Dist = |A cx + B cy - D| / sqrt(A^2 + B^2)
            // Actually my plane eq is Ax + By = D. So Ax + By - D = 0.
            const num = Math.abs(pl.A * sp.cx + pl.B * sp.cy - pl.D);
            const den = Math.sqrt(pl.A * pl.A + pl.B * pl.B);
            const h = num / den;
            const r = Math.sqrt(sp.rSq);

            // cos(theta) = h / r
            return Math.acos(Math.max(-1, Math.min(1, h / r)));
        }
    }
}

