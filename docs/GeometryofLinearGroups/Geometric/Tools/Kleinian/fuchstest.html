<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dirichlet Tiling Viewer (H^2)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mathquill@0.10.1/build/mathquill.css">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathquill@0.10.1/build/mathquill.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      display: flex;
      font-family: sans-serif;
    }

    #canvas-container {
      flex-grow: 1;
      height: 100vh;
      background-color: #f8f9fa;
      position: relative;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Control panel */
    #controlPanel {
      position: relative;
      width: 340px;
      min-width: 340px;
      background: #ffffff;
      padding: 12px;
      font-size: 13px;
      z-index: 10;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.1);
      height: 100vh;
      overflow-y: auto;
    }

    #controlPanel h3 {
      margin: 4px 0 12px;
      font-size: 16px;
    }
    
    #controlPanel h4 {
        margin: 20px 0 8px;
        font-size: 14px;
        border-bottom: 1px solid #e5e7eb;
        padding-bottom: 4px;
    }

    .matrix-bracket {
      font-size: 48px;
      vertical-align: middle;
      margin: 0 4px;
      color: #4b5563;
    }

    .matrix-grid-inline {
      display: inline-grid;
      grid-template-columns: repeat(2, minmax(40px, auto));
      grid-gap: 4px;
      vertical-align: middle;
    }
    
    /* --- FIX: Added styles for MathQuill elements --- */
    .mq-matrix-input {
      border: 1px solid #d1d5db;
      border-radius: 4px;
      background-color: #f9fafb;
      min-width: 40px;
      min-height: 28px;
    }

    .mq-editable-field {
      padding: 2px 5px;
    }
    /* ------------------------------------------- */

    #controlPanel button {
      margin-top: 12px;
      width: 100%;
      padding: 6px;
    }

    .matrix-block {
      margin-bottom: 8px;
    }

    #message-box {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 12px;
      background: rgba(33, 150, 243, 0.15);
      color: #0b5394;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      display: none;
    }

    #message-box.error {
      background: rgba(244, 67, 54, 0.15);
      color: #b71c1c;
    }
  </style>
</head>

<body class="bg-gray-100">
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="message-box"></div>
  </div>

  <div id="controlPanel">
    <div style="display: flex; align-items: center; justify-content: space-between;">
      <h3 style="margin: 0;">Dirichlet Tiling in HÂ²</h3>
      <button id="saveImageBtn" title="Save image" style="width: 40px; margin: 0;">ðŸ“·</button>
    </div>

    <h4>Generators</h4>
    <div id="matrixInputs" style="margin-top: 12px;"></div>
    <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 12px;">
      <label for="wordLength" style="display:flex; align-items:center; margin:0;">
        <span style="margin-right:6px;">Word length:</span>
        <input id="wordLength" type="number" value="5" min="1" step="1" style="width:60px; padding: 4px; border: 1px solid #d1d5db; border-radius: 4px;" />
      </label>
      <button id="addMatrixBtn" style="width:32px; height:32px; padding:0; font-size:22px; line-height:1; font-weight:bold;">+</button>
    </div>

    <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 12px;">
      <label for="groupSelector" style="margin: 0;">Predefined group:</label>
      <select id="groupSelector" style="flex-grow: 1; margin: 0 6px; padding: 4px; border: 1px solid #d1d5db; border-radius: 4px;">
        <option value="">-- Select --</option>
      </select>
    </div>
    
    <button id="updateGroupBtn" style="margin-top: 16px;">Generate Tiling</button>

    <h4>Display Options</h4>
    <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
      <input id="toggleOrbit" type="checkbox" checked/>
      Show orbit of \(i\)
    </label>
    <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
      <input id="toggleTessellation" type="checkbox" checked/>
      Show full tessellation
    </label>
    <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
        Line width:
        <input id="lineWidthSlider" type="range" min="0.5" max="5" step="0.25" value="1.5" style="flex-grow:1;">
        <span id="lineWidthValue">1.5</span>
      </label>
  </div>

  <script>
    // --- Canvas and global state ---
    let canvas, ctx;
    let canvasWidth, canvasHeight;
    const basepoint = new Complex(0, 1); // Standard basepoint z = i in H^2
    let generators = [];
    let transform = { scale: 150, tx: 0, ty: 300 }; // Pan/zoom state

    // --- Math classes for H^2 geometry ---
    class Complex {
      constructor(re = 0, im = 0) { this.re = re; this.im = im; }
      add(z) { return new Complex(this.re + z.re, this.im + z.im); }
      sub(z) { return new Complex(this.re - z.re, this.im + z.im); }
      mul(z) { return new Complex(this.re * z.re - this.im * z.im, this.re * z.im + this.im * z.re); }
      div(z) {
        const denom = z.re * z.re + z.im * z.im;
        if (denom === 0) return new Complex(Infinity, Infinity);
        return new Complex((this.re * z.re + this.im * z.im) / denom, (this.im * z.re - this.re * z.im) / denom);
      }
      normSq() { return this.re * this.re + this.im * this.im; }
      abs() { return Math.sqrt(this.normSq()); }
    }

    class Matrix2 {
      constructor(a, b, c, d) {
        this.a = a; this.b = b; this.c = c; this.d = d;
      }
      multiply(m) {
        return new Matrix2(
          this.a * m.a + this.b * m.c, this.a * m.b + this.b * m.d,
          this.c * m.a + this.d * m.c, this.c * m.b + this.d * m.d
        );
      }
      inverse() {
        const det = this.a * this.d - this.b * this.c;
        if (Math.abs(det) < 1e-9) return null;
        const invDet = 1.0 / det;
        return new Matrix2(
          this.d * invDet, -this.b * invDet, -this.c * invDet, this.a * invDet
        );
      }
      isIdentity() {
          return Math.abs(this.a - 1) < 1e-9 && Math.abs(this.b) < 1e-9 &&
                 Math.abs(this.c) < 1e-9 && Math.abs(this.d - 1) < 1e-9;
      }
      apply(z) {
        const cz_d = new Complex(this.c * z.re + this.d, this.c * z.im);
        const az_b = new Complex(this.a * z.re + this.b, this.a * z.im);
        return az_b.div(cz_d);
      }
    }

    function hDist(z1, z2) {
      if (z1.im <= 0 || z2.im <= 0) return Infinity;
      const num = (z1.re - z2.re) ** 2 + (z1.im - z2.im) ** 2;
      const den = 2 * z1.im * z2.im;
      return Math.acosh(1 + num / den);
    }

    // --- Group generation ---
    const KEY_SCALE = 1e6;
    function keyFromMatrix(m) {
        let sign = 1.0;
        const entries = [m.a, m.b, m.c, m.d];
        for(const entry of entries) {
            if (Math.abs(entry) > 1e-9) {
                if (entry < 0) sign = -1.0;
                break;
            }
        }
        const parts = entries.map(v => Math.round(v * sign * KEY_SCALE));
        return parts.join(';');
    }
    
    function generateGroupElements(gens, wordLength) {
      const elements = new Map();
      const I = new Matrix2(1, 0, 0, 1);
      elements.set(keyFromMatrix(I), I);

      const invGens = gens.map(g => g.inverse()).filter(Boolean);
      const initialSet = [...gens, ...invGens];
      
      let queue = [I];
      for (let l = 0; l < wordLength; l++) {
        const nextQueue = [];
        for (const word of queue) {
          for (const g of initialSet) {
            const newWord = word.multiply(g);
            const key = keyFromMatrix(newWord);
            if (!elements.has(key)) {
              elements.set(key, newWord);
              nextQueue.push(newWord);
            }
          }
        }
        if (nextQueue.length === 0) break;
        queue = nextQueue;
      }
      return Array.from(elements.values());
    }

    // --- UI Logic ---
    const messageBox = document.getElementById('message-box');
    function showMessage(message, isError = false) {
      messageBox.textContent = message;
      messageBox.className = isError ? 'error' : '';
      messageBox.style.display = 'block';
      clearTimeout(showMessage._t);
      showMessage._t = setTimeout(() => { messageBox.style.display = 'none'; }, 4000);
    }
    
    function typesetMath() {
      if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise([document.getElementById('controlPanel')]).catch(() => {});
      }
    }

    function latexToExpr(latex) {
      return String(latex || '0')
        .replace(/\\frac\{(.+?)\}\{(.+?)\}/g, '($1)/($2)')
        .replace(/\\sqrt\{(.+?)\}/g, 'sqrt($1)')
        .replace(/\\pi/g, 'pi')
        .replace(/\\(cos|sin|tan)\((.+?)\)/g, '$1($2)');
    }

    function evalRealExpression(expr) {
        try {
            const val = math.evaluate(expr);
            if (typeof val === 'number') return val;
            if (val && typeof val.toNumber === 'function') return val.toNumber();
            return NaN;
        } catch (e) {
            return NaN;
        }
    }
    
    function addMatrixInput(values = ['1', '0', '0', '1']) {
      const idx = document.querySelectorAll('#matrixInputs .matrix-block').length;
      const container = document.createElement('div');
      container.className = 'matrix-block';
      container.innerHTML = `
            <div style="display:flex;align-items:center;">
              <label style="flex-grow:1;">
                <span class="matrix-label">\\( g_{${idx + 1}} = \\)</span>
                <span class="matrix-bracket">(</span>
                <span class="matrix-grid-inline">
                    <span class="mq-matrix-input"></span><span class="mq-matrix-input"></span>
                    <span class="mq-matrix-input"></span><span class="mq-matrix-input"></span>
                </span>
                <span class="matrix-bracket">)</span>
              </label>
              <button class="delete-matrix-btn" style="margin-left:8px;width:26px;height:30px;">âœ–</button>
            </div>`;
      container.querySelector('.delete-matrix-btn').addEventListener('click', () => {
        container.remove();
        document.querySelectorAll('#matrixInputs .matrix-label').forEach((lbl, i) => { 
            lbl.innerHTML = `\\( g_{${i + 1}} = \\)`;
        });
        typesetMath();
      });
      document.getElementById('matrixInputs').appendChild(container);
      
      // FIX: Initialize with jQuery, which is the standard MathQuill practice
      $(container).find('.mq-matrix-input').each(function(i) {
          const initialValue = values[i] || '0';
          $(this).mathquill('editable').mathquill('latex', initialValue);
      });

      typesetMath();
    }

    function rebuildGeneratorsFromUI() {
      generators.length = 0;
      const blocks = document.querySelectorAll('#matrixInputs .matrix-block');
      for (const block of blocks) {
        const spans = block.querySelectorAll('.mq-matrix-input');
        // FIX: Use jQuery to get latex content
        const vals = Array.from(spans).map(s => {
            const latex = $(s).mathquill('latex');
            return evalRealExpression(latexToExpr(latex));
        });
        if (vals.some(isNaN)) {
            showMessage('Invalid real number in matrix input. Skipping.', true);
            continue;
        }
        const [a, b, c, d] = vals;
        const det = a * d - b * c;
        if (Math.abs(det) < 1e-9) {
          showMessage('Matrix skipped: determinant is zero.', true);
          continue;
        }
        const sqrtDet = Math.sqrt(Math.abs(det));
        generators.push(new Matrix2(a / sqrtDet, b / sqrtDet, c / sqrtDet, d / sqrtDet));
      }
    }
    
    const exampleLibrary = [
      { name: 'Modular Group', mats: [['1', '1', '0', '1'], ['0', '-1', '1', '0']] },
      { name: 'Hecke Group H(4)', mats: [['1', '\\sqrt{2}', '0', '1'], ['0', '-1', '1', '0']] },
      { name: 'Hecke Group H(5)', mats: [['1', '2\\cos(\\pi/5)', '0', '1'], ['0', '-1', '1', '0']] },
      { name: 'Genus 2 Surface Group', mats: [
          ['1.827', '2.508', '1.307', '1.827'], ['-0.453', '0.749', '-1.231', '-0.453'],
          ['3.325', '-4.425', '-2.508', '3.325'], ['0.279', '0.505', '0.301', '0.279']
      ]}
    ];

    function setExample(example) {
      document.getElementById('matrixInputs').innerHTML = '';
      example.forEach(vals => addMatrixInput(vals));
      typesetMath();
    }
    
    function setupPanelUI() {
      document.getElementById('addMatrixBtn').addEventListener('click', () => addMatrixInput());
      document.getElementById('updateGroupBtn').addEventListener('click', generateAndDraw);
      document.getElementById('saveImageBtn').addEventListener('click', () => {
          const link = document.createElement('a');
          link.download = 'dirichlet-tiling.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
      });
      
      const groupSel = document.getElementById('groupSelector');
      exampleLibrary.forEach((ex, idx) => {
        const opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = ex.name;
        groupSel.appendChild(opt);
      });
      groupSel.addEventListener('change', (e) => {
        const idx = parseInt(e.target.value, 10);
        if (!isNaN(idx) && exampleLibrary[idx]) {
          setExample(exampleLibrary[idx].mats);
          generateAndDraw();
        }
      });
      
      document.getElementById('toggleOrbit').addEventListener('change', generateAndDraw);
      document.getElementById('toggleTessellation').addEventListener('change', generateAndDraw);
      
      const lwSlider = document.getElementById('lineWidthSlider');
      lwSlider.addEventListener('input', () => {
        document.getElementById('lineWidthValue').textContent = lwSlider.value;
        generateAndDraw();
      });
    }

    // --- Drawing Logic ---
    function worldToScreen(z) {
      return {
        x: canvasWidth / 2 + transform.tx + z.re * transform.scale,
        y: canvasHeight - transform.ty - z.im * transform.scale
      };
    }
    
    function drawGeodesicBisector(p, q, color) {
        ctx.strokeStyle = color;
        ctx.beginPath();
        
        // If real parts are nearly equal, it's a vertical line
        if (Math.abs(p.re - q.re) < 1e-9 && Math.abs(p.im - q.im) < 1e-9) return;
        if (Math.abs(p.re - q.re) < 1e-9) {
             const screen_x = worldToScreen(p).x;
             ctx.moveTo(screen_x, 0);
             ctx.lineTo(screen_x, canvasHeight);
        } else {
            // It's a semicircle with center on the real axis
            const c = (q.normSq() - p.normSq()) / (2 * (q.re - p.re));
            const r2 = p.normSq() - 2 * c * p.re + c * c;
            if (r2 < 0) return;
            const r = Math.sqrt(r2);
            
            const centerScreen = worldToScreen({ re: c, im: 0 });
            ctx.arc(centerScreen.x, centerScreen.y, r * transform.scale, Math.PI, 2 * Math.PI);
        }
        ctx.stroke();
    }

    function computeDelaunayNeighbors(groupElements) {
        const orbit = groupElements.map(g => ({ g, p: g.apply(basepoint) }));
        return orbit.filter(item => {
            if (item.g.isIdentity()) return false;
            const dist_i_p = hDist(basepoint, item.p);
            for (const other of orbit) {
                if (keyFromMatrix(other.g) === keyFromMatrix(item.g)) continue;
                if (hDist(other.p, item.p) < dist_i_p - 1e-6) return false;
            }
            return true;
        }).map(item => item.g);
    }

    function generateAndDraw() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      const axisY = worldToScreen({re: 0, im: 0}).y;
      ctx.moveTo(0, axisY);
      ctx.lineTo(canvasWidth, axisY);
      ctx.stroke();
      
      rebuildGeneratorsFromUI();
      if (generators.length === 0) {
        showMessage('No valid generators. Please define at least one invertible real matrix.', true);
        return;
      }

      const wordLength = parseInt(document.getElementById('wordLength').value) || 4;
      const groupElements = generateGroupElements(generators, wordLength);
      const neighbors = computeDelaunayNeighbors(groupElements);

      ctx.lineWidth = parseFloat(document.getElementById('lineWidthSlider').value);
      
      ctx.save();
      ctx.rect(0, 0, canvasWidth, axisY);
      ctx.clip();
      
      neighbors.forEach((g, i) => {
          const hue = (i / neighbors.length) * 360;
          const color = `hsl(${hue}, 80%, 40%)`;
          
          const fundamentalWallPt = g.apply(basepoint);

          if (document.getElementById('toggleTessellation').checked) {
              groupElements.forEach(h => {
                const p1 = h.apply(basepoint);
                const p2 = h.apply(fundamentalWallPt);
                drawGeodesicBisector(p1, p2, color);
              });
          } else {
             drawGeodesicBisector(basepoint, fundamentalWallPt, color);
          }
      });
      ctx.restore();

      if (document.getElementById('toggleOrbit').checked) {
        ctx.fillStyle = '#333';
        groupElements.forEach(g => {
          const p = g.apply(basepoint);
          const s = worldToScreen(p);
          if (s.y < axisY) {
             ctx.beginPath();
             ctx.arc(s.x, s.y, 3, 0, 2 * Math.PI);
             ctx.fill();
          }
        });
      }
    }
    
    function init() {
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');
      const container = document.getElementById('canvas-container');

      function resizeCanvas() {
        canvasWidth = container.clientWidth;
        canvasHeight = container.clientHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        transform.tx = 0;
        transform.ty = canvasHeight * 0.6;
        transform.scale = canvasWidth / 4;
        generateAndDraw();
      }
      
      window.addEventListener('resize', resizeCanvas);
      
      setupPanelUI();
      
      let isDragging = false;
      let lastX, lastY;
      canvas.addEventListener('mousedown', (e) => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
      canvas.addEventListener('mousemove', (e) => {
          if (isDragging) {
              transform.tx += e.clientX - lastX;
              transform.ty -= e.clientY - lastY;
              lastX = e.clientX; lastY = e.clientY;
              generateAndDraw();
          }
      });
      canvas.addEventListener('mouseup', () => { isDragging = false; });
      canvas.addEventListener('mouseleave', () => { isDragging = false; });
      canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const scaleFactor = e.deltaY < 0 ? 1.1 : 1/1.1;
          transform.scale *= scaleFactor;
          generateAndDraw();
      });

      // Set default example and draw
      setExample(exampleLibrary[0].mats);
      resizeCanvas();
    }

    // Use jQuery's document ready to ensure all elements including MathQuill are loaded
    $(function() {
        init();
    });
  </script>
</body>

</html>