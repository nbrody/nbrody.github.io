<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riley Slice Explorer</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 15px;
            background-color: #fdfdfd;
        }

        h1,
        h2 {
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            color: #1a1a1a;
        }

        .container {
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            margin-bottom: 20px;
        }

        .image-container {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }

        .placeholder-text {
            color: #6c757d;
            font-style: italic;
        }

        .info-box {
            background-color: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .info-box h3 {
            margin-top: 0;
            color: #004085;
        }

        .input-group {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .input-group label {
            font-weight: 600;
            min-width: 120px;
        }

        .rational-input {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
        }

        .rational-input input {
            width: 80px;
            padding: 8px;
            font-size: 16px;
            border: 1px solid #ccc;
            text-align: center;
        }

        .rational-input input:first-child {
            border-bottom: none;
            border-radius: 4px 4px 0 0;
        }

        .rational-input input:last-child {
            border-top: 2px solid #333;
            border-radius: 0 0 4px 4px;
        }

        #calculateButton {
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        #calculateButton:hover {
            background-color: #0056b3;
        }

        #results {
            margin-top: 20px;
        }

        .polynomial-display {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            margin: 15px 0;
        }

        .polynomial-display h3 {
            margin-top: 0;
            color: #495057;
        }

        .polynomial {
            font-size: 18px;
            color: #212529;
            padding: 10px;
            background-color: white;
            border-radius: 4px;
            overflow-x: auto;
            text-align: center;
        }

        code {
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        .error {
            color: #d9534f;
            font-weight: bold;
            padding: 10px;
            background-color: #f8d7da;
            border-radius: 4px;
        }

        .computation-steps {
            margin-top: 20px;
            padding: 15px;
            background-color: #f1f3f5;
            border-radius: 4px;
        }

        .computation-steps h4 {
            margin-top: 0;
        }

        .step {
            margin: 10px 0;
            padding-left: 15px;
            border-left: 3px solid #007bff;
        }

        canvas {
            border: 1px solid #dee2e6;
            border-radius: 4px;
            display: block;
            margin: 20px auto;
            background-color: #fff;
            cursor: crosshair;
        }

        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }

        .legend {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Riley Slice Explorer</h1>

        <div class="info-box">
            <h3>Convention</h3>
            <p>This tool explores the Riley slice using the generators:</p>
            <ul>
                <li><strong>A</strong> = \(\begin{pmatrix}1 & z \\ 0 & 1\end{pmatrix}\) (parabolic element)</li>
                <li><strong>B</strong> = \(\begin{pmatrix}0 & -1 \\ 1 & 0\end{pmatrix}\) (elliptic element of order 4)</li>
            </ul>
            <p>For each rational number \(p/q\), we compute the associated Riley polynomial \(Q(p/q)\).</p>
        </div>

        <div class="image-container">
            <p class="placeholder-text">Riley Slice Visualization</p>
            <p class="placeholder-text" style="font-size: 14px;">(Place your Riley slice image here: riley_slice.png)</p>
        </div>
    </div>

    <div class="container">
        <h2>Polynomial Calculator</h2>
        <p>Enter a rational number to compute its corresponding Riley polynomial:</p>

        <div class="input-group">
            <label for="numerator">Rational Number:</label>
            <div class="rational-input">
                <input type="number" id="numerator" value="3" min="0">
                <input type="number" id="denominator" value="5" min="1">
            </div>
            <button id="calculateButton">Calculate Polynomial</button>
        </div>

        <div id="results"></div>
    </div>

    <div class="container">
        <h2>Real Locus Visualization</h2>
        <p>The plot below shows the set of complex numbers \(z\) where \(Q(p/q)(z)\) is real (i.e., \(\text{Im}(Q(p/q)(z)) = 0\)) in the region \([-3, 3] \times [-3, 3]\).</p>

        <div class="canvas-container">
            <canvas id="rileyCanvas" width="600" height="600"></canvas>
        </div>

        <div class="legend">
            <strong>Legend:</strong>
            <span style="color: #007bff;">■</span> Blue curves show where \(Q(p/q)(z)\) is real (\(\text{Im}(Q(z)) = 0\)).
            <span style="color: #dc3545;">●</span> Red dots show the roots of \(Q(p/q)(z) + 2\).
            The axes show the real and imaginary parts of \(z\).
        </div>
    </div>

    <script>
        // Polynomial class for operations
        class Polynomial {
            constructor(coeffs) {
                // coeffs[i] is coefficient of z^i
                this.coeffs = coeffs.slice();
                this.trim();
            }

            trim() {
                while (this.coeffs.length > 1 && Math.abs(this.coeffs[this.coeffs.length - 1]) < 1e-10) {
                    this.coeffs.pop();
                }
                if (this.coeffs.length === 0) {
                    this.coeffs = [0];
                }
            }

            static fromConstant(c) {
                return new Polynomial([c]);
            }

            add(other) {
                const maxLen = Math.max(this.coeffs.length, other.coeffs.length);
                const result = new Array(maxLen).fill(0);
                for (let i = 0; i < this.coeffs.length; i++) {
                    result[i] += this.coeffs[i];
                }
                for (let i = 0; i < other.coeffs.length; i++) {
                    result[i] += other.coeffs[i];
                }
                return new Polynomial(result);
            }

            subtract(other) {
                const maxLen = Math.max(this.coeffs.length, other.coeffs.length);
                const result = new Array(maxLen).fill(0);
                for (let i = 0; i < this.coeffs.length; i++) {
                    result[i] += this.coeffs[i];
                }
                for (let i = 0; i < other.coeffs.length; i++) {
                    result[i] -= other.coeffs[i];
                }
                return new Polynomial(result);
            }

            multiply(other) {
                const result = new Array(this.coeffs.length + other.coeffs.length - 1).fill(0);
                for (let i = 0; i < this.coeffs.length; i++) {
                    for (let j = 0; j < other.coeffs.length; j++) {
                        result[i + j] += this.coeffs[i] * other.coeffs[j];
                    }
                }
                return new Polynomial(result);
            }

            toString() {
                const terms = [];
                for (let i = this.coeffs.length - 1; i >= 0; i--) {
                    const coeff = this.coeffs[i];
                    if (Math.abs(coeff) < 1e-10) continue;

                    let term = '';
                    const absCoeff = Math.abs(coeff);

                    if (i === 0) {
                        term = absCoeff.toString();
                    } else if (i === 1) {
                        if (absCoeff === 1) {
                            term = 'z';
                        } else {
                            term = `${absCoeff}z`;
                        }
                    } else {
                        if (absCoeff === 1) {
                            term = `z^${i}`;
                        } else {
                            term = `${absCoeff}z^${i}`;
                        }
                    }

                    if (coeff < 0) {
                        term = terms.length > 0 ? `- ${term}` : `-${term}`;
                    } else if (terms.length > 0) {
                        term = `+ ${term}`;
                    }

                    terms.push(term);
                }
                return terms.length > 0 ? terms.join(' ') : '0';
            }

            // Convert to LaTeX format for MathJax
            toLatex() {
                const terms = [];
                for (let i = this.coeffs.length - 1; i >= 0; i--) {
                    const coeff = this.coeffs[i];
                    if (Math.abs(coeff) < 1e-10) continue;

                    let term = '';
                    const absCoeff = Math.abs(coeff);

                    if (i === 0) {
                        term = absCoeff.toString();
                    } else if (i === 1) {
                        if (absCoeff === 1) {
                            term = 'z';
                        } else {
                            term = `${absCoeff}z`;
                        }
                    } else {
                        if (absCoeff === 1) {
                            term = `z^{${i}}`;
                        } else {
                            term = `${absCoeff}z^{${i}}`;
                        }
                    }

                    if (coeff < 0) {
                        term = terms.length > 0 ? `- ${term}` : `-${term}`;
                    } else if (terms.length > 0) {
                        term = `+ ${term}`;
                    }

                    terms.push(term);
                }
                return terms.length > 0 ? terms.join(' ') : '0';
            }

            // Evaluate polynomial at complex number z = re + im*i
            evaluateComplex(re, im) {
                let resultRe = 0;
                let resultIm = 0;
                let powerRe = 1;
                let powerIm = 0;

                for (let i = 0; i < this.coeffs.length; i++) {
                    // Add coeff * power to result
                    resultRe += this.coeffs[i] * powerRe;
                    resultIm += this.coeffs[i] * powerIm;

                    // Multiply power by z
                    const newPowerRe = powerRe * re - powerIm * im;
                    const newPowerIm = powerRe * im + powerIm * re;
                    powerRe = newPowerRe;
                    powerIm = newPowerIm;
                }

                return { re: resultRe, im: resultIm };
            }

            // Find roots using Durand-Kerner method
            findRoots() {
                const degree = this.coeffs.length - 1;
                if (degree < 1) return [];

                // Normalize polynomial (make it monic)
                const leadCoeff = this.coeffs[degree];
                if (Math.abs(leadCoeff) < 1e-10) return [];

                const p = this.coeffs.map(c => c / leadCoeff);

                // Special cases
                if (degree === 1) {
                    return [{ re: -p[0], im: 0 }];
                }
                if (degree === 2) {
                    const a = 1;
                    const b = p[0];
                    const c = p[1];
                    const discriminant = b * b - 4 * a * c;
                    if (discriminant >= 0) {
                        return [
                            { re: (-b + Math.sqrt(discriminant)) / (2 * a), im: 0 },
                            { re: (-b - Math.sqrt(discriminant)) / (2 * a), im: 0 }
                        ];
                    } else {
                        const sqrtDisc = Math.sqrt(-discriminant);
                        return [
                            { re: -b / (2 * a), im: sqrtDisc / (2 * a) },
                            { re: -b / (2 * a), im: -sqrtDisc / (2 * a) }
                        ];
                    }
                }

                // Durand-Kerner method for higher degrees
                let roots = [];
                const r = 0.4 + 0.9;
                for (let i = 0; i < degree; i++) {
                    const angle = (2 * Math.PI * i) / degree;
                    roots.push({
                        re: Math.cos(angle),
                        im: Math.sin(angle)
                    });
                }

                const MAX_ITER = 100;
                const TOLERANCE = 1e-9;

                for (let iter = 0; iter < MAX_ITER; iter++) {
                    let maxChange = 0;
                    const newRoots = roots.map(root => ({ ...root }));

                    for (let i = 0; i < degree; i++) {
                        // Evaluate polynomial at roots[i]
                        let p_val = this.evaluateComplex(roots[i].re, roots[i].im);

                        // Compute denominator: product of (roots[i] - roots[j]) for j != i
                        let denominator = { re: 1, im: 0 };
                        for (let j = 0; j < degree; j++) {
                            if (i === j) continue;
                            const diff = {
                                re: roots[i].re - roots[j].re,
                                im: roots[i].im - roots[j].im
                            };
                            const newDenom = {
                                re: denominator.re * diff.re - denominator.im * diff.im,
                                im: denominator.re * diff.im + denominator.im * diff.re
                            };
                            denominator = newDenom;
                        }

                        // Divide p_val by denominator
                        const den_mag_sq = denominator.re * denominator.re + denominator.im * denominator.im;
                        if (den_mag_sq < 1e-15) continue;

                        const correction = {
                            re: (p_val.re * denominator.re + p_val.im * denominator.im) / den_mag_sq,
                            im: (p_val.im * denominator.re - p_val.re * denominator.im) / den_mag_sq
                        };

                        newRoots[i].re -= correction.re;
                        newRoots[i].im -= correction.im;

                        const change = correction.re * correction.re + correction.im * correction.im;
                        if (change > maxChange) maxChange = change;
                    }

                    roots = newRoots;
                    if (Math.sqrt(maxChange) < TOLERANCE) break;
                }

                return roots;
            }
        }

        // GCD function
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        // Reduce fraction to lowest terms
        function reduceFraction(p, q) {
            const g = gcd(p, q);
            return { p: p / g, q: q / g };
        }

        // Check if two fractions are Farey neighbors
        function areFareyNeighbors(p1, q1, p2, q2) {
            return Math.abs(p2 * q1 - p1 * q2) === 1;
        }

        // Riley polynomial computation using Farey tree recursion
        const polynomialCache = new Map();

        function getRileyPolynomial(p, q) {
            const key = `${p}/${q}`;
            if (polynomialCache.has(key)) {
                return polynomialCache.get(key);
            }

            // Base cases
            if (p === 0 && q === 1) {
                const poly = new Polynomial([2, 0, -1]); // 2 - z^2
                polynomialCache.set(key, poly);
                return poly;
            }
            if (p === 1 && q === 1) {
                const poly = new Polynomial([2, 0, 1]); // 2 + z^2
                polynomialCache.set(key, poly);
                return poly;
            }
            if (p === 1 && q === 2) {
                const poly = new Polynomial([2, 0, 0, 0, 1]); // 2 + z^4
                polynomialCache.set(key, poly);
                return poly;
            }

            // Try to find Farey neighbors and compute using recursion
            // Generate fractions with smaller denominators
            const fractions = [];
            for (let denom = 1; denom < q; denom++) {
                for (let num = 0; num <= denom; num++) {
                    if (gcd(num, denom) === 1) {
                        fractions.push({ p: num, q: denom });
                    }
                }
            }

            // Look for Farey neighbors whose mediant is p/q
            for (let i = 0; i < fractions.length; i++) {
                for (let j = i + 1; j < fractions.length; j++) {
                    const f1 = fractions[i];
                    const f2 = fractions[j];

                    // Check if they are Farey neighbors
                    if (!areFareyNeighbors(f1.p, f1.q, f2.p, f2.q)) continue;

                    // Check if mediant equals our target
                    const mp = f1.p + f2.p;
                    const mq = f1.q + f2.q;
                    const reduced = reduceFraction(mp, mq);

                    if (reduced.p === p && reduced.q === q) {
                        // Found the right pair! Use recursion formula:
                        // Q(p/q) = 8 - Q(a/c) * Q(b/d) - Q((b-a)/(d-c))
                        const Q1 = getRileyPolynomial(f1.p, f1.q);
                        const Q2 = getRileyPolynomial(f2.p, f2.q);

                        const diffP = Math.abs(f2.p - f1.p);
                        const diffQ = Math.abs(f2.q - f1.q);
                        const diffReduced = reduceFraction(diffP, diffQ);
                        const Q3 = getRileyPolynomial(diffReduced.p, diffReduced.q);

                        const product = Q1.multiply(Q2);
                        const sum = product.add(Q3);
                        const result = Polynomial.fromConstant(8).subtract(sum);

                        polynomialCache.set(key, result);
                        return result;
                    }
                }
            }

            // If we couldn't compute it, return null
            return null;
        }

        // Event handlers
        document.getElementById('calculateButton').addEventListener('click', () => {
            const p = parseInt(document.getElementById('numerator').value);
            const q = parseInt(document.getElementById('denominator').value);
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';

            if (isNaN(p) || isNaN(q) || q <= 0 || p < 0) {
                resultsDiv.innerHTML = '<p class="error">Please enter valid non-negative integers with q > 0.</p>';
                return;
            }

            const reduced = reduceFraction(p, q);
            const poly = getRileyPolynomial(reduced.p, reduced.q);

            if (poly === null) {
                resultsDiv.innerHTML = `<p class="error">Could not compute polynomial for ${reduced.p}/${reduced.q}. The recursion may require additional base cases or a higher iteration limit.</p>`;
                return;
            }

            let html = '<div class="polynomial-display">';
            html += `<h3>Riley Polynomial \\(Q\\left(\\frac{${reduced.p}}{${reduced.q}}\\right)\\)</h3>`;
            html += `<div class="polynomial">\\[${poly.toLatex()}\\]</div>`;

            if (p !== reduced.p || q !== reduced.q) {
                html += `<p style="margin-top: 10px; color: #6c757d; font-size: 14px;">Note: Reduced from ${p}/${q} to ${reduced.p}/${reduced.q}</p>`;
            }

            html += '</div>';

            // Show degree and coefficients
            html += '<div class="computation-steps">';
            html += '<h4>Polynomial Details</h4>';
            html += `<p><strong>Degree:</strong> ${poly.coeffs.length - 1}</p>`;
            html += `<p><strong>Coefficients</strong> (from \\(z^0\\) to \\(z^{${poly.coeffs.length - 1}}\\)):</p>`;
            html += '<p style="font-family: monospace;">[' + poly.coeffs.join(', ') + ']</p>';

            // Show roots of Q + 2
            const polyPlus2 = poly.add(Polynomial.fromConstant(2));
            const roots = polyPlus2.findRoots();
            if (roots.length > 0) {
                html += `<h4 style="margin-top: 15px;">Roots of \\(Q\\left(\\frac{${reduced.p}}{${reduced.q}}\\right) + 2\\)</h4>`;
                html += '<ul style="font-size: 14px; list-style: none; padding-left: 0;">';
                roots.forEach((root, i) => {
                    const re = root.re.toFixed(4);
                    const im = Math.abs(root.im).toFixed(4);
                    const sign = root.im >= 0 ? '+' : '-';
                    const rootStr = Math.abs(root.im) < 1e-6
                        ? `${re}`
                        : `${re} ${sign} ${im}i`;
                    html += `<li>\\(z_{${i + 1}} = ${rootStr}\\)</li>`;
                });
                html += '</ul>';
            }

            html += '</div>';

            resultsDiv.innerHTML = html;

            // Typeset the MathJax content
            if (window.MathJax) {
                MathJax.typesetPromise([resultsDiv]).catch((err) => console.log('MathJax typeset error:', err));
            }
        });

        // Trigger calculation on Enter key
        document.getElementById('numerator').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('calculateButton').click();
        });
        document.getElementById('denominator').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('calculateButton').click();
        });

        // Initial calculation on load
        document.getElementById('calculateButton').click();

        // ============ Canvas Plotting Code ============

        const canvas = document.getElementById('rileyCanvas');
        const ctx = canvas.getContext('2d');
        let currentPolynomial = null;

        function plotRealLocus() {
            const p = parseInt(document.getElementById('numerator').value);
            const q = parseInt(document.getElementById('denominator').value);
            const xMin = -3;
            const xMax = 3;
            const yMin = -3;
            const yMax = 3;

            if (isNaN(p) || isNaN(q) || q <= 0 || p < 0) {
                alert('Please calculate a valid polynomial first!');
                return;
            }

            const reduced = reduceFraction(p, q);
            currentPolynomial = getRileyPolynomial(reduced.p, reduced.q);

            if (!currentPolynomial) {
                alert('Could not compute polynomial for this fraction.');
                return;
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            drawAxes(xMin, xMax, yMin, yMax);

            // Plot the real locus (where Im(Q(z)) = 0)
            plotImplicitCurve(currentPolynomial, xMin, xMax, yMin, yMax);

            // Find and plot roots of Q + 2
            const polyPlus2 = currentPolynomial.add(Polynomial.fromConstant(2));
            const roots = polyPlus2.findRoots();
            plotRoots(roots, xMin, xMax, yMin, yMax);
        }

        function drawAxes(xMin, xMax, yMin, yMax) {
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;

            // X-axis
            const yZero = mapY(0, yMin, yMax);
            ctx.beginPath();
            ctx.moveTo(0, yZero);
            ctx.lineTo(canvas.width, yZero);
            ctx.stroke();

            // Y-axis
            const xZero = mapX(0, xMin, xMax);
            ctx.beginPath();
            ctx.moveTo(xZero, 0);
            ctx.lineTo(xZero, canvas.height);
            ctx.stroke();

            // Add labels
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText('Re(z)', canvas.width - 40, yZero - 5);
            ctx.fillText('Im(z)', xZero + 5, 15);

            // Draw tick marks
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.5;
            for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x++) {
                if (x === 0) continue;
                const px = mapX(x, xMin, xMax);
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, canvas.height);
                ctx.stroke();
                ctx.fillText(x.toString(), px - 5, yZero + 15);
            }
            for (let y = Math.ceil(yMin); y <= Math.floor(yMax); y++) {
                if (y === 0) continue;
                const py = mapY(y, yMin, yMax);
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(canvas.width, py);
                ctx.stroke();
                ctx.fillText(y.toString(), xZero + 5, py + 5);
            }
        }

        function mapX(x, xMin, xMax) {
            return ((x - xMin) / (xMax - xMin)) * canvas.width;
        }

        function mapY(y, yMin, yMax) {
            return canvas.height - ((y - yMin) / (yMax - yMin)) * canvas.height;
        }

        function plotImplicitCurve(poly, xMin, xMax, yMin, yMax) {
            // Use marching squares algorithm to find contours
            const resolution = 200;
            const dx = (xMax - xMin) / resolution;
            const dy = (yMax - yMin) / resolution;

            // Create grid of values (imaginary part of Q(z))
            const grid = [];
            for (let i = 0; i <= resolution; i++) {
                grid[i] = [];
                for (let j = 0; j <= resolution; j++) {
                    const x = xMin + i * dx;
                    const y = yMin + j * dy;
                    const result = poly.evaluateComplex(x, y);
                    grid[i][j] = result.im; // Store imaginary part
                }
            }

            // Draw contour where Im(Q(z)) = 0
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;

            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x0 = xMin + i * dx;
                    const y0 = yMin + j * dy;
                    const x1 = x0 + dx;
                    const y1 = y0 + dy;

                    const v00 = grid[i][j];
                    const v10 = grid[i + 1][j];
                    const v01 = grid[i][j + 1];
                    const v11 = grid[i + 1][j + 1];

                    // Check if zero crossing occurs
                    drawContourSegment(x0, y0, x1, y1, v00, v10, v01, v11, xMin, xMax, yMin, yMax);
                }
            }
        }

        function plotRoots(roots, xMin, xMax, yMin, yMax) {
            ctx.fillStyle = '#dc3545';
            ctx.strokeStyle = '#721c24';
            ctx.lineWidth = 2;

            for (const root of roots) {
                const x = mapX(root.re, xMin, xMax);
                const y = mapY(root.im, yMin, yMax);

                // Draw a circle for each root
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // Add label showing the root value
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                const label = `${root.re.toFixed(2)}${root.im >= 0 ? '+' : ''}${root.im.toFixed(2)}i`;
                ctx.fillText(label, x + 8, y - 8);
                ctx.fillStyle = '#dc3545';
            }
        }

        function drawContourSegment(x0, y0, x1, y1, v00, v10, v01, v11, xMin, xMax, yMin, yMax) {
            const threshold = 0;
            const points = [];

            // Check each edge for zero crossing
            // Bottom edge
            if ((v00 < threshold && v10 > threshold) || (v00 > threshold && v10 < threshold)) {
                const t = (threshold - v00) / (v10 - v00);
                points.push({ x: x0 + t * (x1 - x0), y: y0 });
            }
            // Right edge
            if ((v10 < threshold && v11 > threshold) || (v10 > threshold && v11 < threshold)) {
                const t = (threshold - v10) / (v11 - v10);
                points.push({ x: x1, y: y0 + t * (y1 - y0) });
            }
            // Top edge
            if ((v01 < threshold && v11 > threshold) || (v01 > threshold && v11 < threshold)) {
                const t = (threshold - v01) / (v11 - v01);
                points.push({ x: x0 + t * (x1 - x0), y: y1 });
            }
            // Left edge
            if ((v00 < threshold && v01 > threshold) || (v00 > threshold && v01 < threshold)) {
                const t = (threshold - v00) / (v01 - v00);
                points.push({ x: x0, y: y0 + t * (y1 - y0) });
            }

            // Draw line segment between points
            if (points.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(mapX(points[0].x, xMin, xMax), mapY(points[0].y, yMin, yMax));
                ctx.lineTo(mapX(points[1].x, xMin, xMax), mapY(points[1].y, yMin, yMax));
                ctx.stroke();
            }
        }

        // Plot when calculate is clicked
        document.getElementById('calculateButton').addEventListener('click', () => {
            setTimeout(plotRealLocus, 100); // Plot after polynomial is calculated
        });

        // Initial plot
        setTimeout(() => {
            plotRealLocus();
        }, 200);
    </script>
</body>

</html>
