/**
 * Kleinian Group Limit Set Visualizer
 * Group generated by:
 * A(w) = w + z
 * B(w) = -1 / w
 */

(function () {
    // --- Configuration & State ---
    const state = {
        z: { re: 1.366, im: 0.248 }, // Updated default
        depth: 14,
        colorMode: 'lastOp', // 'lastOp', 'firstOp', 'depth', 'parity'

        // Viewport for the main fractal
        view: {
            x: 0,
            y: 0,
            scale: 150 // Pixels per unit
        },

        // Viewport for the Z-control plane
        zView: {
            scale: 60, // Pixels per unit in Z-plane
            range: 2.5 // visible range +/-
        },

        isDraggingZ: false,
        isDraggingView: false,
        lastMouse: { x: 0, y: 0 },
        isWandering: false,
        wanderId: null
    };

    // DOM Elements - will be initialized after DOM is ready
    let mainCanvas, zCanvas, mainCtx, zCtx, uiRefs;

    // --- Math & Algorithm ---

    function generateLimitSetPoints() {
        const maxDepth = state.depth;
        let currentRe = [0];
        let currentIm = [0];
        let currentOp = [-1];
        let currentFirstOp = [-1]; // Track first operation

        const pointsToDraw = [];

        for (let d = 0; d < maxDepth; d++) {
            const nextRe = [];
            const nextIm = [];
            const nextOp = [];
            const nextFirstOp = [];

            const zRe = state.z.re;
            const zIm = state.z.im;

            const len = currentRe.length;

            for (let i = 0; i < len; i++) {
                const wRe = currentRe[i];
                const wIm = currentIm[i];
                const last = currentOp[i];
                const first = currentFirstOp[i];

                // Apply A: w + z
                if (last !== 1) {
                    nextRe.push(wRe + zRe);
                    nextIm.push(wIm + zIm);
                    nextOp.push(0);
                    nextFirstOp.push(d === 0 ? 0 : first);
                }

                // Apply A': w - z
                if (last !== 0) {
                    nextRe.push(wRe - zRe);
                    nextIm.push(wIm - zIm);
                    nextOp.push(1);
                    nextFirstOp.push(d === 0 ? 1 : first);
                }

                // Apply B: -1/w
                if (last !== 2) {
                    const distSq = wRe * wRe + wIm * wIm;
                    if (distSq > 1e-12) {
                        const invDist = 1.0 / distSq;
                        nextRe.push(-wRe * invDist);
                        nextIm.push(wIm * invDist);
                        nextOp.push(2);
                        nextFirstOp.push(d === 0 ? 2 : first);
                    }
                }
            }

            if (d > 4) {
                const nextLen = nextRe.length;
                for (let k = 0; k < nextLen; k++) {
                    // Store: re, im, op, depth, firstOp
                    pointsToDraw.push(nextRe[k], nextIm[k], nextOp[k], d, nextFirstOp[k]);
                }
            }

            currentRe = nextRe;
            currentIm = nextIm;
            currentOp = nextOp;
            currentFirstOp = nextFirstOp;

            if (currentRe.length > 300000) break;
        }

        return pointsToDraw;
    }

    // --- Rendering ---

    function drawMainCanvas() {
        if (!mainCanvas || !mainCtx) return;

        const width = mainCanvas.width;
        const height = mainCanvas.height;
        const cx = width / 2 + state.view.x;
        const cy = height / 2 + state.view.y;
        const scale = state.view.scale;

        mainCtx.fillStyle = "#0f0f13";
        mainCtx.fillRect(0, 0, width, height);

        if (uiRefs.loading) uiRefs.loading.style.opacity = 1;

        // Use setTimeout to allow UI to update before heavy calculation
        setTimeout(() => {
            const points = generateLimitSetPoints();
            if (uiRefs.loading) uiRefs.loading.style.opacity = 0;

            const imgData = mainCtx.createImageData(width, height);
            const data = imgData.data;

            const pLen = points.length;
            // Stride is now 5: re, im, op, depth, firstOp
            for (let i = 0; i < pLen; i += 5) {
                const re = points[i];
                const im = points[i + 1];
                const op = points[i + 2];
                const depth = points[i + 3];
                const firstOp = points[i + 4];

                const sx = Math.floor(cx + re * scale);
                const sy = Math.floor(cy - im * scale);

                if (sx >= 0 && sx < width && sy >= 0 && sy < height) {
                    const idx = (sy * width + sx) * 4;

                    let r, g, b;

                    if (state.colorMode === 'lastOp') {
                        if (op === 0) { r = 255; g = 100; b = 100; }
                        else if (op === 1) { r = 100; g = 150; b = 255; }
                        else { r = 255; g = 255; b = 100; }
                    } else if (state.colorMode === 'firstOp') {
                        if (firstOp === 0) { r = 255; g = 100; b = 100; }
                        else if (firstOp === 1) { r = 100; g = 150; b = 255; }
                        else { r = 255; g = 255; b = 100; }
                    } else if (state.colorMode === 'depth') {
                        // Gradient from blue to pink/white based on depth
                        const t = (depth - 5) / (state.depth - 5);
                        r = 50 + 200 * t;
                        g = 100 + 50 * t;
                        b = 255 - 100 * t;
                    } else if (state.colorMode === 'parity') {
                        if (depth % 2 === 0) { r = 255; g = 100; b = 255; }
                        else { r = 100; g = 255; b = 255; }
                    }

                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }

            mainCtx.putImageData(imgData, 0, 0);
            drawAxes(cx, cy, width, height);
        }, 0);
    }

    function drawAxes(cx, cy, width, height) {
        mainCtx.strokeStyle = "#333";
        mainCtx.lineWidth = 1;
        mainCtx.beginPath();
        mainCtx.moveTo(0, cy);
        mainCtx.lineTo(width, cy);
        mainCtx.moveTo(cx, 0);
        mainCtx.lineTo(cx, height);
        mainCtx.stroke();
    }

    function drawZCanvas() {
        if (!zCanvas || !zCtx) return;

        const w = zCanvas.width;
        const h = zCanvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const scale = state.zView.scale;

        zCtx.fillStyle = "#000";
        zCtx.fillRect(0, 0, w, h);

        // Grid
        zCtx.strokeStyle = "#333";
        zCtx.lineWidth = 1;

        // Unit Circle
        zCtx.beginPath();
        zCtx.arc(cx, cy, scale * 2, 0, Math.PI * 2);
        zCtx.strokeStyle = "#2a2a2a";
        zCtx.stroke();

        zCtx.beginPath();
        zCtx.arc(cx, cy, scale * 1, 0, Math.PI * 2);
        zCtx.strokeStyle = "#222";
        zCtx.stroke();

        // Axes
        zCtx.beginPath();
        zCtx.moveTo(0, cy);
        zCtx.lineTo(w, cy);
        zCtx.moveTo(cx, 0);
        zCtx.lineTo(cx, h);
        zCtx.strokeStyle = "#555";
        zCtx.stroke();

        // Z Point
        const zx = cx + state.z.re * scale;
        const zy = cy - state.z.im * scale;

        // Glow
        const grad = zCtx.createRadialGradient(zx, zy, 2, zx, zy, 10);
        grad.addColorStop(0, "#4facfe");
        grad.addColorStop(1, "transparent");
        zCtx.fillStyle = grad;
        zCtx.beginPath();
        zCtx.arc(zx, zy, 10, 0, Math.PI * 2);
        zCtx.fill();

        // Dot
        zCtx.fillStyle = "#fff";
        zCtx.beginPath();
        zCtx.arc(zx, zy, 3, 0, Math.PI * 2);
        zCtx.fill();
    }

    // --- Interaction Handling ---

    function updateUIValues() {
        if (!uiRefs) return;

        if (uiRefs.zReInput) uiRefs.zReInput.value = state.z.re.toFixed(4);
        if (uiRefs.zImInput) uiRefs.zImInput.value = state.z.im.toFixed(4);

        if (uiRefs.depthVal) uiRefs.depthVal.textContent = state.depth;
        if (uiRefs.zoomVal) uiRefs.zoomVal.textContent = state.view.scale;
    }

    function resize() {
        const container = document.getElementById('limit-set-canvas-container');
        if (!container) return;

        mainCanvas.width = container.clientWidth;
        mainCanvas.height = container.clientHeight;

        const zControlContainer = document.getElementById('z-control-container');
        if (zControlContainer) {
            const zRect = zControlContainer.getBoundingClientRect();
            zCanvas.width = zRect.width;
            zCanvas.height = zRect.height;
        }

        drawMainCanvas();
        drawZCanvas();
    }

    function handleZInteraction(clientX, clientY) {
        const rect = zCanvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const w = zCanvas.width;
        const h = zCanvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const scale = state.zView.scale;

        state.z.re = (x - cx) / scale;
        state.z.im = -(y - cy) / scale;
        updateUIValues();
        requestAnimationFrame(drawZCanvas);
        requestAnimationFrame(drawMainCanvas);
    }

    // Initialization
    function init() {
        mainCanvas = document.getElementById('limit-set-main-canvas');
        zCanvas = document.getElementById('z-canvas');

        if (!mainCanvas || !zCanvas) {
            console.warn("Limit Set Visualizer: Canvases not found, skipping initialization.");
            return;
        }

        mainCtx = mainCanvas.getContext('2d', { alpha: false });
        zCtx = zCanvas.getContext('2d');

        uiRefs = {
            zReInput: document.getElementById('z-re-input'),
            zImInput: document.getElementById('z-im-input'),
            depthSlider: document.getElementById('depth-slider'),
            depthVal: document.getElementById('depth-val'),
            zoomSlider: document.getElementById('zoom-slider'),
            zoomVal: document.getElementById('zoom-val'),
            colorMode: document.getElementById('color-mode'),
            examples: document.getElementById('examples-select'),
            saveBtn: document.getElementById('save-btn'),
            loading: document.getElementById('limit-set-loading')
        };

        // Check URL hash for params
        if (window.location.hash) {
            try {
                const hashParams = JSON.parse(decodeURIComponent(window.location.hash.substring(1)));
                if (hashParams.re !== undefined) state.z.re = parseFloat(hashParams.re);
                if (hashParams.im !== undefined) state.z.im = parseFloat(hashParams.im);
                if (hashParams.depth !== undefined) state.depth = parseInt(hashParams.depth);
                if (hashParams.zoom !== undefined) state.view.scale = parseInt(hashParams.zoom);
                if (hashParams.color !== undefined) state.colorMode = hashParams.color;
            } catch (e) {
                console.warn("Error parsing URL hash:", e);
                // Fallback to old parsing if JSON fails
                const params = new URLSearchParams(window.location.hash.substring(1));
                if (params.has('re')) state.z.re = parseFloat(params.get('re'));
                if (params.has('im')) state.z.im = parseFloat(params.get('im'));
                if (params.has('depth')) state.depth = parseInt(params.get('depth'));
                if (params.has('zoom')) state.view.scale = parseInt(params.get('zoom'));
                if (params.has('color')) state.colorMode = params.get('color');
            }
        }

        // Sync UI
        if (uiRefs.depthSlider) uiRefs.depthSlider.value = state.depth;
        if (uiRefs.zoomSlider) uiRefs.zoomSlider.value = Math.min(500, state.view.scale);
        if (uiRefs.colorMode) uiRefs.colorMode.value = state.colorMode;

        updateUIValues();

        // Event Listeners
        window.addEventListener('resize', resize);

        // Main Canvas Interaction
        mainCanvas.addEventListener('mousedown', e => {
            state.isDraggingView = true;
            state.lastMouse = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('mousemove', e => {
            if (state.isDraggingView) {
                const dx = e.clientX - state.lastMouse.x;
                const dy = e.clientY - state.lastMouse.y;
                state.view.x += dx;
                state.view.y += dy;
                state.lastMouse = { x: e.clientX, y: e.clientY };
                requestAnimationFrame(drawMainCanvas);
            }
            if (state.isDraggingZ) {
                handleZInteraction(e.clientX, e.clientY);
            }
        });

        window.addEventListener('mouseup', () => {
            state.isDraggingView = false;
            state.isDraggingZ = false;
        });

        mainCanvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSpeed = 0.05;
            const factor = e.deltaY > 0 ? (1 - zoomSpeed) : (1 + zoomSpeed);
            state.view.scale *= factor;
            state.view.scale = Math.max(10, Math.min(50000, state.view.scale));
            if (state.view.scale <= 500 && uiRefs.zoomSlider) uiRefs.zoomSlider.value = Math.floor(state.view.scale);
            updateUIValues();
            requestAnimationFrame(drawMainCanvas);
        });

        // Z-Canvas Interaction
        zCanvas.addEventListener('mousedown', e => {
            state.isDraggingZ = true;
            handleZInteraction(e.clientX, e.clientY);
        });

        // UI Controls
        if (uiRefs.zReInput) {
            uiRefs.zReInput.addEventListener('change', e => {
                const val = parseFloat(e.target.value);
                if (!isNaN(val)) {
                    state.z.re = val;
                    drawZCanvas();
                    drawMainCanvas();
                }
            });
            uiRefs.zReInput.addEventListener('input', e => {
                // Optional: update on type if desired, but might be too heavy. 
                // 'change' fires on enter or blur which is safer for heavy rendering.
                // For now let's stick to change or maybe input with debounce?
                // Given the request "Allow the user to type in", 'change' is standard.
            });
        }

        if (uiRefs.zImInput) {
            uiRefs.zImInput.addEventListener('change', e => {
                const val = parseFloat(e.target.value);
                if (!isNaN(val)) {
                    state.z.im = val;
                    drawZCanvas();
                    drawMainCanvas();
                }
            });
        }

        if (uiRefs.depthSlider) {
            uiRefs.depthSlider.addEventListener('input', e => {
                state.depth = parseInt(e.target.value);
                updateUIValues();
                requestAnimationFrame(drawMainCanvas);
            });
        }

        if (uiRefs.zoomSlider) {
            uiRefs.zoomSlider.addEventListener('input', e => {
                state.view.scale = parseInt(e.target.value);
                updateUIValues();
                requestAnimationFrame(drawMainCanvas);
            });
        }

        if (uiRefs.colorMode) {
            uiRefs.colorMode.addEventListener('change', e => {
                state.colorMode = e.target.value;
                requestAnimationFrame(drawMainCanvas);
            });
        }

        if (uiRefs.examples) {
            uiRefs.examples.addEventListener('change', e => {
                if (e.target.value) {
                    const val = JSON.parse(e.target.value);
                    state.z.re = val.re;
                    state.z.im = val.im;
                    updateUIValues();
                    drawZCanvas();
                    drawMainCanvas();
                }
            });
        }

        if (uiRefs.saveBtn) {
            uiRefs.saveBtn.addEventListener('click', () => {
                const params = {
                    re: state.z.re,
                    im: state.z.im,
                    depth: state.depth,
                    color: state.colorMode,
                    zoom: state.view.scale
                };
                const hash = '#' + encodeURIComponent(JSON.stringify(params));
                window.location.hash = hash;

                // Visual feedback
                const originalText = uiRefs.saveBtn.textContent;
                uiRefs.saveBtn.textContent = "Copied!";
                setTimeout(() => {
                    uiRefs.saveBtn.textContent = originalText;
                }, 1500);

                // Copy to clipboard
                navigator.clipboard.writeText(window.location.href);
            });
        }

        const wanderBtn = document.getElementById('wander-btn');
        if (wanderBtn) {
            wanderBtn.addEventListener('click', toggleWander);
        }

        function toggleWander() {
            state.isWandering = !state.isWandering;
            const btn = document.getElementById('wander-btn');

            if (state.isWandering) {
                if (btn) {
                    btn.textContent = "Stop Wandering";
                    btn.style.background = "#ef4444"; // Red
                }
                // Initialize velocity if not present
                if (!state.velocity) state.velocity = { re: 0, im: 0 };
                wanderStep();
            } else {
                if (btn) {
                    btn.textContent = "Wander";
                    btn.style.background = "#6b7280"; // Gray
                }
                if (state.wanderId) {
                    cancelAnimationFrame(state.wanderId);
                    state.wanderId = null;
                }
            }
        }

        function wanderStep() {
            if (!state.isWandering) return;

            // Smooth wander using velocity (momentum)
            // Adjust these physics constants to tune the "feel"
            const acceleration = 0.002;
            const friction = 0.98;
            const maxSpeed = 0.05;

            // Update velocity with random acceleration
            state.velocity.re += (Math.random() - 0.5) * acceleration;
            state.velocity.im += (Math.random() - 0.5) * acceleration;

            // Apply friction
            state.velocity.re *= friction;
            state.velocity.im *= friction;

            // Clamp velocity (optional, prevents it from getting too crazy)
            const speed = Math.sqrt(state.velocity.re ** 2 + state.velocity.im ** 2);
            if (speed > maxSpeed) {
                const ratio = maxSpeed / speed;
                state.velocity.re *= ratio;
                state.velocity.im *= ratio;
            }

            // Update position
            state.z.re += state.velocity.re;
            state.z.im += state.velocity.im;

            // Soft bounce off walls [-2, 2]
            if (state.z.re > 2) { state.z.re = 2; state.velocity.re *= -1; }
            if (state.z.re < -2) { state.z.re = -2; state.velocity.re *= -1; }
            if (state.z.im > 2) { state.z.im = 2; state.velocity.im *= -1; }
            if (state.z.im < -2) { state.z.im = -2; state.velocity.im *= -1; }

            updateUIValues();
            drawZCanvas();
            drawMainCanvas();

            state.wanderId = requestAnimationFrame(wanderStep);
        }

        // Listen for external events
        window.addEventListener('riley-slice-root-selected', e => {
            if (e.detail) {
                state.z.re = e.detail.re;
                state.z.im = e.detail.im;
                updateUIValues();
                drawZCanvas();
                drawMainCanvas();

                // Scroll to visualizer if needed (optional, but helpful)
                // const container = document.getElementById('limit-set-canvas-container');
                // if (container) {
                //     container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // }
            }
        });

        resize();
    }

    // Run init when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

})();
