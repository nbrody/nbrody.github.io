/**
 * Kleinian Group Limit Set Visualizer
 * Group generated by:
 * A(w) = w + z
 * B(w) = -1 / w
 */

(function () {
    // --- Configuration & State ---
    const state = {
        z: { re: 1.366, im: 0.248 }, // Updated default
        depth: 14,
        colorMode: 'lastOp', // 'lastOp', 'firstOp', 'depth', 'parity'

        // Viewport for the main fractal
        view: {
            x: 0,
            y: 0,
            scale: 150 // Pixels per unit
        },

        // Viewport for the Z-control plane
        zView: {
            scale: 60, // Pixels per unit in Z-plane
            range: 2.5 // visible range +/-
        },

        isDraggingZ: false,
        isDraggingView: false,
        isInteracting: false, // Tracks if user is actively moving things
        lastMouse: { x: 0, y: 0 },
        isWandering: false,
        wanderId: null,

        // Pre-allocated buffers for BFS (to avoid GC)
        buffers: {
            maxPoints: 500000,
            currRe: new Float32Array(500000),
            currIm: new Float32Array(500000),
            currOp: new Int8Array(500000),
            currFirstOp: new Int8Array(500000),
            nextRe: new Float32Array(500000),
            nextIm: new Float32Array(500000),
            nextOp: new Int8Array(500000),
            nextFirstOp: new Int8Array(500000),
            pointsToDraw: new Float32Array(1500000) // Stride 5
        }
    };

    // DOM Elements - will be initialized after DOM is ready
    let mainCanvas, zCanvas, mainCtx, zCtx, uiRefs;

    // --- Math & Algorithm ---

    function generateLimitSetPoints(isDraft = false) {
        const maxDepth = isDraft ? Math.min(state.depth, 10) : state.depth;
        const maxPointsInLayer = state.buffers.maxPoints;

        let currRe = state.buffers.currRe;
        let currIm = state.buffers.currIm;
        let currOp = state.buffers.currOp;
        let currFirstOp = state.buffers.currFirstOp;

        let nextRe = state.buffers.nextRe;
        let nextIm = state.buffers.nextIm;
        let nextOp = state.buffers.nextOp;
        let nextFirstOp = state.buffers.nextFirstOp;

        const pointsToDraw = state.buffers.pointsToDraw;
        let pointsCount = 0;

        // Initial point: (0,0)
        currRe[0] = 0;
        currIm[0] = 0;
        currOp[0] = -1;
        currFirstOp[0] = -1;
        let currentLen = 1;

        const zRe = state.z.re;
        const zIm = state.z.im;

        for (let d = 0; d < maxDepth; d++) {
            let nextLen = 0;

            for (let i = 0; i < currentLen; i++) {
                const wRe = currRe[i];
                const wIm = currIm[i];
                const last = currOp[i];
                const first = currFirstOp[i];

                // Apply A: w + z
                if (last !== 1 && nextLen < maxPointsInLayer) {
                    nextRe[nextLen] = wRe + zRe;
                    nextIm[nextLen] = wIm + zIm;
                    nextOp[nextLen] = 0;
                    nextFirstOp[nextLen] = (d === 0) ? 0 : first;
                    nextLen++;
                }

                // Apply A': w - z
                if (last !== 0 && nextLen < maxPointsInLayer) {
                    nextRe[nextLen] = wRe - zRe;
                    nextIm[nextLen] = wIm - zIm;
                    nextOp[nextLen] = 1;
                    nextFirstOp[nextLen] = (d === 0) ? 1 : first;
                    nextLen++;
                }

                // Apply B: -1/w
                if (last !== 2 && nextLen < maxPointsInLayer) {
                    const distSq = wRe * wRe + wIm * wIm;
                    if (distSq > 1e-12) {
                        const invDist = 1.0 / distSq;
                        nextRe[nextLen] = -wRe * invDist;
                        nextIm[nextLen] = wIm * invDist;
                        nextOp[nextLen] = 2;
                        nextFirstOp[nextLen] = (d === 0) ? 2 : first;
                        nextLen++;
                    }
                }
            }

            // Export points to draw from certain depth
            if (d > 4) {
                // Limit points to draw in draft mode
                const step = isDraft ? 2 : 1;
                for (let k = 0; k < nextLen; k += step) {
                    if (pointsCount + 5 < pointsToDraw.length) {
                        pointsToDraw[pointsCount++] = nextRe[k];
                        pointsToDraw[pointsCount++] = nextIm[k];
                        pointsToDraw[pointsCount++] = nextOp[k];
                        pointsToDraw[pointsCount++] = d;
                        pointsToDraw[pointsCount++] = nextFirstOp[k];
                    }
                }
            }

            // Swap buffers
            let temp;
            temp = currRe; currRe = nextRe; nextRe = temp;
            temp = currIm; currIm = nextIm; nextIm = temp;
            temp = currOp; currOp = nextOp; nextOp = temp;
            temp = currFirstOp; currFirstOp = nextFirstOp; nextFirstOp = temp;

            currentLen = nextLen;
            if (currentLen > 300000 || (isDraft && currentLen > 50000)) break;
        }

        return { data: pointsToDraw, count: pointsCount };
    }

    // --- Rendering ---

    let highDetailTimer = null;

    function drawMainCanvas() {
        if (!mainCanvas || !mainCtx) return;

        const width = mainCanvas.width;
        const height = mainCanvas.height;
        const cx = width / 2 + state.view.x;
        const cy = height / 2 + state.view.y;
        const scale = state.view.scale;

        // If interacting, draw immediately with lower depth
        if (state.isInteracting || state.isWandering) {
            render(true); // Draft mode

            // Schedule high detail render when interaction stops
            clearTimeout(highDetailTimer);
            highDetailTimer = setTimeout(() => {
                state.isInteracting = false;
                render(false);
            }, 300);
        } else {
            render(false); // High detail
        }

        function render(isDraft) {
            const { data: points, count } = generateLimitSetPoints(isDraft);

            mainCtx.fillStyle = "#0f0f13";
            mainCtx.fillRect(0, 0, width, height);

            const imgData = mainCtx.createImageData(width, height);
            const data = imgData.data;

            // Stride is 5: re, im, op, depth, firstOp
            for (let i = 0; i < count; i += 5) {
                const re = points[i];
                const im = points[i + 1];
                const op = points[i + 2];
                const depth = points[i + 3];
                const firstOp = points[i + 4];

                const sx = (cx + re * scale) | 0; // Faster than Math.floor
                const sy = (cy - im * scale) | 0;

                if (sx >= 0 && sx < width && sy >= 0 && sy < height) {
                    const idx = (sy * width + sx) << 2; // Faster than * 4

                    let r, g, b;
                    if (state.colorMode === 'lastOp') {
                        if (op === 0) { r = 255; g = 100; b = 100; }
                        else if (op === 1) { r = 100; g = 150; b = 255; }
                        else { r = 255; g = 255; b = 100; }
                    } else if (state.colorMode === 'firstOp') {
                        if (firstOp === 0) { r = 255; g = 100; b = 100; }
                        else if (firstOp === 1) { r = 100; g = 150; b = 255; }
                        else { r = 255; g = 255; b = 100; }
                    } else if (state.colorMode === 'depth') {
                        const t = (depth - 5) / (state.depth - 5);
                        r = (50 + 200 * t) | 0;
                        g = (100 + 50 * t) | 0;
                        b = (255 - 100 * t) | 0;
                    } else if (state.colorMode === 'parity') {
                        if (depth % 2 === 0) { r = 255; g = 100; b = 255; }
                        else { r = 100; g = 255; b = 255; }
                    }

                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }

            mainCtx.putImageData(imgData, 0, 0);
            drawAxes(cx, cy, width, height);
        }
    }

    function drawAxes(cx, cy, width, height) {
        mainCtx.strokeStyle = "#333";
        mainCtx.lineWidth = 1;
        mainCtx.beginPath();
        mainCtx.moveTo(0, cy);
        mainCtx.lineTo(width, cy);
        mainCtx.moveTo(cx, 0);
        mainCtx.lineTo(cx, height);
        mainCtx.stroke();
    }

    function drawZCanvas() {
        if (!zCanvas || !zCtx) return;

        const w = zCanvas.width;
        const h = zCanvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const scale = state.zView.scale;

        zCtx.fillStyle = "#000";
        zCtx.fillRect(0, 0, w, h);

        // Grid
        zCtx.strokeStyle = "#333";
        zCtx.lineWidth = 1;

        // Unit Circle
        zCtx.beginPath();
        zCtx.arc(cx, cy, scale * 2, 0, Math.PI * 2);
        zCtx.strokeStyle = "#2a2a2a";
        zCtx.stroke();

        zCtx.beginPath();
        zCtx.arc(cx, cy, scale * 1, 0, Math.PI * 2);
        zCtx.strokeStyle = "#222";
        zCtx.stroke();

        // Axes
        zCtx.beginPath();
        zCtx.moveTo(0, cy);
        zCtx.lineTo(w, cy);
        zCtx.moveTo(cx, 0);
        zCtx.lineTo(cx, h);
        zCtx.strokeStyle = "#555";
        zCtx.stroke();

        // Z Point
        const zx = cx + state.z.re * scale;
        const zy = cy - state.z.im * scale;

        // Glow
        const grad = zCtx.createRadialGradient(zx, zy, 2, zx, zy, 10);
        grad.addColorStop(0, "#4facfe");
        grad.addColorStop(1, "transparent");
        zCtx.fillStyle = grad;
        zCtx.beginPath();
        zCtx.arc(zx, zy, 10, 0, Math.PI * 2);
        zCtx.fill();

        // Dot
        zCtx.fillStyle = "#fff";
        zCtx.beginPath();
        zCtx.arc(zx, zy, 3, 0, Math.PI * 2);
        zCtx.fill();
    }

    // --- Interaction Handling ---

    function updateUIValues() {
        if (!uiRefs) return;

        if (uiRefs.zReInput) uiRefs.zReInput.value = state.z.re.toFixed(4);
        if (uiRefs.zImInput) uiRefs.zImInput.value = state.z.im.toFixed(4);

        if (uiRefs.depthVal) uiRefs.depthVal.textContent = state.depth;
        if (uiRefs.zoomVal) uiRefs.zoomVal.textContent = state.view.scale;
    }

    function resize() {
        const container = document.getElementById('limit-set-canvas-container');
        if (!container) return;

        mainCanvas.width = container.clientWidth;
        mainCanvas.height = container.clientHeight;

        const zControlContainer = document.getElementById('z-control-container');
        if (zControlContainer) {
            const zRect = zControlContainer.getBoundingClientRect();
            zCanvas.width = zRect.width;
            zCanvas.height = zRect.height;
        }

        drawMainCanvas();
        drawZCanvas();
    }

    function handleZInteraction(clientX, clientY) {
        const rect = zCanvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const w = zCanvas.width;
        const h = zCanvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const scale = state.zView.scale;

        state.z.re = (x - cx) / scale;
        state.z.im = -(y - cy) / scale;
        updateUIValues();
        requestAnimationFrame(drawZCanvas);
        requestAnimationFrame(drawMainCanvas);
    }

    // Initialization
    function init() {
        mainCanvas = document.getElementById('limit-set-main-canvas');
        zCanvas = document.getElementById('z-canvas');

        if (!mainCanvas || !zCanvas) {
            console.warn("Limit Set Visualizer: Canvases not found, skipping initialization.");
            return;
        }

        mainCtx = mainCanvas.getContext('2d', { alpha: false });
        zCtx = zCanvas.getContext('2d');

        uiRefs = {
            zReInput: document.getElementById('z-re-input'),
            zImInput: document.getElementById('z-im-input'),
            depthSlider: document.getElementById('depth-slider'),
            depthVal: document.getElementById('depth-val'),
            zoomSlider: document.getElementById('zoom-slider'),
            zoomVal: document.getElementById('zoom-val'),
            colorMode: document.getElementById('color-mode'),
            examples: document.getElementById('examples-select'),
            saveBtn: document.getElementById('save-btn'),
            loading: document.getElementById('limit-set-loading')
        };

        // Check URL hash for params
        if (window.location.hash) {
            try {
                const hashParams = JSON.parse(decodeURIComponent(window.location.hash.substring(1)));
                if (hashParams.re !== undefined) state.z.re = parseFloat(hashParams.re);
                if (hashParams.im !== undefined) state.z.im = parseFloat(hashParams.im);
                if (hashParams.depth !== undefined) state.depth = parseInt(hashParams.depth);
                if (hashParams.zoom !== undefined) state.view.scale = parseInt(hashParams.zoom);
                if (hashParams.color !== undefined) state.colorMode = hashParams.color;
            } catch (e) {
                console.warn("Error parsing URL hash:", e);
                // Fallback to old parsing if JSON fails
                const params = new URLSearchParams(window.location.hash.substring(1));
                if (params.has('re')) state.z.re = parseFloat(params.get('re'));
                if (params.has('im')) state.z.im = parseFloat(params.get('im'));
                if (params.has('depth')) state.depth = parseInt(params.get('depth'));
                if (params.has('zoom')) state.view.scale = parseInt(params.get('zoom'));
                if (params.has('color')) state.colorMode = params.get('color');
            }
        }

        // Sync UI
        if (uiRefs.depthSlider) uiRefs.depthSlider.value = state.depth;
        if (uiRefs.zoomSlider) uiRefs.zoomSlider.value = Math.min(500, state.view.scale);
        if (uiRefs.colorMode) uiRefs.colorMode.value = state.colorMode;

        updateUIValues();

        // Event Listeners
        window.addEventListener('resize', resize);

        // Main Canvas Interaction
        mainCanvas.addEventListener('mousedown', e => {
            state.isDraggingView = true;
            state.isInteracting = true;
            state.lastMouse = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('mousemove', e => {
            if (state.isDraggingView) {
                const dx = e.clientX - state.lastMouse.x;
                const dy = e.clientY - state.lastMouse.y;
                state.view.x += dx;
                state.view.y += dy;
                state.lastMouse = { x: e.clientX, y: e.clientY };
                requestAnimationFrame(drawMainCanvas);
            }
            if (state.isDraggingZ) {
                handleZInteraction(e.clientX, e.clientY);
            }
        });

        window.addEventListener('mouseup', () => {
            state.isDraggingView = false;
            state.isDraggingZ = false;
            // state.isInteracting remains true momentarily to allow final high-detail render via timer
        });

        zCanvas.addEventListener('mousedown', e => {
            state.isDraggingZ = true;
            state.isInteracting = true;
            handleZInteraction(e.clientX, e.clientY);
        });

        mainCanvas.addEventListener('wheel', e => {
            e.preventDefault();
            state.isInteracting = true;
            const zoomSpeed = 0.05;
            const factor = e.deltaY > 0 ? (1 - zoomSpeed) : (1 + zoomSpeed);
            state.view.scale *= factor;
            state.view.scale = Math.max(10, Math.min(50000, state.view.scale));
            if (state.view.scale <= 500 && uiRefs.zoomSlider) uiRefs.zoomSlider.value = Math.floor(state.view.scale);
            updateUIValues();
            requestAnimationFrame(drawMainCanvas);
        }, { passive: false });

        // UI Controls
        if (uiRefs.zReInput) {
            uiRefs.zReInput.addEventListener('change', e => {
                const val = parseFloat(e.target.value);
                if (!isNaN(val)) {
                    state.z.re = val;
                    drawZCanvas();
                    drawMainCanvas();
                }
            });
            uiRefs.zReInput.addEventListener('input', e => {
                // Optional: update on type if desired, but might be too heavy. 
                // 'change' fires on enter or blur which is safer for heavy rendering.
                // For now let's stick to change or maybe input with debounce?
                // Given the request "Allow the user to type in", 'change' is standard.
            });
        }

        if (uiRefs.zImInput) {
            uiRefs.zImInput.addEventListener('change', e => {
                const val = parseFloat(e.target.value);
                if (!isNaN(val)) {
                    state.z.im = val;
                    drawZCanvas();
                    drawMainCanvas();
                }
            });
        }

        if (uiRefs.depthSlider) {
            uiRefs.depthSlider.addEventListener('input', e => {
                state.depth = parseInt(e.target.value);
                updateUIValues();
                requestAnimationFrame(drawMainCanvas);
            });
        }

        if (uiRefs.zoomSlider) {
            uiRefs.zoomSlider.addEventListener('input', e => {
                state.view.scale = parseInt(e.target.value);
                updateUIValues();
                requestAnimationFrame(drawMainCanvas);
            });
        }

        if (uiRefs.colorMode) {
            uiRefs.colorMode.addEventListener('change', e => {
                state.colorMode = e.target.value;
                requestAnimationFrame(drawMainCanvas);
            });
        }

        if (uiRefs.examples) {
            uiRefs.examples.addEventListener('change', e => {
                if (e.target.value) {
                    const val = JSON.parse(e.target.value);
                    state.z.re = val.re;
                    state.z.im = val.im;
                    updateUIValues();
                    drawZCanvas();
                    drawMainCanvas();
                }
            });
        }

        if (uiRefs.saveBtn) {
            uiRefs.saveBtn.addEventListener('click', () => {
                const params = {
                    re: state.z.re,
                    im: state.z.im,
                    depth: state.depth,
                    color: state.colorMode,
                    zoom: state.view.scale
                };
                const hash = '#' + encodeURIComponent(JSON.stringify(params));
                window.location.hash = hash;

                // Visual feedback
                const originalText = uiRefs.saveBtn.textContent;
                uiRefs.saveBtn.textContent = "Copied!";
                setTimeout(() => {
                    uiRefs.saveBtn.textContent = originalText;
                }, 1500);

                // Copy to clipboard
                navigator.clipboard.writeText(window.location.href);
            });
        }

        const wanderBtn = document.getElementById('wander-btn');
        if (wanderBtn) {
            wanderBtn.addEventListener('click', toggleWander);
        }

        function toggleWander() {
            state.isWandering = !state.isWandering;
            const btn = document.getElementById('wander-btn');

            if (state.isWandering) {
                if (btn) {
                    btn.textContent = "Stop Wandering";
                    btn.style.background = "#ef4444"; // Red
                }
                // Initialize velocity if not present
                if (!state.velocity) state.velocity = { re: 0, im: 0 };
                wanderStep();
            } else {
                if (btn) {
                    btn.textContent = "Wander";
                    btn.style.background = "#6b7280"; // Gray
                }
                if (state.wanderId) {
                    cancelAnimationFrame(state.wanderId);
                    state.wanderId = null;
                }
            }
        }

        function wanderStep() {
            if (!state.isWandering) return;

            // Smooth wander using velocity (momentum)
            // Adjust these physics constants to tune the "feel"
            const acceleration = 0.002;
            const friction = 0.98;
            const maxSpeed = 0.05;

            // Update velocity with random acceleration
            state.velocity.re += (Math.random() - 0.5) * acceleration;
            state.velocity.im += (Math.random() - 0.5) * acceleration;

            // Apply friction
            state.velocity.re *= friction;
            state.velocity.im *= friction;

            // Clamp velocity (optional, prevents it from getting too crazy)
            const speed = Math.sqrt(state.velocity.re ** 2 + state.velocity.im ** 2);
            if (speed > maxSpeed) {
                const ratio = maxSpeed / speed;
                state.velocity.re *= ratio;
                state.velocity.im *= ratio;
            }

            // Update position
            state.z.re += state.velocity.re;
            state.z.im += state.velocity.im;

            // Soft bounce off walls [-2, 2]
            if (state.z.re > 2) { state.z.re = 2; state.velocity.re *= -1; }
            if (state.z.re < -2) { state.z.re = -2; state.velocity.re *= -1; }
            if (state.z.im > 2) { state.z.im = 2; state.velocity.im *= -1; }
            if (state.z.im < -2) { state.z.im = -2; state.velocity.im *= -1; }

            updateUIValues();
            drawZCanvas();
            drawMainCanvas();

            state.wanderId = requestAnimationFrame(wanderStep);
        }

        // Listen for external events
        window.addEventListener('riley-slice-root-selected', e => {
            if (e.detail) {
                state.z.re = e.detail.re;
                state.z.im = e.detail.im;
                updateUIValues();
                drawZCanvas();
                drawMainCanvas();

                // Scroll to visualizer if needed (optional, but helpful)
                // const container = document.getElementById('limit-set-canvas-container');
                // if (container) {
                //     container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // }
            }
        });

        resize();
    }

    // Run init when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

})();
