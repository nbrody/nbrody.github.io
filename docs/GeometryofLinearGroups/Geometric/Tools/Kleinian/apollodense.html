<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Apollonian Circle Packing — Ray-Marched DE (GLSL)</title>
<style>
  html, body { margin:0; height:100%; background:#0b0b10; color:#e8e8ef; font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
  #wrap { position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr; }
  header {
    display:flex; gap:.75rem; align-items:center; padding:.5rem .75rem; background:#0f0f16; border-bottom:1px solid #1b1b24;
    position:relative; z-index:1;
  }
  header h1 { font-size:14px; font-weight:600; margin:0; color:#b9c2ff; letter-spacing:.2px;}
  .spacer { flex:1; }
  .ctrl { display:flex; align-items:center; gap:.4rem; color:#cfcfe8;}
  .ctrl label { opacity:.85; }
  .ctrl input[type="range"] { width:160px; }
  .btn {
    background:#1b1b28; border:1px solid #29293a; color:#e8e8ef; border-radius:8px; padding:.45rem .7rem; cursor:pointer;
  }
  .btn:hover { background:#222235; }
  #canvas { width:100%; height:100%; display:block; }
  .hint { opacity:.7; font-size:12px; }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Apollonian (GLSL distance estimator)</h1>
    <div class="spacer"></div>
    <div class="ctrl"><label>Iter:</label><input id="iter" type="range" min="4" max="64" value="28"></div>
    <div class="ctrl"><label>Line:</label><input id="thick" type="range" min="1" max="40" value="16"></div>
    <button id="reset" class="btn">Reset view</button>
    <button id="save"  class="btn" title="Save PNG">Save</button>
  </header>
  <canvas id="canvas"></canvas>
</div>

<script>
// ——— WebGPU + WGSL version ————————————————————————————————————————————
const canvas = document.getElementById('canvas');
const iterEl   = document.getElementById('iter');
const thickEl  = document.getElementById('thick');
const resetBtn = document.getElementById('reset');
const saveBtn  = document.getElementById('save');

if (!('gpu' in navigator)) {
  alert('WebGPU not available in this browser. Try Chrome/Edge with chrome://flags/#enable-unsafe-webgpu');
  throw new Error('WebGPU required');
}

const DPR = Math.max(1, window.devicePixelRatio || 1);
let device, context, format;
let pipeline, uniformBuffer, bindGroup, vertexBuffer;

let zoom = 1.0;
let center = {x: 0.0, y: 0.0};
let t0 = performance.now();

resetBtn.onclick = () => { zoom = 0.95; center.x = 0.0; center.y = 0.0; };
saveBtn.onclick = () => {
  const link = document.createElement('a');
  link.download = 'apollonian.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
};

// Fullscreen triangle vertices
const triVerts = new Float32Array([
  -1, -1,
   3, -1,
  -1,  3,
]);

const shaderWGSL = /* wgsl */ `
struct Uniforms {
  // Two packed vec4s to keep alignment simple
  v0 : vec4f, // (uRes.x, uRes.y, uTime, float(uIters))
  v1 : vec4f, // (uZoom, uThickness, uCenter.x, uCenter.y)
};
@group(0) @binding(0) var<uniform> U : Uniforms;

// Helpers to unpack
fn uRes() -> vec2f { return U.v0.xy; }
fn uTime() -> f32 { return U.v0.z; }
fn uIters() -> i32 { return i32(U.v0.w); }
fn uZoom() -> f32 { return U.v1.x; }
fn uThickness() -> f32 { return U.v1.y; }
fn uCenter() -> vec2f { return U.v1.zw; }

struct VSOut { @builtin(position) pos : vec4f; };

@vertex fn vs_main(@location(0) a_pos : vec2f) -> VSOut {
  var out : VSOut;
  out.pos = vec4f(a_pos, 0.0, 1.0);
  return out;
}

struct DEOut { dist: f32, shade: f32 };

fn length2(v: vec2f) -> f32 { return dot(v, v); }

fn apollonianDE(z0: vec2f, maxSteps: i32) -> DEOut {
  let R : f32 = 1.0; // outer radius
  let HALF_SQ3 : f32 = 0.8660254037844386;
  let d : f32 = 1.0 / (1.0 + HALF_SQ3);
  let r : f32 = HALF_SQ3 * d;
  let c0 : vec2f = vec2f(0.0, d);
  let c1 : vec2f = d * vec2f( 0.8660254037844386, -0.5);
  let c2 : vec2f = d * vec2f(-0.8660254037844386, -0.5);

  var z = z0;
  var scale : f32 = 1.0;
  var shade : f32 = 0.0;

  for (var i: i32 = 0; i < 128; i = i + 1) {
    if (i >= maxSteps) { break; }
    var did = false;

    let dO = length(z);
    if (dO > R) {
      let s = (R*R) / (dO*dO);
      z = z * s;
      scale = scale * s;
      shade = shade + 0.4;
      did = true;
    }

    let v0 = z - c0; let d0 = length(v0);
    if (d0 < r) {
      let s = (r*r) / (d0*d0);
      z = c0 + v0 * s;
      scale = scale * s;
      shade = shade + 1.0;
      did = true;
    }
    let v1 = z - c1; let d1 = length(v1);
    if (d1 < r) {
      let s = (r*r) / (d1*d1);
      z = c1 + v1 * s;
      scale = scale * s;
      shade = shade + 1.0;
      did = true;
    }
    let v2 = z - c2; let d2 = length(v2);
    if (d2 < r) {
      let s = (r*r) / (d2*d2);
      z = c2 + v2 * s;
      scale = scale * s;
      shade = shade + 1.0;
      did = true;
    }

    if (!did) { break; }
  }

  let local = abs(length(z) - 1.0);
  let dist = local / max(scale, 1e-18);
  return DEOut(dist, shade);
}

fn palette(t: f32) -> vec3f {
  let a = vec3f(0.17, 0.12, 0.30);
  let b = vec3f(0.45, 0.55, 0.95);
  let c = vec3f(0.80, 0.20, 0.40);
  let d = vec3f(0.00, 0.85, 0.75);
  return a + b * cos(6.28318 * (c * t + d));
}

@fragment fn fs_main(@builtin(position) pos: vec4f) -> @location(0) vec4f {
  let res = uRes();
  let frag = pos.xy; // in pixel coords
  let uv = (frag - 0.5 * res) / vec2f(res.y);
  let z  = uv / uZoom() + uCenter();

  let de = apollonianDE(z, uIters());

  let px = 1.0 / (res.y * uZoom());
  let thickness = (uThickness() * 0.03) * px;
  let aa = fwidth(de.dist) + 0.75 * px;

  var line = 1.0 - smoothstep(thickness, thickness + aa, de.dist);

  let r2 = dot(uv, uv);
  let bg = mix(vec3f(0.04,0.05,0.07), vec3f(0.015,0.018,0.030), smoothstep(0.0, 0.9, r2));

  var ink = palette(0.07 * de.shade + 0.02 * uTime());
  ink = mix(ink, vec3f(0.98), 0.15);

  var col = mix(bg, ink, line);
  let glow = exp(-30.0 * max(de.dist - thickness, 0.0) / px);
  col = col + 0.02 * glow * ink;

  return vec4f(col, 1.0);
}
`;

async function init() {
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) { alert('WebGPU adapter unavailable'); throw new Error('No adapter'); }
  device = await adapter.requestDevice();
  context = canvas.getContext('webgpu');
  format = navigator.gpu.getPreferredCanvasFormat();
  context.configure({ device, format, alphaMode: 'opaque' });

  // Create buffers
  vertexBuffer = device.createBuffer({
    size: triVerts.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    mappedAtCreation: true,
  });
  new Float32Array(vertexBuffer.getMappedRange()).set(triVerts);
  vertexBuffer.unmap();

  // Uniform buffer: two vec4f (32 bytes each) => 64 bytes
  uniformBuffer = device.createBuffer({
    size: 64,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  const module = device.createShaderModule({ code: shaderWGSL });

  pipeline = await device.createRenderPipelineAsync({
    layout: 'auto',
    vertex: {
      module,
      entryPoint: 'vs_main',
      buffers: [{
        arrayStride: 8,
        attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }],
      }],
    },
    fragment: {
      module,
      entryPoint: 'fs_main',
      targets: [{ format }],
    },
    primitive: { topology: 'triangle-list' },
  });

  bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
  });

  // Interaction: pan/zoom
  let dragging = false, lastX = 0, lastY = 0;
  canvas.addEventListener('mousedown', (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
  window.addEventListener('mouseup', () => dragging = false);
  window.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const dx = (e.clientX - lastX) / (canvas.height) / zoom;
    const dy = (e.clientY - lastY) / (canvas.height) / zoom;
    center.x -= dx;
    center.y += dy;
    lastX = e.clientX; lastY = e.clientY;
  });
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * DPR;
    const my = (e.clientY - rect.top)  * DPR;
    const uvx = (mx - 0.5*canvas.width)  / canvas.height;
    const uvy = (my - 0.5*canvas.height) / canvas.height;

    const worldBefore = { x: uvx/zoom + center.x, y: uvy/zoom + center.y };
    const factor = Math.exp(-e.deltaY * 0.0018);
    zoom = Math.max(1e-4, Math.min(200.0, zoom * factor));
    const worldAfter  = { x: uvx/zoom + center.x, y: uvy/zoom + center.y };
    center.x += (worldBefore.x - worldAfter.x);
    center.y += (worldBefore.y - worldAfter.y);
  }, { passive: false });

  resetBtn.click(); // set default view
  draw();
}

function resize() {
  const w = canvas.clientWidth, h = canvas.clientHeight;
  canvas.width  = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
}
new ResizeObserver(() => { resize(); }).observe(canvas);

function updateUniforms() {
  const uResX = canvas.width;
  const uResY = canvas.height;
  const uTime = (performance.now() - t0) * 0.001;
  const uIters = parseInt(iterEl.value, 10) | 0;
  const uZoom = zoom;
  const uThick = parseFloat(thickEl.value);
  const uCenterX = center.x;
  const uCenterY = center.y;

  // Pack into two vec4f (32 bytes each)
  const v0 = new Float32Array([uResX, uResY, uTime, uIters]);
  const v1 = new Float32Array([uZoom, uThick, uCenterX, uCenterY]);

  device.queue.writeBuffer(uniformBuffer, 0, v0.buffer, v0.byteOffset, v0.byteLength);
  device.queue.writeBuffer(uniformBuffer, 32, v1.buffer, v1.byteOffset, v1.byteLength);
}

function draw() {
  resize();
  updateUniforms();

  const encoder = device.createCommandEncoder();
  const view = context.getCurrentTexture().createView();
  const pass = encoder.beginRenderPass({
    colorAttachments: [{
      view,
      clearValue: { r: 0.06, g: 0.07, b: 0.1, a: 1.0 },
      loadOp: 'clear',
      storeOp: 'store',
    }],
  });
  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bindGroup);
  pass.setVertexBuffer(0, vertexBuffer);
  pass.draw(3, 1, 0, 0);
  pass.end();

  device.queue.submit([encoder.finish()]);
  requestAnimationFrame(draw);
}

init();
</script>
</body>
</html>