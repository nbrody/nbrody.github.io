<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integer Quaternions of Norm p</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }

        #visualization {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111827;
            /* bg-gray-900 */
        }

        .label {
            color: white;
            font-family: sans-serif;
            padding: 2px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200 antialiased">

    <div class="flex flex-col md:flex-row h-screen">
        <!-- Controls Panel -->
        <div class="w-full md:w-80 p-6 bg-gray-800 shadow-lg overflow-y-auto">
            <h1 class="text-2xl font-bold text-white mb-2">Quaternion Explorer</h1>
            <p class="text-sm text-gray-400 mb-6">Visualizing integer solutions to a²+b²+c²+d² = p</p>

            <div class="space-y-4">
                <div>
                    <label for="prime" class="block text-sm font-medium text-gray-300">Odd Prime (p)</label>
                    <input type="number" id="prime" value="13"
                        class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                </div>

                <div id="solution-display" class="hidden">
                    <p class="block text-sm font-medium text-gray-300">Solution for x²+y² ≡ -1 (mod p)</p>
                    <p id="xy-solution" class="mt-1 text-lg text-indigo-400 font-mono"></p>
                </div>

                <button id="visualize-btn"
                    class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105">
                    Visualize Quaternions
                </button>
            </div>

            <div id="loading" class="mt-4 text-center text-gray-400 hidden">
                <p>Searching for quaternions...</p>
                <div class="w-full bg-gray-700 rounded-full h-2.5 mt-2">
                    <div id="progress-bar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>

            <div id="quaternion-list-container" class="mt-4">
                <label class="block text-sm font-medium text-gray-300 mb-1">Quaternion List</label>
                <pre id="quaternion-list" class="bg-gray-800 text-gray-100 p-2 rounded h-40 overflow-auto text-xs select-all">Click "Visualize Quaternions" to generate the list…</pre>
            </div>

            <div class="mt-6 pt-6 border-t border-gray-700">
                <h2 class="text-lg font-semibold text-white mb-3">About the Visualization</h2>
                <p class="text-sm text-gray-400">
                    This program finds all integer solutions (a, b, c, d) to the equation a² + b² + c² + d² = p, where p
                    is a prime number. By Lagrange's four-square theorem, such solutions exist for any prime. The number
                    of solutions is exactly 8 * (p + 1).
                </p>
                <p class="text-sm text-gray-400 mt-3">
                    Each solution corresponds to an integer quaternion of norm p. These 4D points (a,b,c,d) are
                    projected into 3D space by plotting (b, c, d). The first coordinate, 'a', is represented by the
                    color of the point.
                </p>
                <p class="text-sm text-gray-400 mt-3">
                    The group Q8={±1, ±i, ±j, ±k} acts on these quaternions by left-multiplication, and we can
                    choose a unique representative from each orbit by requiring a>0 and b even; this leaves us with
                    p+1 quaternions, each corresponding to a point in the projective line P¹(Fₚ). The
                    grouping depends on the kernel of the quaternion's matrix representation modulo p. This
                    visualization displays all solutions at once, forming a structure on a 3-sphere.
                </p>
            </div>
            <div class="mt-6 pt-6 border-t border-gray-700 text-center text-xs text-gray-500">
                <p>Rotate: Left Mouse<br>Pan: Right Mouse<br>Zoom: Scroll</p>
            </div>
        </div>

        <!-- Visualization Canvas -->
        <div class="flex-1 relative">
            <div id="canvas-container" class="w-full h-full">
                <canvas id="visualization"></canvas>
            </div>
            <div id="tooltip"
                class="absolute hidden bg-gray-900 bg-opacity-75 text-white text-xs rounded-md px-2 py-1 pointer-events-none">
            </div>
        </div>

        <!-- REMOVE DUPLICATE quaternion-list-container BLOCK BELOW THIS LINE -->
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, labelRenderer, controls;
        let points = [];
        let labels = [];

        // --- Core Logic ---
        function isPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;
            for (let i = 5; i * i <= num; i = i + 6) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
            }
            return true;
        }

        function findXY(p) {
            for (let x = 0; x < p; x++) {
                for (let y = 0; y < p; y++) {
                    if ((x * x + y * y) % p === (p - 1)) {
                        return { x, y };
                    }
                }
            }
            return null; // Should not happen for odd primes
        }

        async function findQuaternions(p, progressBar) {
            const solutions = new Set();
            const limit = Math.floor(Math.sqrt(p));
            const totalSteps = (2 * limit + 1);
            let currentStep = 0;

            function search(currentSum, count, currentSolution) {
                if (count === 4) {
                    if (currentSum === p) {
                        solutions.add(JSON.stringify(currentSolution.slice().sort()));
                        // Add all permutations and signs
                        function generatePermutations(arr) {
                            if (arr.length === 0) return [[]];
                            const firstEl = arr[0];
                            const rest = arr.slice(1);
                            const permsWithoutFirst = generatePermutations(rest);
                            const allPermutations = [];
                            permsWithoutFirst.forEach(perm => {
                                for (let i = 0; i <= perm.length; i++) {
                                    const permWithFirst = [...perm.slice(0, i), firstEl, ...perm.slice(i)];
                                    allPermutations.push(permWithFirst);
                                }
                            });
                            return allPermutations;
                        }

                        const uniquePerms = [...new Set(generatePermutations(currentSolution).map(p => JSON.stringify(p)))].map(p => JSON.parse(p));

                        uniquePerms.forEach(perm => {
                            for (let i = 0; i < 16; i++) {
                                const signedPerm = perm.slice();
                                if ((i & 1) > 0) signedPerm[0] *= -1;
                                if ((i & 2) > 0) signedPerm[1] *= -1;
                                if ((i & 4) > 0) signedPerm[2] *= -1;
                                if ((i & 8) > 0) signedPerm[3] *= -1;
                                if (signedPerm[0] ** 2 + signedPerm[1] ** 2 + signedPerm[2] ** 2 + signedPerm[3] ** 2 === p) {
                                    solutions.add(JSON.stringify(signedPerm));
                                }
                            }
                        });
                    }
                    return;
                }

                const remainingSum = p - currentSum;
                const remainingSlots = 4 - count;
                if (remainingSum < 0) return;

                const maxPossible = Math.floor(Math.sqrt(remainingSum));

                for (let i = 0; i <= maxPossible; i++) {
                    currentSolution[count] = i;
                    search(currentSum + i * i, count + 1, currentSolution);
                }
            }

            // A more direct search for all integer solutions
            const quats = [];
            for (let a = -limit; a <= limit; a++) {
                progressBar.style.width = `${((a + limit) / (2 * limit)) * 100}%`;
                await new Promise(resolve => setTimeout(resolve, 0)); // Allow UI to update
                for (let b = -limit; b <= limit; b++) {
                    for (let c = -limit; c <= limit; c++) {
                        const d2 = p - (a * a + b * b + c * c);
                        if (d2 >= 0) {
                            const d = Math.sqrt(d2);
                            if (d === Math.floor(d)) {
                                quats.push([a, b, c, d]);
                                if (d !== 0) {
                                    quats.push([a, b, c, -d]);
                                }
                            }
                        }
                    }
                }
            }
            return quats;
        }

        // --- THREE.js Visualization ---
        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('visualization'), antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            container.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, labelRenderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);

            // Add axes
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            const axisLabels = ['b', 'c', 'd'];
            const colors = [0xff0000, 0x00ff00, 0x0000ff]; // x, y, z
            for (let i = 0; i < 3; i++) {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'label';
                labelDiv.textContent = axisLabels[i];
                const label = new CSS2DObject(labelDiv);
                const pos = new THREE.Vector3();
                pos.setComponent(i, 5.5);
                label.position.copy(pos);
                scene.add(label);
            }

            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function clearScene() {
            points.forEach(p => scene.remove(p));
            labels.forEach(l => scene.remove(l));
            points = [];
            labels = [];
        }

        function visualize(quaternions, coloredKeys = null) {
            clearScene();

            const p = parseInt(document.getElementById('prime').value);
            const limit = Math.sqrt(p);
            const colorScale = new THREE.Color();
            const material = new THREE.PointsMaterial({ size: 0.2, vertexColors: true });
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            quaternions.forEach(q => {
                const [a, b, c, d] = q;
                positions.push(b, c, d);

                const key = q.join(',');
                const isColored = coloredKeys ? coloredKeys.has(key) : true;
                if (isColored) {
                    // Vivid color by 'a'
                    const hue = 0.5 + 0.5 * (a / limit); // Map [-limit, limit] to [0, 1] for hue
                    colorScale.setHSL(hue, 0.8, 0.6);
                } else {
                    // Muted gray for non-listed quaternions
                    colorScale.setRGB(0.35, 0.35, 0.35);
                }
                colors.push(colorScale.r, colorScale.g, colorScale.b);
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const pointsObject = new THREE.Points(geometry, material);
            scene.add(pointsObject);
            points.push(pointsObject);

            // Add tooltip logic
            const tooltip = document.getElementById('tooltip');
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            raycaster.params.Points.threshold = 0.5;

            const onMouseMove = (event) => {
                const container = document.getElementById('canvas-container');
                const rect = container.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(pointsObject);

                if (intersects.length > 0) {
                    const index = intersects[0].index;
                    const q = quaternions[index];
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${event.clientX + 10}px`;
                    tooltip.style.top = `${event.clientY + 10}px`;
                    tooltip.textContent = `(${q.join(', ')})`;
                } else {
                    tooltip.style.display = 'none';
                }
            };
            renderer.domElement.addEventListener('mousemove', onMouseMove);
        }

        document.getElementById('visualize-btn').addEventListener('click', async () => {
            const p = parseInt(document.getElementById('prime').value);
            if (!isPrime(p) || p % 2 === 0) {
                alert('Please enter an odd prime number.');
                return;
            }

            const solutionDisplay = document.getElementById('solution-display');
            const xySolutionEl = document.getElementById('xy-solution');
            const xy = findXY(p);
            if (xy) {
                xySolutionEl.textContent = `(x, y) = (${xy.x}, ${xy.y})`;
                solutionDisplay.style.display = 'block';
            } else {
                solutionDisplay.style.display = 'none';
            }

            const loadingEl = document.getElementById('loading');
            const progressBar = document.getElementById('progress-bar');
            loadingEl.style.display = 'block';
            progressBar.style.width = '0%';

            try {
                const quats = await findQuaternions(p, progressBar);
                const listEl = document.getElementById('quaternion-list');
                const filtered = quats.filter(([a,b,c,d]) => a > 0 && (a & 1) === 1 && (b & 1) === 0);

                function formatQuat([a,b,c,d]) {
                    let parts = [];
                    if (a !== 0) parts.push(`${a}`);
                    if (b !== 0) parts.push(`${b>0?'+':''}${b}i`);
                    if (c !== 0) parts.push(`${c>0?'+':''}${c}j`);
                    if (d !== 0) parts.push(`${d>0?'+':''}${d}k`);
                    return parts.join('');
                }

                function conjugate([a,b,c,d]) {
                    return [a,-b,-c,-d];
                }

                const seen = new Set();
                const lines = [];
                // Helper: sign of second nonzero coordinate
                function secondNonzeroSign([a,b,c,d]) {
                    const arr = [a,b,c,d];
                    let count = 0;
                    for (const x of arr) {
                        if (x !== 0) {
                            count++;
                            if (count === 2) return Math.sign(x);
                        }
                    }
                    return 0; // fallback
                }
                for (const q of filtered) {
                    const key = q.join(',');
                    const conj = conjugate(q);
                    const keyc = conj.join(',');
                    if (seen.has(key) || seen.has(keyc)) continue;
                    seen.add(key);
                    seen.add(keyc);
                    const s = secondNonzeroSign(q);
                    const left = (s >= 0) ? q : conj; // favor positive; if zero, keep q
                    const right = (left === q) ? conj : q;
                    lines.push(formatQuat(left).padEnd(24) + formatQuat(right));
                }
                listEl.textContent = lines.join('\n');

                // Only color the quaternions that appear in the list
                const coloredKeys = seen; // contains both q and its conjugate keys
                visualize(quats, coloredKeys);
            } catch (e) {
                console.error(e);
                alert("An error occurred while finding quaternions.");
            } finally {
                loadingEl.style.display = 'none';
            }
        });

        init();
        document.getElementById('visualize-btn').click();

    </script>
</body>

</html>