<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globe Game</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        #canvas-wrapper {
            flex-grow: 1;
            transition: all 0.3s ease;
        }

        #plus-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        #plus-button:hover {
            transform: scale(1.1);
            background-color: rgba(255, 255, 255, 1);
        }

        #plus-button.active {
            transform: rotate(45deg);
        }

        #legend-box {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.55);
            color: #fff;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
            box-shadow: 0 2px 10px rgba(0,0,0,0.25);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            pointer-events: none;
        }
        /* Distance badge */
        #distance-box {
            position: absolute;
            top: 80px; /* just below legend */
            left: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.55);
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
            box-shadow: 0 2px 10px rgba(0,0,0,0.25);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            pointer-events: none;
        }

        #side-panel {
            width: 0;
            height: 100vh;
            background-color: rgba(30, 30, 40, 0.95);
            color: white;
            overflow-y: auto;
            transition: width 0.3s ease;
            padding: 0;
            box-sizing: border-box;
        }

        #side-panel.open {
            width: 320px;
            padding: 30px 20px;
        }

        #side-panel h2 {
            margin-top: 0;
            color: #00ff66;
            font-size: 24px;
        }

        #side-panel h3 {
            color: #ff8800;
            margin-top: 25px;
            font-size: 18px;
        }

        .goal-text {
            line-height: 1.6;
            color: #e0e0e0;
            margin-bottom: 20px;
        }

        #moves-display {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            min-height: 24px;
            word-break: break-all;
            color: #00ff66;
        }

        #matrix-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            white-space: pre;
            line-height: 1.8;
            color: #ffffff;
        }

        .matrix-row {
            margin: 4px 0;
        }

        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            font-size: 14px;
            color: #b0b0b0;
        }

        /* === On-screen controls for mobile === */
        #touch-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1100;
            width: 160px;
            height: 160px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 8px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        #touch-controls .spacer { pointer-events: none; }
        .arrow-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            background: rgba(255,255,255,0.9);
            border: none;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.05s ease, background 0.2s ease;
        }
        .arrow-btn:active { transform: scale(0.98); }
        .arrow-btn:focus { outline: none; }

        /* Slightly larger hit area on very small screens */
        @media (max-width: 768px) {
            #touch-controls { width: 200px; height: 200px; gap: 10px; }
            .arrow-btn { font-size: 26px; }
        }

        /* Hide on-screen arrows on wide screens (desktop) */
        @media (min-width: 1025px) {
            #touch-controls { display: none; }
        }
    </style>
    <script>
      window.MathJax = {
        tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
        chtml: { scale: 2 }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" defer></script>
</head>

<body>
    <div id="container">
        <div id="legend-box"></div>
        <div id="distance-box">Distance to Target: — miles</div>
        <div id="canvas-wrapper"></div>
        <button id="plus-button">+</button>
        <!-- On-screen arrow controls for mobile -->
        <div id="touch-controls">
            <div class="spacer"></div>
            <button id="btn-up" class="arrow-btn" aria-label="Move Up">▲</button>
            <div class="spacer"></div>
            <button id="btn-left" class="arrow-btn" aria-label="Move Left">◀</button>
            <div class="spacer"></div>
            <button id="btn-right" class="arrow-btn" aria-label="Move Right">▶</button>
            <div class="spacer"></div>
            <button id="btn-down" class="arrow-btn" aria-label="Move Down">▼</button>
            <div class="spacer"></div>
        </div>
        <div id="side-panel">
            <h2>Globe Navigation Game</h2>
            <div class="goal-text">
                <strong>Goal:</strong> Navigate the globe using the arrow keys. Try to move the character from the green beacon to the orange beacon.
            </div>

            <h3>Move Sequence</h3>
            <div id="moves-display"></div>

            <h3>Matrix from word</h3>
            <div id="matrix-display"></div>

            <div class="instructions">
                <strong>Controls:</strong><br>
                • Arrow Keys: Rotate globe<br>
                • Mouse: Drag to orbit view<br>
                • Scroll: Zoom in/out
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // === Legend: show exact rotation angles for arrow keys ===
        const legendEl = document.getElementById('legend-box');
        const distanceEl = document.getElementById('distance-box');
        const round4 = (n) => Math.round(n * 1e4) / 1e4;
        // L is a rotation about Y with cos=3/5, sin=4/5; U is about X with cos=5/13, sin=12/13
        const xDeg = round4(Math.atan2(4/5, 3/5) * 180 / Math.PI);   // Left/Right
        const yDeg = round4(Math.atan2(12/13, 5/13) * 180 / Math.PI); // Up/Down
        legendEl.innerHTML = `Left/Right: rotate by ${xDeg}&deg;.<br>Up/Down: rotate by ${yDeg}&deg;.`;

        // === Exact rational arithmetic (BigInt) and 3x3 matrix utilities ===
        const BI = (x) => BigInt(x);
        const gcdBI = (a, b) => { a = a < 0n ? -a : a; b = b < 0n ? -b : b; while (b) { const t = a % b; a = b; b = t; } return a; };
        class Frac {
          constructor(num, den = 1n) {
            if (den === 0n) throw new Error('Zero denominator');
            if (den < 0n) { num = -num; den = -den; }
            const g = gcdBI(num, den);
            this.n = num / g; this.d = den / g;
          }
          static from(a, b = 1) { return new Frac(BI(a), BI(b)); }
          add(o) { return new Frac(this.n*o.d + o.n*this.d, this.d*o.d); }
          sub(o) { return new Frac(this.n*o.d - o.n*this.d, this.d*o.d); }
          mul(o) { return new Frac(this.n*o.n, this.d*o.d); }
          inv()   { return new Frac(this.d, this.n); }
          toLatex() {
            if (this.d === 1n) return `${this.n}`;
            let d = this.d;
            let a = 0, b = 0;
            while (d % 5n === 0n) { d /= 5n; a++; }
            while (d % 13n === 0n) { d /= 13n; b++; }
            let factors = [];
            if (a > 0) factors.push(`5^{${a}}`);
            if (b > 0) factors.push(`13^{${b}}`);
            let denomStr = factors.length > 0 ? factors.join(' ') : `${this.d}`;
            return `\\frac{${this.n}}{${denomStr}}`;
          }
        }
        const F = (a, b = 1) => Frac.from(a, b);
        const I3 = () => [[F(1),F(0),F(0)],[F(0),F(1),F(0)],[F(0),F(0),F(1)]];
        const matMul3 = (A,B) => {
          const C = [[F(0),F(0),F(0)],[F(0),F(0),F(0)],[F(0),F(0),F(0)]];
          for (let i=0;i<3;i++) for (let j=0;j<3;j++) {
            let s = F(0);
            for (let k=0;k<3;k++) s = s.add(A[i][k].mul(B[k][j]));
            C[i][j] = s;
          }
          return C;
        };

        // Get DOM elements
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const plusButton = document.getElementById('plus-button');
        const sidePanel = document.getElementById('side-panel');
        const movesDisplay = document.getElementById('moves-display');
        const matrixDisplay = document.getElementById('matrix-display');

        // Track moves and cumulative matrix (exact for display)
        let moves = [];
        let cumulativeMatrixExact = I3();

        // Panel state
        let panelOpen = false;

        // 1. Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setSize(window.innerWidth, window.innerHeight);
        canvasWrapper.appendChild(renderer.domElement);

        camera.position.z = 20;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // 2. Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2.5, 500);
        pointLight.position.set(20, 10, 25);
        scene.add(pointLight);

        const backLight = new THREE.PointLight(0xffffff, 2.0, 500);
        backLight.position.set(-20, -10, -25);
        scene.add(backLight);

        // 3. Create the Earth
        const textureLoader = new THREE.TextureLoader();
        const earthTexture = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg');
        earthTexture.colorSpace = THREE.SRGBColorSpace;
        const earthMaterial = new THREE.MeshBasicMaterial({ map: earthTexture });
        const earthGeometry = new THREE.SphereGeometry(10, 64, 64);
        const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earthMesh);

        // 3.5 Keyboard-driven globe moves (animated)
        let targetQuaternion = new THREE.Quaternion(); // Target orientation

        // Initialize view so Santa Cruz, CA (lat 36.9741° N, lon 122.0308° W) is at the center
        const lat = THREE.MathUtils.degToRad(36.9741);
        const lon = THREE.MathUtils.degToRad(-122.0308);
        // Convert to 3D position on unit sphere using Three.js' common lat/lon mapping
        // phi: polar angle from +Y; theta: azimuth measured from -Z toward +X
        const phi = Math.PI / 2 - lat;
        const theta = lon + Math.PI;
        const v = new THREE.Vector3(
            -Math.sin(phi) * Math.cos(theta),
            Math.cos(phi),
            Math.sin(phi) * Math.sin(theta)
        ).normalize();
        // Rotate so that this surface point faces the camera (+Z direction)
        const qCenter = new THREE.Quaternion().setFromUnitVectors(v, new THREE.Vector3(0, 0, 1));
        earthMesh.quaternion.copy(qCenter);
        targetQuaternion.copy(earthMesh.quaternion);
        // (Optional but harmless) Make sure camera and controls target are centered
        camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);

        // === Beacon helper + two beacons (Santa Cruz + Nashville) ===
        const earthRadius = 10;            // matches SphereGeometry radius
        const beaconOffset = 0.0;          // place beacon bases flush with the surface

        function addBeaconAtLatLon(latDeg, lonDeg, colorHex) {
            // Convert lat/lon in degrees to unit normal in the globe's coordinates
            const lat = THREE.MathUtils.degToRad(latDeg);
            const lon = THREE.MathUtils.degToRad(lonDeg);
            const phi = Math.PI / 2 - lat;
            const theta = lon + Math.PI;
            const n = new THREE.Vector3(
                -Math.sin(phi) * Math.cos(theta),
                Math.cos(phi),
                Math.sin(phi) * Math.sin(theta)
            ).normalize();

            // Group that rides with the Earth
            const g = new THREE.Group();
            earthMesh.add(g);
            g.position.copy(n.clone().multiplyScalar(earthRadius + beaconOffset));
            g.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), n));

            // Simple emissive material in the requested color
            const poleMat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 0.6, metalness: 0.1, roughness: 0.4 });
            const bulbMat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 1.2, metalness: 0.0, roughness: 0.2 });

            // Pole + bulb (compact, same size for all beacons)
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.7, 16), poleMat);
            pole.position.y = 0.35;
            g.add(pole);
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), bulbMat);
            bulb.position.y = 0.7;
            g.add(bulb);

            // Light glow
            const light = new THREE.PointLight(colorHex, 2.5, 20, 2.0);
            light.position.set(0, 0.8, 0);
            g.add(light);
            return g;
        }

        function addBeaconAtXYZ(vec3, colorHex) {
            // Normalize the input vector to ensure placement on the sphere surface
            const n = vec3.clone().normalize();

            // Group that rides with the Earth
            const g = new THREE.Group();
            earthMesh.add(g);
            g.position.copy(n.clone().multiplyScalar(earthRadius + beaconOffset));
            g.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), n));

            // Materials (match style used in addBeaconAtLatLon)
            const poleMat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 0.6, metalness: 0.1, roughness: 0.4 });
            const bulbMat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 1.2, metalness: 0.0, roughness: 0.2 });

            // Pole + bulb
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.7, 16), poleMat);
            pole.position.y = 0.35;
            g.add(pole);
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), bulbMat);
            bulb.position.y = 0.7;
            g.add(bulb);

            // Light glow
            const light = new THREE.PointLight(colorHex, 2.5, 20, 2.0);
            light.position.set(0, 0.8, 0);
            g.add(light);
            return g;
        }

        function addBeaconAtABC(a, b, c, colorHex, den = 105625) {
            // Map (a,b,c) to globe coords via (x,y,z) = (a, c, -b), then scale by denominator
            const x = a / den;
            const y = c / den;
            const z = (-b) / den;
            return addBeaconAtXYZ(new THREE.Vector3(x, y, z), colorHex);
        }


        // === User-specified beacons using (a,b,c) with (x,y,z)=(a,c,-b) and denominator 105625 ===
        const SCBeacon = addBeaconAtABC(-44568, -71676, 63505, 0x00ff66, 105625);
        const NashBeacon = addBeaconAtABC(4644, -85175, 62292, 0xff8800, 105625);

        // === Little character perched above the RED beacon (fixed in world space) ===
        const character = new THREE.Group();
        scene.add(character); // keep in world space so the world rotates under him

        // Place him at the top of the red beacon in *world* coordinates, then leave him there
        SCBeacon.updateWorldMatrix(true, true);
        const charLocal = new THREE.Vector3(0, 1.05, 0); // offset above beacon base (matches beacon geometry)
        const charWorld = SCBeacon.localToWorld(charLocal.clone());
        character.position.copy(charWorld);

        // Match initial orientation so +Y points along the outward normal at the beacon
        const charQuat = new THREE.Quaternion();
        SCBeacon.getWorldQuaternion(charQuat);
        character.quaternion.copy(charQuat);

        // Simple stylized figure: body (capsule-ish) + head
        const charBodyMat = new THREE.MeshStandardMaterial({ color: 0x3333ff, metalness: 0.05, roughness: 0.6 });
        const charHeadMat = new THREE.MeshStandardMaterial({ color: 0xffe0bd, metalness: 0.0, roughness: 0.9 });

        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.28, 12), charBodyMat);
        body.position.y = 0.14;
        character.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), charHeadMat);
        head.position.y = 0.34;
        character.add(head);

        // Tiny point light to make the character readable
        const charLight = new THREE.PointLight(0xffffff, 0.6, 2.0, 2.0);
        charLight.position.set(0, 0.4, 0);
        character.add(charLight);
        // === End little character ===

        function makeM4(a11, a12, a13, a21, a22, a23, a31, a32, a33) {
            const m = new THREE.Matrix4();
            m.set(
                a11, a12, a13, 0,
                a21, a22, a23, 0,
                a31, a32, a33, 0,
                0, 0, 0, 1
            );
            return m;
        }

        //        const solutionDen = BI(105625^2);
       //     const solution.set(
       //         -4572516257 / solutionDen, -5478224724 / solutionDen, -8576233380 / solutionDen, 0,
        //        9026019900 / solutionDen, 2159536800 / solutionDen, -6191768375 / solutionDen, 0,
         //       4700392524 / solutionDen, -9476079607 / solutionDen, 3546950160 / solutionDen, 0,
           //     0, 0, 0, 1);


        // Define matrices as before
        const L = makeM4(3 / 5, 0, 4 / 5, 0, 1, 0, -4 / 5, 0, 3 / 5);
        const Linv = L.clone().invert();
        const U = makeM4(1, 0, 0, 0, 5 / 13, -12 / 13, 0, 12 / 13, 5 / 13);
        const Uinv = U.clone().invert();

        // Exact (rational) 3x3 versions for display math (premultiply order matches THREE path)
        const Lx   = [[F(3,5), F(0),   F(4,5)], [F(0), F(1), F(0)], [F(-4,5), F(0), F(3,5)]];
        const Linvx= [[F(3,5), F(0), F(-4,5)], [F(0), F(1), F(0)], [F(4,5),  F(0), F(3,5)]];
        const Ux   = [[F(1), F(0), F(0)], [F(0), F(5,13), F(-12,13)], [F(0), F(12,13), F(5,13)]];
        const Uinvx= [[F(1), F(0), F(0)], [F(0), F(5,13), F(12,13)],  [F(0), F(-12,13), F(5,13)]];

        // Convert rotation matrices to quaternions for smooth interpolation
        const qL = new THREE.Quaternion().setFromRotationMatrix(L);
        const qLinv = new THREE.Quaternion().setFromRotationMatrix(Linv);
        const qU = new THREE.Quaternion().setFromRotationMatrix(U);
        const qUinv = new THREE.Quaternion().setFromRotationMatrix(Uinv);

        // Function to update the displays
        function updateDisplays() {
            // Update moves display with reduced word (canceling adjacent inverses, no spaces)
            function reduceWord(wordArr) {
                let changed = true;
                while (changed) {
                    changed = false;
                    for (let i = 0; i < wordArr.length - 1; i++) {
                        const pair = wordArr[i] + wordArr[i+1];
                        if (pair === 'LR' || pair === 'RL' || pair === 'DU' || pair === 'UD') {
                            wordArr.splice(i, 2);
                            changed = true;
                            break;
                        }
                    }
                }
                return wordArr;
            }
            const reduced = reduceWord([...moves]);
            movesDisplay.textContent = reduced.length > 0 ? reduced.join('') : '(no moves yet)';

            // Update matrix display (LaTeX via MathJax)
            const M = cumulativeMatrixExact;
            const row = (r) => `${M[r][0].toLatex()} & ${M[r][1].toLatex()} & ${M[r][2].toLatex()}`;
            const latex = `\\[\\begin{pmatrix} ${row(0)} \\\\ ${row(1)} \\\\ ${row(2)} \\end{pmatrix}\\]`;
            matrixDisplay.innerHTML = latex;
            if (window.MathJax && window.MathJax.typesetPromise) { window.MathJax.typesetPromise([matrixDisplay]); }
        }

        // Initialize displays
        updateDisplays();

        // Helper: apply a single move (L, R, U, D) used by both keyboard and touch
        function applyMove(moveChar) {
            let moveMatrix = null;
            let moveExact = null;
            switch (moveChar) {
                case 'L':
                    targetQuaternion.premultiply(qL);
                    moveMatrix = L;     moveExact = Lx;     break;
                case 'R':
                    targetQuaternion.premultiply(qLinv);
                    moveMatrix = Linv;  moveExact = Linvx;  break;
                case 'U':
                    targetQuaternion.premultiply(qU);
                    moveMatrix = U;     moveExact = Ux;     break;
                case 'D':
                    targetQuaternion.premultiply(qUinv);
                    moveMatrix = Uinv;  moveExact = Uinvx;  break;
                default:
                    return; // ignore unknown
            }
            // Update exact display math
            if (moveMatrix && moveExact) {
                moves.push(moveChar);
                cumulativeMatrixExact = matMul3(moveExact, cumulativeMatrixExact);
                updateDisplays();
            }
        }

        window.addEventListener('keydown', (e) => {
            let move = null;
            switch (e.key) {
                case 'ArrowLeft':  move = 'L'; break;
                case 'ArrowRight': move = 'R'; break;
                case 'ArrowUp':    move = 'U'; break;
                case 'ArrowDown':  move = 'D'; break;
                default: return;
            }
            e.preventDefault();
            applyMove(move);
        });

        // === Touch/mobile controls ===
        const btnUp = document.getElementById('btn-up');
        const btnDown = document.getElementById('btn-down');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');

        function bindButton(btn, moveChar) {
            if (!btn) return;
            const fire = (ev) => { ev.preventDefault(); ev.stopPropagation(); applyMove(moveChar); };
            btn.addEventListener('pointerdown', fire);
            btn.addEventListener('click', fire);
        }

        bindButton(btnUp, 'U');
        bindButton(btnDown, 'D');
        bindButton(btnLeft, 'L');
        bindButton(btnRight, 'R');

        // === Great-circle distance (geodesic on sphere) from character's subpoint to NashBeacon ===
        function computeGeodesicMiles() {
            // Earth mean radius in miles
            const R_miles = 3958.7613;
            // Center of Earth in world coords
            const center = new THREE.Vector3();
            earthMesh.getWorldPosition(center);
            // Unit direction from center to the character's subpoint (project character to sphere)
            const uChar = character.position.clone().sub(center).normalize();
            // Unit direction from center to the NashBeacon base point
            const pTargetWorld = new THREE.Vector3();
            NashBeacon.getWorldPosition(pTargetWorld);
            const uTarget = pTargetWorld.sub(center).normalize();
            // Central angle and arc length
            const dot = THREE.MathUtils.clamp(uChar.dot(uTarget), -1, 1);
            const angle = Math.acos(dot); // radians
            return R_miles * angle;
        }

        // Plus button click handler
        plusButton.addEventListener('click', () => {
            panelOpen = !panelOpen;

            if (panelOpen) {
                sidePanel.classList.add('open');
                plusButton.classList.add('active');
            } else {
                sidePanel.classList.remove('open');
                plusButton.classList.remove('active');
            }

            // Delay the resize to match the animation
            setTimeout(() => {
                handleResize();
            }, 50);
        });

        // 4. Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Smoothly interpolate the earth's current quaternion towards the target
            const animationStep = 0.08; // Adjust for faster/slower animation
            if (!earthMesh.quaternion.equals(targetQuaternion)) {
                earthMesh.quaternion.slerp(targetQuaternion, animationStep);
            }

            // Update distance-to-target UI
            if (distanceEl) {
                const miles = computeGeodesicMiles();
                distanceEl.textContent = `Distance to Target: ${miles.toFixed(1)} miles`;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resizing
        function handleResize() {
            const width = panelOpen ? window.innerWidth - 320 : window.innerWidth;
            camera.aspect = width / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(width, window.innerHeight);
        }

        window.addEventListener('resize', handleResize);

        animate();
    </script>
</body>

</html>