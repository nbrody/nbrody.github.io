<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globe Game</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        #canvas-wrapper {
            flex-grow: 1;
            transition: all 0.3s ease;
        }

        #plus-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        #plus-button:hover {
            transform: scale(1.1);
            background-color: rgba(255, 255, 255, 1);
        }

        #plus-button.active {
            transform: rotate(45deg);
        }

        #side-panel {
            width: 0;
            height: 100vh;
            background-color: rgba(30, 30, 40, 0.95);
            color: white;
            overflow-y: auto;
            transition: width 0.3s ease;
            padding: 0;
            box-sizing: border-box;
        }

        #side-panel.open {
            width: 320px;
            padding: 30px 20px;
        }

        #side-panel h2 {
            margin-top: 0;
            color: #00ff66;
            font-size: 24px;
        }

        #side-panel h3 {
            color: #ff8800;
            margin-top: 25px;
            font-size: 18px;
        }

        .goal-text {
            line-height: 1.6;
            color: #e0e0e0;
            margin-bottom: 20px;
        }

        #moves-display {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            min-height: 24px;
            word-break: break-all;
            color: #00ff66;
        }

        #matrix-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            white-space: pre;
            line-height: 1.8;
            color: #ffffff;
        }

        .matrix-row {
            margin: 4px 0;
        }

        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            font-size: 14px;
            color: #b0b0b0;
        }
    </style>
    <script>
      window.MathJax = {
        tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
        chtml: { scale: 2 }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" defer></script>
</head>

<body>
    <div id="container">
        <div id="canvas-wrapper"></div>
        <button id="plus-button">+</button>
        <div id="side-panel">
            <h2>Globe Navigation Game</h2>
            <div class="goal-text">
                <strong>Goal:</strong> Navigate the globe using the arrow keys. Try to move the character from
                the green beacon (Santa Cruz, CA) to the orange beacon (Nashville, TN).
            </div>

            <h3>Move Sequence</h3>
            <div id="moves-display"></div>

            <h3>Matrix from word</h3>
            <div id="matrix-display"></div>

            <div class="instructions">
                <strong>Controls:</strong><br>
                • Arrow Keys: Rotate globe<br>
                • Mouse: Drag to orbit view<br>
                • Scroll: Zoom in/out
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // === Exact rational arithmetic (BigInt) and 3x3 matrix utilities ===
        const BI = (x) => BigInt(x);
        const gcdBI = (a, b) => { a = a < 0n ? -a : a; b = b < 0n ? -b : b; while (b) { const t = a % b; a = b; b = t; } return a; };
        class Frac {
          constructor(num, den = 1n) {
            if (den === 0n) throw new Error('Zero denominator');
            if (den < 0n) { num = -num; den = -den; }
            const g = gcdBI(num, den);
            this.n = num / g; this.d = den / g;
          }
          static from(a, b = 1) { return new Frac(BI(a), BI(b)); }
          add(o) { return new Frac(this.n*o.d + o.n*this.d, this.d*o.d); }
          sub(o) { return new Frac(this.n*o.d - o.n*this.d, this.d*o.d); }
          mul(o) { return new Frac(this.n*o.n, this.d*o.d); }
          inv()   { return new Frac(this.d, this.n); }
          toLatex() {
            if (this.d === 1n) return `${this.n}`;
            let d = this.d;
            let a = 0, b = 0;
            while (d % 5n === 0n) { d /= 5n; a++; }
            while (d % 13n === 0n) { d /= 13n; b++; }
            let factors = [];
            if (a > 0) factors.push(`5^{${a}}`);
            if (b > 0) factors.push(`13^{${b}}`);
            let denomStr = factors.length > 0 ? factors.join(' ') : `${this.d}`;
            return `\\frac{${this.n}}{${denomStr}}`;
          }
        }
        const F = (a, b = 1) => Frac.from(a, b);
        const I3 = () => [[F(1),F(0),F(0)],[F(0),F(1),F(0)],[F(0),F(0),F(1)]];
        const matMul3 = (A,B) => {
          const C = [[F(0),F(0),F(0)],[F(0),F(0),F(0)],[F(0),F(0),F(0)]];
          for (let i=0;i<3;i++) for (let j=0;j<3;j++) {
            let s = F(0);
            for (let k=0;k<3;k++) s = s.add(A[i][k].mul(B[k][j]));
            C[i][j] = s;
          }
          return C;
        };

        // Get DOM elements
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const plusButton = document.getElementById('plus-button');
        const sidePanel = document.getElementById('side-panel');
        const movesDisplay = document.getElementById('moves-display');
        const matrixDisplay = document.getElementById('matrix-display');

        // Track moves and cumulative matrix (exact for display)
        let moves = [];
        let cumulativeMatrixExact = I3();

        // Panel state
        let panelOpen = false;

        // 1. Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setSize(window.innerWidth, window.innerHeight);
        canvasWrapper.appendChild(renderer.domElement);

        camera.position.z = 20;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // 2. Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2.5, 500);
        pointLight.position.set(20, 10, 25);
        scene.add(pointLight);

        const backLight = new THREE.PointLight(0xffffff, 2.0, 500);
        backLight.position.set(-20, -10, -25);
        scene.add(backLight);

        // 3. Create the Earth
        const textureLoader = new THREE.TextureLoader();
        const earthTexture = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg');
        earthTexture.colorSpace = THREE.SRGBColorSpace;
        const earthMaterial = new THREE.MeshBasicMaterial({ map: earthTexture });
        const earthGeometry = new THREE.SphereGeometry(10, 64, 64);
        const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earthMesh);

        // 3.5 Keyboard-driven globe moves (animated)
        let targetQuaternion = new THREE.Quaternion(); // Target orientation

        // Initialize view so Santa Cruz, CA (lat 36.9741° N, lon 122.0308° W) is at the center
        const lat = THREE.MathUtils.degToRad(36.9741);
        const lon = THREE.MathUtils.degToRad(-122.0308);
        // Convert to 3D position on unit sphere using Three.js' common lat/lon mapping
        // phi: polar angle from +Y; theta: azimuth measured from -Z toward +X
        const phi = Math.PI / 2 - lat;
        const theta = lon + Math.PI;
        const v = new THREE.Vector3(
            -Math.sin(phi) * Math.cos(theta),
            Math.cos(phi),
            Math.sin(phi) * Math.sin(theta)
        ).normalize();
        // Rotate so that this surface point faces the camera (+Z direction)
        const qCenter = new THREE.Quaternion().setFromUnitVectors(v, new THREE.Vector3(0, 0, 1));
        earthMesh.quaternion.copy(qCenter);
        targetQuaternion.copy(earthMesh.quaternion);
        // (Optional but harmless) Make sure camera and controls target are centered
        camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);

        // === Beacon helper + two beacons (Santa Cruz + Nashville) ===
        const earthRadius = 10;            // matches SphereGeometry radius
        const beaconOffset = 0.0;          // place beacon bases flush with the surface

        function addBeaconAtLatLon(latDeg, lonDeg, colorHex) {
            // Convert lat/lon in degrees to unit normal in the globe's coordinates
            const lat = THREE.MathUtils.degToRad(latDeg);
            const lon = THREE.MathUtils.degToRad(lonDeg);
            const phi = Math.PI / 2 - lat;
            const theta = lon + Math.PI;
            const n = new THREE.Vector3(
                -Math.sin(phi) * Math.cos(theta),
                Math.cos(phi),
                Math.sin(phi) * Math.sin(theta)
            ).normalize();

            // Group that rides with the Earth
            const g = new THREE.Group();
            earthMesh.add(g);
            g.position.copy(n.clone().multiplyScalar(earthRadius + beaconOffset));
            g.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), n));

            // Simple emissive material in the requested color
            const poleMat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 0.6, metalness: 0.1, roughness: 0.4 });
            const bulbMat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 1.2, metalness: 0.0, roughness: 0.2 });

            // Pole + bulb (compact, same size for all beacons)
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.7, 16), poleMat);
            pole.position.y = 0.35;
            g.add(pole);
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), bulbMat);
            bulb.position.y = 0.7;
            g.add(bulb);

            // Light glow
            const light = new THREE.PointLight(colorHex, 2.5, 20, 2.0);
            light.position.set(0, 0.8, 0);
            g.add(light);
            return g;
        }

        const scBeacon = addBeaconAtLatLon(36.9741, -122.0308, 0x00ff66);
        const nashBeacon = addBeaconAtLatLon(36.1627, -86.7816, 0xff8800);

        // === Little character perched above Santa Cruz (fixed in world space) ===
        const character = new THREE.Group();
        scene.add(character); // keep in world space so the world rotates under him

        // Place him at the top of the Santa Cruz beacon in *world* coordinates, then leave him there
        scBeacon.updateWorldMatrix(true, true);
        const charLocal = new THREE.Vector3(0, 1.05, 0); // same offset as before, relative to beacon
        const charWorld = scBeacon.localToWorld(charLocal.clone());
        character.position.copy(charWorld);

        // Match initial orientation, then remain fixed
        const charQuat = new THREE.Quaternion();
        scBeacon.getWorldQuaternion(charQuat);
        character.quaternion.copy(charQuat);

        // Simple stylized figure: body (capsule-ish) + head
        const charBodyMat = new THREE.MeshStandardMaterial({ color: 0x3333ff, metalness: 0.05, roughness: 0.6 });
        const charHeadMat = new THREE.MeshStandardMaterial({ color: 0xffe0bd, metalness: 0.0, roughness: 0.9 });

        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.28, 12), charBodyMat);
        body.position.y = 0.14;
        character.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), charHeadMat);
        head.position.y = 0.34;
        character.add(head);

        // Tiny point light to make the character readable
        const charLight = new THREE.PointLight(0xffffff, 0.6, 2.0, 2.0);
        charLight.position.set(0, 0.4, 0);
        character.add(charLight);
        // === End little character ===

        function makeM4(a11, a12, a13, a21, a22, a23, a31, a32, a33) {
            const m = new THREE.Matrix4();
            m.set(
                a11, a12, a13, 0,
                a21, a22, a23, 0,
                a31, a32, a33, 0,
                0, 0, 0, 1
            );
            return m;
        }

        // Define matrices as before
        const L = makeM4(3 / 5, 0, 4 / 5, 0, 1, 0, -4 / 5, 0, 3 / 5);
        const Linv = L.clone().invert();
        const U = makeM4(1, 0, 0, 0, 5 / 13, -12 / 13, 0, 12 / 13, 5 / 13);
        const Uinv = U.clone().invert();

        // Exact (rational) 3x3 versions for display math (premultiply order matches THREE path)
        const Lx   = [[F(3,5), F(0),   F(4,5)], [F(0), F(1), F(0)], [F(-4,5), F(0), F(3,5)]];
        const Linvx= [[F(3,5), F(0), F(-4,5)], [F(0), F(1), F(0)], [F(4,5),  F(0), F(3,5)]];
        const Ux   = [[F(1), F(0), F(0)], [F(0), F(5,13), F(-12,13)], [F(0), F(12,13), F(5,13)]];
        const Uinvx= [[F(1), F(0), F(0)], [F(0), F(5,13), F(12,13)],  [F(0), F(-12,13), F(5,13)]];

        // Convert rotation matrices to quaternions for smooth interpolation
        const qL = new THREE.Quaternion().setFromRotationMatrix(L);
        const qLinv = new THREE.Quaternion().setFromRotationMatrix(Linv);
        const qU = new THREE.Quaternion().setFromRotationMatrix(U);
        const qUinv = new THREE.Quaternion().setFromRotationMatrix(Uinv);

        // Function to update the displays
        function updateDisplays() {
            // Update moves display with reduced word (canceling adjacent inverses, no spaces)
            function reduceWord(wordArr) {
                let changed = true;
                while (changed) {
                    changed = false;
                    for (let i = 0; i < wordArr.length - 1; i++) {
                        const pair = wordArr[i] + wordArr[i+1];
                        if (pair === 'LR' || pair === 'RL' || pair === 'DU' || pair === 'UD') {
                            wordArr.splice(i, 2);
                            changed = true;
                            break;
                        }
                    }
                }
                return wordArr;
            }
            const reduced = reduceWord([...moves]);
            movesDisplay.textContent = reduced.length > 0 ? reduced.join('') : '(no moves yet)';

            // Update matrix display (LaTeX via MathJax)
            const M = cumulativeMatrixExact;
            const row = (r) => `${M[r][0].toLatex()} & ${M[r][1].toLatex()} & ${M[r][2].toLatex()}`;
            const latex = `\\[\\begin{pmatrix} ${row(0)} \\\\ ${row(1)} \\\\ ${row(2)} \\end{pmatrix}\\]`;
            matrixDisplay.innerHTML = latex;
            if (window.MathJax && window.MathJax.typesetPromise) { window.MathJax.typesetPromise([matrixDisplay]); }
        }

        // Initialize displays
        updateDisplays();

        window.addEventListener('keydown', (e) => {
            let moveMatrix = null;
            let moveChar = '';
            let moveExact = null;

            // Instead of applying the matrix directly, update the target quaternion
            switch (e.key) {
                case 'ArrowLeft':
                    targetQuaternion.premultiply(qL);
                    moveMatrix = L.clone();
                    moveExact = Lx;
                    moveChar = 'L';
                    break;
                case 'ArrowRight':
                    targetQuaternion.premultiply(qLinv);
                    moveMatrix = Linv.clone();
                    moveExact = Linvx;
                    moveChar = 'R';
                    break;
                case 'ArrowUp':
                    targetQuaternion.premultiply(qU);
                    moveMatrix = U.clone();
                    moveExact = Ux;
                    moveChar = 'U';
                    break;
                case 'ArrowDown':
                    targetQuaternion.premultiply(qUinv);
                    moveMatrix = Uinv.clone();
                    moveExact = Uinvx;
                    moveChar = 'D';
                    break;
                default:
                    return;
            }
            e.preventDefault();

            // Update moves and cumulative matrix
            if (moveMatrix && moveChar && moveExact) {
                moves.push(moveChar);
                cumulativeMatrixExact = matMul3(moveExact, cumulativeMatrixExact);
                updateDisplays();
            }
        });

        // Plus button click handler
        plusButton.addEventListener('click', () => {
            panelOpen = !panelOpen;

            if (panelOpen) {
                sidePanel.classList.add('open');
                plusButton.classList.add('active');
            } else {
                sidePanel.classList.remove('open');
                plusButton.classList.remove('active');
            }

            // Delay the resize to match the animation
            setTimeout(() => {
                handleResize();
            }, 50);
        });

        // 4. Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Smoothly interpolate the earth's current quaternion towards the target
            const animationStep = 0.08; // Adjust for faster/slower animation
            if (!earthMesh.quaternion.equals(targetQuaternion)) {
                earthMesh.quaternion.slerp(targetQuaternion, animationStep);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resizing
        function handleResize() {
            const width = panelOpen ? window.innerWidth - 320 : window.innerWidth;
            camera.aspect = width / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(width, window.innerHeight);
        }

        window.addEventListener('resize', handleResize);

        animate();
    </script>
</body>

</html>