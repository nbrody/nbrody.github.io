<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quaternion Calculator - Dynamic Primes</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 2em;
            background-color: #f4f4f9;
            color: #333;
        }

        h1, h2 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1em;
            background-color: white;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .prime-input-section {
            text-align: center;
            padding: 20px;
            background-color: #ecf0f1;
            border-radius: 8px;
            margin: 20px 0;
        }

        .prime-input-section label {
            font-weight: bold;
            margin-right: 10px;
        }

        .prime-input-section input {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
            width: 300px;
        }

        .prime-input-section button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 10px;
        }

        .prime-input-section button:hover {
            background-color: #2980b9;
        }

        #status-message {
            margin-top: 10px;
            font-style: italic;
            color: #7f8c8d;
        }

        #relations-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .legend-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .legend-title {
            margin: 0;
            font-weight: 600;
            color: #2c3e50;
        }

        .legend {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .legend-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }

        .legend span {
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 999px;
        }

        .relation-square {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            background-color: #fdfdfd;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            text-align: center;
        }

        .squares-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 4px;
            align-items: start;
        }

        .square-cell {
            text-align: center;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 20px;
            margin-top: 20px;
            background-color: #ecf0f1;
            border-radius: 8px;
        }

        .controls label {
            font-weight: bold;
        }

        select, input[type="range"] {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
        }

        #vis-container, #square-complex-container {
            width: 100%;
            height: 600px;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #ccc;
        }

        #square-complex-container {
            height: 500px;
            background-color: #f9f9f9;
        }

        .generators-section {
            margin: 20px 0;
        }

        .generators-content {
            display: flex;
            gap: 20px;
            min-height: 500px;
        }

        .generator-vis-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .generator-info-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .generator-filter {
            text-align: center;
            margin-bottom: 15px;
            padding: 15px;
            background-color: #ecf0f1;
            border-radius: 8px;
        }

        .generator-filter label {
            font-weight: bold;
            margin-right: 10px;
        }

        .generator-filter select {
            padding: 5px 10px;
        }

        #generators-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 15px;
            background-color: #fdfdfd;
            border-radius: 8px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            overflow-y: auto;
            flex: 1;
        }

        .generators-legend-title {
            margin: 0 0 8px 0;
            font-weight: 600;
            color: #2c3e50;
            text-align: center;
        }

        .generators-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }

        .generators-row span {
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 999px;
        }

        #generator-vis-container {
            width: 100%;
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #111827;
            position: relative;
        }

        #generator-vis-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* PQ Relations Table */
        #pq-relations-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            padding: 20px;
        }

        .pq-relation-table-wrapper {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #dee2e6;
        }

        .pq-relation-table-wrapper h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .pq-relation-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0 auto;
            font-size: 14px;
        }

        .pq-relation-table th,
        .pq-relation-table td {
            border: 1px solid #dee2e6;
            padding: 6px;
            text-align: center;
            min-width: 100px;
            min-height: 100px;
        }

        .pq-relation-table th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }

        .pq-relation-table td {
            background-color: white;
        }

        .pq-relation-table .row-header {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }

        .pq-relation-cell {
            font-size: 12px;
            cursor: help;
            padding: 4px;
        }

        .pq-relation-cell svg {
            display: block;
            margin: 0 auto;
        }

        /* Responsive design for smaller screens */
        @media (max-width: 968px) {
            .generators-content {
                flex-direction: column;
            }

            #generator-vis-container {
                height: 400px;
            }

            .pq-relation-table {
                font-size: 11px;
            }

            .pq-relation-cell {
                font-size: 10px;
            }
        }
    </style>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$','$$'], ['\\[','\\]']]
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
    <div class="container">
        <h1>Quaternion Calculator</h1>
        <p style="text-align: center;">Computations in $\mathsf{SO}_3(\mathbb{Z}[1/n])$</p>

        <div class="prime-input-section">
            <label for="prime-input">Odd Primes:</label>
            <input type="text" id="prime-input" placeholder="e.g., 5, 13" value="5, 13">
            <button id="compute-button">Compute</button>
            <div id="status-message"></div>
        </div>

        <hr>

        <div class="generators-section">
            <h2>Generators</h2>
            <div class="generators-content">
                <div class="generator-vis-panel">
                    <div id="generator-vis-container"></div>
                </div>
                <div class="generator-info-panel">
                    <div class="generator-filter">
                        <label for="prime-filter">Filter by Prime:</label>
                        <select id="prime-filter">
                            <option value="all">All Primes</option>
                        </select>
                    </div>
                    <div id="xy-solution-display" style="display: none; margin-bottom: 10px; padding: 10px; background-color: #e8f4f8; border-radius: 8px; text-align: center;">
                        <p style="margin: 0; font-size: 0.9em; color: #2c3e50;">
                            <strong>x² + y² ≡ -1 (mod p)</strong><br>
                            <span id="xy-solution-text"></span>
                        </p>
                    </div>
                    <div id="generators-container">
                        <p style="text-align: center; color: #7f8c8d;">Compute generators first.</p>
                    </div>
                </div>
            </div>
        </div>

        <hr>

        <h2>Relations</h2>
        <p style="text-align: center; color: #7f8c8d;">
            For each pair of primes $p$ and $q$, there are $(p+1)(q+1)$ quaternions of norm $pq$.<br>
            Each can be factored as $p_i \cdot q_j = q_k \cdot p_\ell$ where $i \in \mathbb{F}_p \mathbb{P}^1$ and $j \in \mathbb{F}_q \mathbb{P}^1$.
        </p>
        <div id="pq-relations-container">
            <p style="text-align: center; color: #7f8c8d;">Compute generators for at least 2 primes.</p>
        </div>

        <hr>

        <h2>Presentation of the Group</h2>
        <div id="relations-container"></div>

        <hr>

        <h2>Interactive Cayley Graph on $S^2$</h2>
        <div class="controls">
            <label for="gen-x">X-Axis Generator:</label>
            <select id="gen-x"></select>
            <label for="gen-y">Y-Axis Generator:</label>
            <select id="gen-y"></select>
            <label for="depth-slider">Depth:</label>
            <input type="range" id="depth-slider" min="1" max="9" value="4">
            <span id="depth-value">4</span>
        </div>
        <div id="vis-container"></div>

        <hr>

        <h2>Square Complex</h2>
        <div id="square-complex-container"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.171.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.171.0/examples/jsm/"
        }
    }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import {
            QMath,
            computeRelations,
            generateColors
        } from './generatorComputation.js';

        // Add vector/pure quaternion conversion helpers
        QMath.vecToPure = (v) => [0, v.x, v.y, v.z];
        QMath.pureToVec = (q) => new THREE.Vector3(q[1], q[2], q[3]);
        // Act on a pure quaternion by conjugation: q * v * q^(-1)
        QMath.act = (q, v) => {
            const qInv = QMath.inverse(q);
            return QMath.multiply(QMath.multiply(q, v), qInv);
        };
        import {
            generateGeneratorsForPrimes,
            createGeneratorObject,
            formatQuaternion,
            findXYSolution,
            matchQuaternionToP1
        } from './primeQuaternionFilters.js';
        import { computeProjectiveRelations } from './projectiveQuaternion.js';

        // --- GLOBAL STATE ---
        let GENERATORS = {};
        let RELATIONS = [];
        let XY_SOLUTIONS = {}; // Store x²+y²=-1 solutions for each prime
        let scene, camera, renderer, controls, cayleyGroup;
        let genScene, genCamera, genRenderer, genControls;

        // --- UTILITY FUNCTIONS ---
        const SVG_NS = 'http://www.w3.org/2000/svg';

        const H = (tag, props = {}, kids = []) => {
            const el = document.createElement(tag);
            const { style, ...rest } = props;
            Object.entries(rest).forEach(([k, v]) => {
                if (k === 'className') el.className = v;
                else if (k === 'text') el.textContent = v;
                else el[k] = v;
            });
            if (style) Object.entries(style).forEach(([k, v]) => el.style[k] = v);
            kids.forEach(k => el.append(k));
            return el;
        };

        const S = (tag, attrs = {}) => {
            const el = document.createElementNS(SVG_NS, tag);
            Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, String(v)));
            return el;
        };

        const markerCache = new Map();
        const markerForColor = (defs, color) => {
            if (markerCache.has(color)) return markerCache.get(color);
            const id = `arrow-${markerCache.size}`;
            const m = S('marker', { id, viewBox: '0 0 10 10', refX: 0, refY: 5, markerWidth: 5, markerHeight: 5, orient: 'auto-start-reverse', markerUnits: 'strokeWidth' });
            m.append(S('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: color, stroke: color }));
            defs.appendChild(m);
            markerCache.set(color, id);
            return id;
        };

        const isStar = (k) => k.endsWith('*');

        function getContrastColor(hex) {
            const clean = hex.replace('#', '');
            const r = parseInt(clean.substr(0, 2), 16);
            const g = parseInt(clean.substr(2, 2), 16);
            const b = parseInt(clean.substr(4, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 155 ? '#000000' : '#ffffff';
        }

        // --- GENERATOR COMPUTATION HANDLER ---
        document.getElementById('compute-button').addEventListener('click', async () => {
            const input = document.getElementById('prime-input').value;
            const primes = input.split(',').map(s => parseInt(s.trim())).filter(n => n > 2 && n % 2 === 1);

            if (primes.length === 0) {
                document.getElementById('status-message').textContent = 'Please enter valid odd primes.';
                return;
            }

            document.getElementById('status-message').textContent = `Computing canonical generators for primes: ${primes.join(', ')}...`;

            try {
                // Compute and store XY solutions for each prime first
                primes.forEach(p => {
                    XY_SOLUTIONS[p] = findXYSolution(p);
                });

                // Generate canonical generators for each prime using primeQuaternions.html approach
                const allCanonical = await generateGeneratorsForPrimes(primes, (progress, message) => {
                    document.getElementById('status-message').textContent =
                        `Computing ${message}... ${Math.round(progress * 100)}%`;
                });

                // Create generators object with colors
                const totalGenerators = allCanonical.reduce((sum, item) => sum + item.generators.length, 0);
                const colors = generateColors(totalGenerators);
                let colorIndex = 0;

                GENERATORS = {};
                let genIndex = 1;

                allCanonical.forEach(({ prime, generators }) => {
                    generators.forEach(genObj => {
                        const q = genObj.quaternion;
                        const p1Label = genObj.p1Label;

                        const key = `g${genIndex}`;
                        const keyConj = `g${genIndex}*`;
                        const color = colors[colorIndex];

                        GENERATORS[key] = {
                            q: q,
                            color: color,
                            prime: prime,
                            formatted: formatQuaternion(q),
                            p1Label: p1Label,
                            label: `(${prime}, ${p1Label || '?'})`
                        };

                        const conj = [q[0], -q[1], -q[2], -q[3]];
                        // Compute P¹ label for conjugate separately
                        const xy = XY_SOLUTIONS[prime];
                        const p1LabelConj = xy ? matchQuaternionToP1(conj, xy.x, xy.y, prime) : null;

                        GENERATORS[keyConj] = {
                            q: conj,
                            color: color,
                            prime: prime,
                            formatted: formatQuaternion(conj),
                            p1Label: p1LabelConj,
                            label: `(${prime}, ${p1LabelConj || '?'})*`
                        };

                        colorIndex++;
                        genIndex++;
                    });
                });

                const totalGens = Object.keys(GENERATORS).length / 2;
                console.log(`Generated ${totalGens} canonical generators`);

                // Log generators for debugging (including P¹ labels)
                Object.keys(GENERATORS).forEach(key => {
                    const gen = GENERATORS[key];
                    console.log(`${key} (p=${gen.prime}, P¹=${gen.p1Label}): ${gen.formatted}`);
                });

                document.getElementById('status-message').textContent = `Computing relations...`;

                // Use setTimeout to allow UI to update
                await new Promise(resolve => setTimeout(resolve, 100));

                // Compute relations using projective quaternion equality
                RELATIONS = computeRelations(GENERATORS);

                document.getElementById('status-message').textContent =
                    `✓ Generated ${totalGens} canonical generators, ${RELATIONS.length} relations`;

                // Refresh all visualizations
                populatePrimeFilter(primes);
                drawGenerators();
                drawRelationSquares();
                computeAndDrawPQRelations();
                populateSelectors();
                if (!scene) initThree();
                drawCayleyGraph();
                drawSquareComplex();

            } catch (error) {
                console.error('Error computing generators:', error);
                document.getElementById('status-message').textContent = `Error: ${error.message}`;
            }
        });

        // --- GENERATOR DISPLAY ---
        function populatePrimeFilter(primes) {
            const primeFilter = document.getElementById('prime-filter');
            primeFilter.innerHTML = '<option value="all">All Primes</option>';

            primes.forEach(p => {
                const option = document.createElement('option');
                option.value = p;
                option.textContent = `Prime ${p}`;
                primeFilter.appendChild(option);
            });

            // Add event listener for filter changes
            primeFilter.onchange = () => drawGenerators();
        }

        function drawGenerators() {
            const container = document.getElementById('generators-container');
            container.innerHTML = '';

            if (Object.keys(GENERATORS).length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Compute generators first.</p>';
                return;
            }

            const selectedPrime = document.getElementById('prime-filter').value;

            // Show/hide XY solution display
            const xyDisplay = document.getElementById('xy-solution-display');
            const xyText = document.getElementById('xy-solution-text');
            if (selectedPrime !== 'all' && XY_SOLUTIONS[selectedPrime]) {
                const xy = XY_SOLUTIONS[selectedPrime];
                xyText.textContent = `Solution for p = ${selectedPrime}: (x, y) = (${xy.x}, ${xy.y})`;
                xyDisplay.style.display = 'block';
            } else {
                xyDisplay.style.display = 'none';
            }

            // Get generators to display (filter by prime if needed)
            const genKeys = Object.keys(GENERATORS).filter(k => !k.endsWith('*'));
            const filteredKeys = selectedPrime === 'all'
                ? genKeys
                : genKeys.filter(k => GENERATORS[k].prime === parseInt(selectedPrime));

            if (filteredKeys.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No generators for selected prime.</p>';
                return;
            }

            // Sort generators by P¹ label for consistent display
            const sortByP1Label = (keys) => {
                return keys.sort((a, b) => {
                    const labelA = GENERATORS[a].p1Label;
                    const labelB = GENERATORS[b].p1Label;
                    if (labelA === '∞') return 1;
                    if (labelB === '∞') return -1;
                    return parseInt(labelA) - parseInt(labelB);
                });
            };

            // Group generators by prime if showing all
            if (selectedPrime === 'all') {
                const genByPrime = {};
                filteredKeys.forEach(key => {
                    const prime = GENERATORS[key].prime;
                    if (!genByPrime[prime]) genByPrime[prime] = [];
                    genByPrime[prime].push(key);
                });

                Object.keys(genByPrime).sort((a, b) => a - b).forEach(prime => {
                    const sortedKeys = sortByP1Label(genByPrime[prime]);
                    const row = H('div', { className: 'generators-row' }, sortedKeys.map(key => {
                        const gen = GENERATORS[key];
                        const color = gen.color;
                        const label = formatQuaternion(gen.q);
                        const span = H('span', { text: label });
                        span.style.backgroundColor = color;
                        span.style.color = getContrastColor(color);
                        // Show P¹ label on hover
                        span.title = `${formatQuaternion(gen.q)}\nP¹ label: ${gen.p1Label || '?'}`;
                        return span;
                    }));
                    container.appendChild(row);
                });
            } else {
                // Single row for one prime
                const sortedKeys = sortByP1Label(filteredKeys);
                const row = H('div', { className: 'generators-row' }, sortedKeys.map(key => {
                    const gen = GENERATORS[key];
                    const color = gen.color;
                    const label = formatQuaternion(gen.q);
                    const span = H('span', { text: label });
                    span.style.backgroundColor = color;
                    span.style.color = getContrastColor(color);
                    // Show P¹ label on hover
                    span.title = `${formatQuaternion(gen.q)}\nP¹ label: ${gen.p1Label || '?'}`;
                    return span;
                }));
                container.appendChild(row);
            }

            // Update 3D visualization
            visualizeGenerators();
        }

        // --- GENERATOR 3D VISUALIZATION ---
        function initGeneratorVisualization() {
            const container = document.getElementById('generator-vis-container');
            genScene = new THREE.Scene();
            genCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            genCamera.position.z = 15;

            genRenderer = new THREE.WebGLRenderer({ antialias: true });
            genRenderer.setSize(container.clientWidth, container.clientHeight);
            genRenderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(genRenderer.domElement);

            genControls = new OrbitControls(genCamera, genRenderer.domElement);
            genControls.enableDamping = true;
            genControls.dampingFactor = 0.05;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            genScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7.5);
            genScene.add(directionalLight);

            // Add axes helper
            const axesHelper = new THREE.AxesHelper(10);
            genScene.add(axesHelper);

            animateGeneratorVis();
        }

        function animateGeneratorVis() {
            requestAnimationFrame(animateGeneratorVis);
            if (genControls) genControls.update();
            if (genRenderer && genScene && genCamera) {
                genRenderer.render(genScene, genCamera);
            }
        }

        function visualizeGenerators() {
            if (!genScene) {
                initGeneratorVisualization();
            }

            // Clear existing points
            const objectsToRemove = genScene.children.filter(obj => obj instanceof THREE.Points);
            objectsToRemove.forEach(obj => genScene.remove(obj));

            if (Object.keys(GENERATORS).length === 0) return;

            const selectedPrime = document.getElementById('prime-filter').value;

            // Get all quaternions to visualize
            const allQuaternions = [];
            const genKeys = Object.keys(GENERATORS).filter(k => !k.endsWith('*'));

            genKeys.forEach(key => {
                const gen = GENERATORS[key];
                if (selectedPrime === 'all' || gen.prime === parseInt(selectedPrime)) {
                    // Add both the generator and its conjugate
                    allQuaternions.push({ q: gen.q, color: gen.color });
                    const genConj = GENERATORS[key + '*'];
                    allQuaternions.push({ q: genConj.q, color: genConj.color });
                }
            });

            if (allQuaternions.length === 0) return;

            // Find max coordinate for scaling
            let maxCoord = 0;
            allQuaternions.forEach(({ q }) => {
                maxCoord = Math.max(maxCoord, Math.abs(q[1]), Math.abs(q[2]), Math.abs(q[3]));
            });

            // Create geometry
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            allQuaternions.forEach(({ q, color }) => {
                const [a, b, c, d] = q;
                // Plot (b, c, d) in 3D space
                positions.push(b, c, d);

                // Use the generator's assigned color
                const threeColor = new THREE.Color(color);
                colors.push(threeColor.r, threeColor.g, threeColor.b);
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geometry, material);
            genScene.add(points);

            // Adjust camera position based on data
            genCamera.position.z = Math.max(15, maxCoord * 2);
        }

        // --- PQ FACTORIZATION RELATIONS ---
        // Helper function to create a small relation square SVG
        function createRelationSquareSVG(bottomKey, rightKey, leftKey, topKey, size = 90) {
            const svg = S('svg', { width: size, height: size, viewBox: '0 0 100 100' });
            const defs = S('defs');
            svg.appendChild(defs);

            // Background shading
            svg.appendChild(S('rect', {
                x: 15, y: 15, width: 70, height: 70,
                fill: 'rgba(0,0,0,0.05)', stroke: 'none'
            }));

            // Define edges: [generatorKey, x1, y1, x2, y2]
            const edges = [
                { key: bottomKey, x1: 15, y1: 85, x2: 85, y2: 85 }, // bottom
                { key: rightKey, x1: 85, y1: 85, x2: 85, y2: 15 },  // right
                { key: leftKey, x1: 15, y1: 85, x2: 15, y2: 15 },   // left
                { key: topKey, x1: 15, y1: 15, x2: 85, y2: 15 }     // top
            ];

            edges.forEach((e) => {
                if (!e.key || !GENERATORS[e.key]) return;

                let { x1, y1, x2, y2 } = e;
                const color = GENERATORS[e.key].color;

                // Reverse direction if conjugate
                if (isStar(e.key)) {
                    [x1, x2] = [x2, x1];
                    [y1, y2] = [y2, y1];
                }

                const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
                const markerId = markerForColor(defs, color);
                const pathEl = S('path', {
                    d: `M ${x1} ${y1} L ${mx} ${my} L ${x2} ${y2}`,
                    fill: 'none', stroke: color, 'stroke-width': 4,
                    'marker-mid': `url(#${markerId})`
                });
                svg.appendChild(pathEl);
            });

            return svg;
        }

        function computeAndDrawPQRelations() {
            const container = document.getElementById('pq-relations-container');
            container.innerHTML = '';

            // Get list of primes
            const primes = [...new Set(Object.values(GENERATORS).map(g => g.prime))].sort((a, b) => a - b);

            if (primes.length < 2) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Compute generators for at least 2 primes.</p>';
                return;
            }

            // For each pair of primes (p, q) where p < q
            for (let i = 0; i < primes.length; i++) {
                for (let j = i + 1; j < primes.length; j++) {
                    const p = primes[i];
                    const q = primes[j];

                    // Get all generators for each prime (including conjugates)
                    const pGens = Object.keys(GENERATORS).filter(k => GENERATORS[k].prime === p);
                    const qGens = Object.keys(GENERATORS).filter(k => GENERATORS[k].prime === q);

                    // Get unique P¹ labels for each prime
                    const pLabels = [...new Set(pGens.map(k => GENERATORS[k].p1Label))].filter(l => l !== undefined);
                    const qLabels = [...new Set(qGens.map(k => GENERATORS[k].p1Label))].filter(l => l !== undefined);

                    // Sort labels (numbers first, then ∞)
                    const sortP1Labels = (labels) => {
                        return labels.sort((a, b) => {
                            if (a === '∞') return 1;
                            if (b === '∞') return -1;
                            return parseInt(a) - parseInt(b);
                        });
                    };

                    const sortedPLabels = sortP1Labels([...pLabels]);
                    const sortedQLabels = sortP1Labels([...qLabels]);

                    console.log(`PQ Relations table for p=${p}, q=${q}:`);
                    console.log(`  P¹ labels for p=${p} (${sortedPLabels.length}): ${sortedPLabels.join(', ')}`);
                    console.log(`  P¹ labels for q=${q} (${sortedQLabels.length}): ${sortedQLabels.join(', ')}`);
                    console.log(`  Expected: ${p+1} × ${q+1} = ${(p+1) * (q+1)} cells`);

                    // Create table
                    const tableWrapper = H('div', { className: 'pq-relation-table-wrapper' });
                    const title = H('h3', { text: `Norm ${p}×${q} Relations: $\\mathbb{F}_{${p}}\\mathbb{P}^1 \\times \\mathbb{F}_{${q}}\\mathbb{P}^1$` });
                    tableWrapper.appendChild(title);

                    const table = document.createElement('table');
                    table.className = 'pq-relation-table';

                    // Header row
                    const headerRow = document.createElement('tr');
                    const cornerCell = H('th');
                    cornerCell.innerHTML = `$p=${p} \\backslash q=${q}$`;
                    headerRow.appendChild(cornerCell);
                    sortedQLabels.forEach(qLabel => {
                        const th = H('th');
                        th.innerHTML = qLabel === '∞' ? '$\\infty$' : `$${qLabel}$`;
                        headerRow.appendChild(th);
                    });
                    table.appendChild(headerRow);

                    // Data rows
                    sortedPLabels.forEach(pLabel => {
                        const row = document.createElement('tr');
                        const rowHeader = H('td', { className: 'row-header' });
                        rowHeader.innerHTML = pLabel === '∞' ? '$\\infty$' : `$${pLabel}$`;
                        row.appendChild(rowHeader);

                        sortedQLabels.forEach(qLabel => {
                            // Find p_i generator (could be canonical or conjugate)
                            const pGenKey = pGens.find(k => GENERATORS[k].p1Label === pLabel);
                            // Find q_j generator (could be canonical or conjugate)
                            const qGenKey = qGens.find(k => GENERATORS[k].p1Label === qLabel);

                            if (!pGenKey || !qGenKey) {
                                row.appendChild(H('td', { text: '?' }));
                                return;
                            }

                            const pGen = GENERATORS[pGenKey];
                            const qGen = GENERATORS[qGenKey];

                            // Compute p_i * q_j
                            const pq = QMath.multiply(pGen.q, qGen.q);

                            // Try to find q_k * p_l that equals pq (up to sign)
                            let found = false;
                            for (const qkKey of qGens) {
                                if (found) break;
                                for (const plKey of pGens) {
                                    const qk = GENERATORS[qkKey];
                                    const pl = GENERATORS[plKey];
                                    const qp = QMath.multiply(qk.q, pl.q);

                                    if (QMath.areEqual(pq, qp) || QMath.areEqual(pq, qp.map(x => -x))) {
                                        // Found the relation: p_i * q_j = q_k * p_l
                                        // Create square diagram showing the relation
                                        const cell = H('td', { className: 'pq-relation-cell' });

                                        // Create SVG square with:
                                        // Bottom: p_i, Right: q_j, Left: q_k, Top: p_l
                                        const squareSVG = createRelationSquareSVG(pGenKey, qGenKey, qkKey, plKey);

                                        const sign = QMath.areEqual(pq, qp) ? '' : '-';
                                        cell.title = `${formatQuaternion(pGen.q)} × ${formatQuaternion(qGen.q)} = ${sign}${formatQuaternion(qk.q)} × ${formatQuaternion(pl.q)}`;
                                        cell.appendChild(squareSVG);
                                        row.appendChild(cell);
                                        found = true;
                                        break;
                                    }
                                }
                            }

                            if (!found) {
                                row.appendChild(H('td', { text: '?' }));
                            }
                        });

                        table.appendChild(row);
                    });

                    tableWrapper.appendChild(table);
                    container.appendChild(tableWrapper);
                }
            }

            // Trigger MathJax to render
            if (window.MathJax) {
                MathJax.typesetPromise([container]).catch((err) => console.log('MathJax error:', err));
            }
        }

        // --- RELATION SQUARES VISUALIZATION ---
        function drawRelationSquares() {
            const container = document.getElementById('relations-container');
            container.innerHTML = '';

            if (RELATIONS.length === 0) {
                container.textContent = 'No relations computed yet.';
                return;
            }

            const wrapper = H('div', { className: 'relation-square' });

            // Legend
            const legendContainer = H('div', { className: 'legend-container' }, [
                H('p', { className: 'legend-title', text: 'Generators' })
            ]);
            const legend = H('div', { className: 'legend' });

            // Group generators by prime for legend
            const genByPrime = {};
            Object.keys(GENERATORS).filter(k => !k.endsWith('*')).forEach(key => {
                const prime = GENERATORS[key].prime;
                if (!genByPrime[prime]) genByPrime[prime] = [];
                genByPrime[prime].push(key);
            });

            Object.keys(genByPrime).sort((a, b) => a - b).forEach(prime => {
                const row = H('div', { className: 'legend-row' }, genByPrime[prime].map(key => {
                    const color = GENERATORS[key].color;
                    const span = H('span', { text: formatQuaternion(GENERATORS[key].q) });
                    span.style.backgroundColor = color;
                    span.style.color = getContrastColor(color);
                    return span;
                }));
                legend.appendChild(row);
            });

            legendContainer.appendChild(legend);
            wrapper.appendChild(legendContainer);

            const relHeading = H('p', {
                text: 'Relations',
                style: { margin: '6px 0 4px 0', textAlign: 'center', fontWeight: '600' }
            });
            wrapper.appendChild(relHeading);

            const grid = H('div', { className: 'squares-grid' });
            wrapper.appendChild(grid);

            RELATIONS.forEach((rel, i) => {
                const cell = H('div', { className: 'square-cell' });
                const svg = S('svg', { width: 150, height: 150, viewBox: '0 0 100 100' });
                const defs = S('defs');
                svg.appendChild(defs);

                // Background shading
                svg.appendChild(S('rect', {
                    x: 15, y: 15, width: 70, height: 70,
                    fill: 'rgba(0,0,0,0.05)', stroke: 'none'
                }));

                const edges = [
                    { key: rel.a, x1: 15, y1: 85, x2: 85, y2: 85, color: GENERATORS[rel.a].color },
                    { key: rel.b, x1: 85, y1: 85, x2: 85, y2: 15, color: GENERATORS[rel.b].color },
                    { key: rel.bp, x1: 15, y1: 85, x2: 15, y2: 15, color: GENERATORS[rel.bp].color },
                    { key: rel.ap, x1: 15, y1: 15, x2: 85, y2: 15, color: GENERATORS[rel.ap].color }
                ];

                edges.forEach((e) => {
                    let { x1, y1, x2, y2 } = e;
                    if (isStar(e.key)) {
                        [x1, x2] = [x2, x1];
                        [y1, y2] = [y2, y1];
                    }
                    const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
                    const markerId = markerForColor(defs, e.color);
                    const pathEl = S('path', {
                        d: `M ${x1} ${y1} L ${mx} ${my} L ${x2} ${y2}`,
                        fill: 'none', stroke: e.color, 'stroke-width': 3,
                        'marker-mid': `url(#${markerId})`
                    });
                    svg.appendChild(pathEl);
                });

                cell.appendChild(svg);
                grid.appendChild(cell);
            });

            container.appendChild(wrapper);
        }

        // --- SELECTOR POPULATION ---
        function populateSelectors() {
            const selX = document.getElementById('gen-x');
            const selY = document.getElementById('gen-y');
            selX.innerHTML = '';
            selY.innerHTML = '';

            const genKeys = Object.keys(GENERATORS).filter(k => !k.endsWith('*'));

            genKeys.forEach(key => {
                const labelText = formatQuaternion(GENERATORS[key].q);
                selX.add(new Option(labelText, key));
                selY.add(new Option(labelText, key));
            });

            if (genKeys.length >= 2) {
                selX.value = genKeys[0];
                selY.value = genKeys[1];
            }
        }

        // --- THREE.JS CAYLEY GRAPH ---
        function initThree() {
            const container = document.getElementById('vis-container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 2.5;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            camera.add(pointLight);
            scene.add(camera);

            const sphereGeom = new THREE.SphereGeometry(1, 64, 32);
            const sphereMat = new THREE.MeshPhongMaterial({
                color: 0x156289, emissive: 0x072534, side: THREE.BackSide,
                transparent: true, opacity: 0.2, shininess: 50
            });
            const boundarySphere = new THREE.Mesh(sphereGeom, sphereMat);
            scene.add(boundarySphere);

            cayleyGroup = new THREE.Group();
            scene.add(cayleyGroup);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('vis-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);

            // Also resize generator visualization
            if (genRenderer && genCamera) {
                const genContainer = document.getElementById('generator-vis-container');
                genCamera.aspect = genContainer.clientWidth / genContainer.clientHeight;
                genCamera.updateProjectionMatrix();
                genRenderer.setSize(genContainer.clientWidth, genContainer.clientHeight);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function drawCayleyGraph() {
            if (!cayleyGroup) return;

            while (cayleyGroup.children.length > 0) {
                cayleyGroup.remove(cayleyGroup.children[0]);
            }

            const genX_key = document.getElementById('gen-x').value;
            const genY_key = document.getElementById('gen-y').value;
            const depth = parseInt(document.getElementById('depth-slider').value);

            if (!genX_key || !genY_key) return;

            // Placeholder: Add visualization logic here
            // Use the same Cayley graph building algorithm from quaternionCalculator.html
            const baseRadius = Math.max(0.05, 0.05 * (3 / (depth + 2)));
            const radiusFor = (lvl) => Math.max(0.003, baseRadius * Math.pow(0.82, Math.max(0, lvl)));
            const edgeOpacityFor = (lvl) => Math.max(0.3, 1 - .5 * (Math.max(0, lvl) / Math.max(1, depth)));

            const q_x = GENERATORS[genX_key];
            const q_y = GENERATORS[genY_key];
            const q_x_inv_key = genX_key.endsWith('*') ? genX_key.slice(0, -1) : genX_key + '*';
            const q_y_inv_key = genY_key.endsWith('*') ? genY_key.slice(0, -1) : genY_key + '*';
            const q_x_inv = GENERATORS[q_x_inv_key];
            const q_y_inv = GENERATORS[q_y_inv_key];

            const gens = [
                { q: q_x.q, color: q_x.color },
                { q: q_y.q, color: q_y.color },
                { q: q_x_inv.q, color: q_x.color },
                { q: q_y_inv.q, color: q_y.color }
            ];

            const basePointVec = new THREE.Vector3(0, 1, 0);
            const basePointPureQ = QMath.vecToPure(basePointVec);
            const queue = [{ q: [1, 0, 0, 0], pos: basePointVec, level: 0 }];
            const visited = new Map();
            visited.set(JSON.stringify(basePointVec.toArray()), true);

            const initialVertexGeom = new THREE.SphereGeometry(radiusFor(0), 20, 12);
            const initialVertexMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            const initialVertex = new THREE.Mesh(initialVertexGeom, initialVertexMat);
            initialVertex.position.copy(basePointVec);
            cayleyGroup.add(initialVertex);

            while (queue.length > 0) {
                const { q, pos, level } = queue.shift();
                if (level >= depth) continue;

                for (const gen of gens) {
                    const next_q = QMath.multiply(gen.q, q);
                    const next_pos_pure = QMath.act(gen.q, QMath.vecToPure(pos));
                    const next_pos = QMath.pureToVec(next_pos_pure);
                    const posKey = JSON.stringify(next_pos.toArray().map(v => v.toFixed(5)));

                    if (!visited.has(posKey)) {
                        visited.set(posKey, true);
                        const vertexGeom = new THREE.SphereGeometry(radiusFor(level + 1), 16, 8);
                        const vertexMat = new THREE.MeshBasicMaterial({
                            color: 0xffffff, transparent: true, opacity: edgeOpacityFor(level + 1)
                        });
                        const vertex = new THREE.Mesh(vertexGeom, vertexMat);
                        vertex.position.copy(next_pos);
                        cayleyGroup.add(vertex);

                        const curve = new THREE.CatmullRomCurve3([
                            pos.clone().multiplyScalar(0.99),
                            pos.clone().add(next_pos).normalize(),
                            next_pos.clone().multiplyScalar(0.99)
                        ]);
                        const points = curve.getPoints(20);
                        const edgeGeom = new THREE.BufferGeometry().setFromPoints(points);
                        const edgeMat = new THREE.LineBasicMaterial({
                            color: gen.color, linewidth: 2, transparent: true, opacity: edgeOpacityFor(level + 1)
                        });
                        const edge = new THREE.Line(edgeGeom, edgeMat);
                        cayleyGroup.add(edge);

                        queue.push({ q: next_q, pos: next_pos, level: level + 1 });
                    }
                }
            }
        }

        // --- SQUARE COMPLEX ---
        function drawSquareComplex() {
            const container = document.getElementById('square-complex-container');
            container.innerHTML = '';

            const genX_key = document.getElementById('gen-x').value;
            const genY_key = document.getElementById('gen-y').value;
            if (!genX_key || !genY_key || RELATIONS.length === 0) {
                container.textContent = 'Compute generators and select axes first.';
                return;
            }

            const svg = S('svg', { width: '100%', height: '100%', viewBox: '0 0 1000 1000' });
            container.appendChild(svg);
            const defs = S('defs');
            svg.appendChild(defs);

            const depth = parseInt(document.getElementById('depth-slider').value);
            const squareSize = 900 / (2 * depth + 1);
            const transform = (i, j) => [500 + i * squareSize, 500 - j * squareSize];

            // Edge storage
            const horzEdges = new Map();
            const vertEdges = new Map();
            const getHorzEdge = (i, j) => horzEdges.get(`${i},${j}`);
            const getVertEdge = (i, j) => vertEdges.get(`${i},${j}`);
            const setHorzEdge = (i, j, gen) => horzEdges.set(`${i},${j}`, gen);
            const setVertEdge = (i, j, gen) => vertEdges.set(`${i},${j}`, gen);

            // Initialize axes
            for (let i = -depth; i < depth; i++) {
                setHorzEdge(i, 0, genX_key);
            }
            for (let j = -depth; j < depth; j++) {
                setVertEdge(0, j, genY_key);
            }

            // Try to fill squares using relations
            const tryFillSquare = (i, j) => {
                const bottom = getHorzEdge(i, j);
                const left = getVertEdge(i, j);
                const top = getHorzEdge(i, j + 1);
                const right = getVertEdge(i + 1, j);

                const edgeCount = [bottom, left, top, right].filter(e => e != null).length;
                if (edgeCount === 4) return false;

                let filled = false;

                // Case 1: bottom + left → top + right
                if (bottom && left && (!top || !right)) {
                    const rel = RELATIONS.find(r => r.a === bottom && r.bp === left);
                    if (rel) {
                        if (!top) { setHorzEdge(i, j + 1, rel.ap); filled = true; }
                        if (!right) { setVertEdge(i + 1, j, rel.b); filled = true; }
                    }
                }

                // Case 2: top + right → bottom + left
                if (top && right && (!bottom || !left)) {
                    const rel = RELATIONS.find(r => r.ap === top && r.b === right);
                    if (rel) {
                        if (!bottom) { setHorzEdge(i, j, rel.a); filled = true; }
                        if (!left) { setVertEdge(i, j, rel.bp); filled = true; }
                    }
                }

                // Case 3: bottom + right → top + left
                if (bottom && right && (!top || !left)) {
                    const rel = RELATIONS.find(r => r.a === bottom && r.b === right);
                    if (rel) {
                        if (!top) { setHorzEdge(i, j + 1, rel.ap); filled = true; }
                        if (!left) { setVertEdge(i, j, rel.bp); filled = true; }
                    }
                }

                // Case 4: top + left → bottom + right
                if (top && left && (!bottom || !right)) {
                    const rel = RELATIONS.find(r => r.ap === top && r.bp === left);
                    if (rel) {
                        if (!bottom) { setHorzEdge(i, j, rel.a); filled = true; }
                        if (!right) { setVertEdge(i + 1, j, rel.b); filled = true; }
                    }
                }

                return filled;
            };

            // Iterate until no more squares can be filled
            let changed = true;
            let iterations = 0;
            const maxIterations = 100;

            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                for (let i = -depth; i < depth; i++) {
                    for (let j = -depth; j < depth; j++) {
                        if (tryFillSquare(i, j)) {
                            changed = true;
                        }
                    }
                }
            }

            // Draw edges
            const drawEdge = (x1, y1, x2, y2, genKey) => {
                if (!genKey) return;
                const gen = GENERATORS[genKey];
                let [p1x, p1y] = transform(x1, y1);
                let [p2x, p2y] = transform(x2, y2);
                if (isStar(genKey)) {
                    [p1x, p2x] = [p2x, p1x];
                    [p1y, p2y] = [p2y, p1y];
                }
                const mx = (p1x + p2x) / 2;
                const my = (p1y + p2y) / 2;
                const markerId = markerForColor(defs, gen.color);
                const pathEl = S('path', {
                    d: `M ${p1x} ${p1y} L ${mx} ${my} L ${p2x} ${p2y}`,
                    fill: 'none', stroke: gen.color, 'stroke-width': 2.5,
                    'marker-mid': `url(#${markerId})`
                });
                svg.appendChild(pathEl);
            };

            // Draw all edges
            for (let i = -depth; i < depth; i++) {
                for (let j = -depth; j <= depth; j++) {
                    const gen = getHorzEdge(i, j);
                    if (gen) drawEdge(i, j, i + 1, j, gen);
                }
            }
            for (let i = -depth; i <= depth; i++) {
                for (let j = -depth; j < depth; j++) {
                    const gen = getVertEdge(i, j);
                    if (gen) drawEdge(i, j, i, j + 1, gen);
                }
            }

            // Draw origin marker
            const [cx, cy] = transform(0, 0);
            const originR = Math.max(5, Math.min(14, squareSize * 0.22));
            const origin = S('circle', {
                cx: String(cx), cy: String(cy), r: String(originR),
                fill: '#ffd700', stroke: '#b8860b', 'stroke-width': '2'
            });
            svg.appendChild(origin);
        }

        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            const genX = document.getElementById('gen-x');
            const genY = document.getElementById('gen-y');
            const depthSlider = document.getElementById('depth-slider');
            const depthValue = document.getElementById('depth-value');

            const updateAll = () => {
                drawCayleyGraph();
                drawSquareComplex();
            };

            genX.addEventListener('change', updateAll);
            genY.addEventListener('change', updateAll);

            depthSlider.addEventListener('input', () => {
                depthValue.textContent = depthSlider.value;
            });
            depthSlider.addEventListener('change', updateAll);
        }

        // --- INITIALIZATION ---
        setupEventListeners();

        // Auto-compute with default primes
        document.getElementById('compute-button').click();

        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise();
        } else {
            window.addEventListener('load', () => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise();
                }
            });
        }
    </script>
</body>

</html>
