<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProjectiveQuaternion Test</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #2c3e50;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .test {
            margin: 10px 0;
            padding: 10px;
            background-color: #e8f4f8;
            border-left: 3px solid #3498db;
        }
        .pass {
            border-left-color: #27ae60;
            background-color: #e8f8f5;
        }
        .fail {
            border-left-color: #e74c3c;
            background-color: #fadbd8;
        }
        button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #2980b9;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>ProjectiveQuaternion Class Test</h1>
    <p>Testing the ProjectiveQuaternion class that identifies quaternions up to scalar multiple.</p>

    <button id="run-tests">Run Tests</button>

    <div id="results"></div>

    <script type="module">
        import {
            ProjectiveQuaternion,
            generateProjectiveQuaternionsOfNorm,
            computeProjectiveRelations
        } from './projectiveQuaternion.js';

        function addTest(name, passed, details = '') {
            const resultsDiv = document.getElementById('results');
            const testDiv = document.createElement('div');
            testDiv.className = `test ${passed ? 'pass' : 'fail'}`;
            testDiv.innerHTML = `
                <strong>${passed ? '✓' : '✗'} ${name}</strong>
                ${details ? `<br><small>${details}</small>` : ''}
            `;
            resultsDiv.appendChild(testDiv);
            return passed;
        }

        document.getElementById('run-tests').addEventListener('click', () => {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';

            let passCount = 0;
            let totalCount = 0;

            // Test 1: Basic construction
            totalCount++;
            const q1 = new ProjectiveQuaternion(1, 2, 3, 4);
            if (addTest('Basic Construction', q1.w === 1 && q1.x === 2 && q1.y === 3 && q1.z === 4,
                `Created: ${q1.toString()}`)) passCount++;

            // Test 2: Normalization (negative first component should flip)
            totalCount++;
            const q2 = new ProjectiveQuaternion(-1, 2, 3, 4);
            if (addTest('Normalization', q2.w === 1 && q2.x === -2 && q2.y === -3 && q2.z === -4,
                `(-1,2,3,4) normalized to (${q2.w},${q2.x},${q2.y},${q2.z})`)) passCount++;

            // Test 3: Projective equality
            totalCount++;
            const q3 = new ProjectiveQuaternion(1, 2, 3, 4);
            const q4 = new ProjectiveQuaternion(2, 4, 6, 8); // Should be equal in projective space
            if (addTest('Projective Equality', q3.equals(q4),
                `(1,2,3,4) ~ (2,4,6,8): ${q3.equals(q4)}`)) passCount++;

            // Test 4: Multiplication
            totalCount++;
            const a = new ProjectiveQuaternion(1, 0, 0, 0); // Real unit
            const b = new ProjectiveQuaternion(0, 1, 0, 0); // i
            const c = a.multiply(b);
            if (addTest('Multiplication', c.x === 1 && c.w === 0 && c.y === 0 && c.z === 0,
                `1 * i = ${c.toString()}`)) passCount++;

            // Test 5: i * j = k
            totalCount++;
            const i = new ProjectiveQuaternion(0, 1, 0, 0);
            const j = new ProjectiveQuaternion(0, 0, 1, 0);
            const k = i.multiply(j);
            if (addTest('i × j = k', Math.abs(k.z - 1) < 1e-9 && Math.abs(k.w) < 1e-9,
                `i * j = ${k.toString()}`)) passCount++;

            // Test 6: Conjugate
            totalCount++;
            const q5 = new ProjectiveQuaternion(1, 2, 3, 4);
            const q5conj = q5.conjugate();
            if (addTest('Conjugate', q5conj.w === 1 && q5conj.x === -2 && q5conj.y === -3 && q5conj.z === -4,
                `(1+2i+3j+4k)* = ${q5conj.toString()}`)) passCount++;

            // Test 7: Norm
            totalCount++;
            const q6 = new ProjectiveQuaternion(1, 2, 0, 0);
            const norm = q6.normSq();
            if (addTest('Norm Squared', norm === 5,
                `|1+2i|² = ${norm}`)) passCount++;

            // Test 8: Generate quaternions of norm 5
            totalCount++;
            const norm5 = generateProjectiveQuaternionsOfNorm(5);
            const expected5 = 3; // (1,2,0,0), (1,0,2,0), (1,0,0,2) and their equivalents
            if (addTest('Generate Norm 5', norm5.length === expected5,
                `Found ${norm5.length} projective quaternions of norm 5: ${norm5.map(q => q.toString()).join(', ')}`)) passCount++;

            // Test 9: Generate quaternions of norm 13
            totalCount++;
            const norm13 = generateProjectiveQuaternionsOfNorm(13);
            if (addTest('Generate Norm 13', norm13.length > 0,
                `Found ${norm13.length} projective quaternions of norm 13`)) passCount++;

            // Test 10: Inverse
            totalCount++;
            const q7 = new ProjectiveQuaternion(1, 0, 0, 0);
            const q7inv = q7.inverse();
            const identity = q7.multiply(q7inv);
            if (addTest('Inverse', Math.abs(identity.w - 1) < 1e-9 && Math.abs(identity.normSq() - 1) < 1e-9,
                `1 * 1⁻¹ = ${identity.toString()}`)) passCount++;

            // Summary
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'section';
            summaryDiv.innerHTML = `<strong>Summary: ${passCount}/${totalCount} tests passed</strong>`;
            resultsDiv.appendChild(summaryDiv);

            // Example: Compute relations for primes 5 and 13
            const exampleDiv = document.createElement('div');
            exampleDiv.className = 'section';
            exampleDiv.innerHTML = '<h3>Example: Computing Relations</h3><p>Computing relations for norm 5 and 13 quaternions...</p>';
            resultsDiv.appendChild(exampleDiv);

            setTimeout(() => {
                const generators = {};
                let idx = 1;

                [...norm5, ...norm13].forEach(pq => {
                    const key = `g${idx}`;
                    const keyConj = `g${idx}*`;
                    generators[key] = { pq, prime: pq.normSq() };
                    generators[keyConj] = { pq: pq.conjugate(), prime: pq.normSq() };
                    idx++;
                });

                const relations = computeProjectiveRelations(generators);
                exampleDiv.innerHTML += `<p>Generated ${Object.keys(generators).length / 2} generators.</p>`;
                exampleDiv.innerHTML += `<p>Found ${relations.length} relations.</p>`;

                if (relations.length > 0) {
                    exampleDiv.innerHTML += '<p>First 5 relations:</p><ul>';
                    relations.slice(0, 5).forEach(rel => {
                        exampleDiv.innerHTML += `<li><code>${rel.a} × ${rel.b} = ${rel.bp} × ${rel.ap}</code></li>`;
                    });
                    exampleDiv.innerHTML += '</ul>';
                }
            }, 100);
        });

        // Auto-run tests on load
        document.getElementById('run-tests').click();
    </script>
</body>
</html>
