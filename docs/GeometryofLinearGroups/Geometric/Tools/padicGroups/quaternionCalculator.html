<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quaternion Calculator for SO_3(Z[1/65])[2]</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 2em;
            background-color: #f4f4f9;
            color: #333;
        }

        h1,
        h2 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1em;
            background-color: white;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        #relations-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .legend-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .legend-title {
            margin: 0;
            font-weight: 600;
            color: #2c3e50;
        }

        .legend {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .legend-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }

        .legend span {
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 999px;
        }

        .relation-square {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            background-color: #fdfdfd;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            text-align: center;
        }

        .relation-square p {
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
            margin: 5px 0 10px 0;
            min-height: 3em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Single box holding all relation squares */
        .squares-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(3, auto);
            gap: 4px;
            align-items: start;
        }
        .square-cell {
            text-align: center;
        }
        .square-cell p {
            margin: 0 0 2px 0;
            min-height: 1.6em;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 20px;
            margin-top: 20px;
            background-color: #ecf0f1;
            border-radius: 8px;
        }

        .controls label {
            font-weight: bold;
        }

        select,
        input {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
        }

        #vis-container, #square-complex-container {
            width: 100%;
            height: 600px;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #ccc;
        }
        #square-complex-container {
             height: 500px;
             background-color: #f9f9f9;
        }
    </style>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$','$$'], ['\\[','\\]']]
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>

    <div class="container">
        <h1>Quaternion Calculator</h1>
        <p style="text-align: center;">This tool explores the group structure of \(\mathsf{SO}_3(\mathbb{Z}[1/65])\).</p>

        <hr>

        <h2>Presentation of the Group</h2>
        <div id="relations-container"></div>

        <hr>

        <h2>Interactive Cayley Graph on $S^2$</h2>
        <div class="controls">
            <label for="gen-x">X-Axis Generator:</label>
            <select id="gen-x"></select>
            <label for="gen-y">Y-Axis Generator:</label>
            <select id="gen-y"></select>
            <label for="depth-slider">Depth:</label>
            <input type="range" id="depth-slider" min="1" max="9" value="4">
            <span id="depth-value">4</span>
        </div>
        <div id="vis-container"></div>
        
        <hr>

        <h2>Square Complex</h2>
        <div id="square-complex-container"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.171.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.171.0/examples/jsm/"
        }
    }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. QUATERNION MATH LIBRARY ---
        const QMath = {
            multiply: (q1, q2) => {
                const [w1, x1, y1, z1] = q1;
                const [w2, x2, y2, z2] = q2;
                return [
                    w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2,
                    w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,
                    w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2,
                    w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2
                ];
            },
            conjugate: (q) => [q[0], -q[1], -q[2], -q[3]],
            normSq: (q) => q[0] ** 2 + q[1] ** 2 + q[2] ** 2 + q[3] ** 2,
            inverse: (q) => {
                const n2 = QMath.normSq(q);
                if (n2 === 0) return [0, 0, 0, 0];
                const [w, x, y, z] = QMath.conjugate(q);
                return [w / n2, x / n2, y / n2, z / n2];
            },
            act: (q, v) => { // v is a pure quaternion [0, x, y, z]
                const q_inv = QMath.inverse(q);
                return QMath.multiply(QMath.multiply(q, v), q_inv);
            },
            areEqual: (q1, q2, epsilon = 1e-9) => {
                return q1.every((val, i) => Math.abs(val - q2[i]) < epsilon);
            },
            vecToPure: (v) => [0, v.x, v.y, v.z],
            pureToVec: (q) => new THREE.Vector3(q[1], q[2], q[3]),
        };

        // --- 2. GENERATORS & RELATIONS DATA ---

        // Generators with names, quaternion values, and colors
        const earthTones = ['#0B0B0B', '#725236', '#9E9FAE', '#F4A460', '#DEB887'];
        const rainbowTones = ['#FFADAD', '#FFD6A5', '#FDFFB6', '#CAFFBF', '#9BF6FF', '#A0C4FF', '#BDB2FF', '#FFC6FF' ];

        const GENERATORS = {
            // Norm 5
            'a_1': { q: [1, 2, 0, 0], color: earthTones[0] },
            'a_1*': { q: [1, -2, 0, 0], color: earthTones[0] },
            'a_2': { q: [1, 0, 2, 0], color: earthTones[1] },
            'a_2*': { q: [1, 0, -2, 0], color: earthTones[1] },
            'a_3': { q: [1, 0, 0, 2], color: earthTones[2] },
            'a_3*': { q: [1, 0, 0, -2], color: earthTones[2] },
            // Norm 13 (type 3+2i)
            'b_1': { q: [3, 2, 0, 0], color: rainbowTones[0] },
            'b_1*': { q: [3, -2, 0, 0], color: rainbowTones[0] },
            'b_2': { q: [3, 0, 2, 0], color: rainbowTones[1] },
            'b_2*': { q: [3, 0, -2, 0], color: rainbowTones[1] },
            'b_3': { q: [3, 0, 0, 2], color: rainbowTones[2] },
            'b_3*': { q: [3, 0, 0, -2], color: rainbowTones[2] },
            // Norm 13 (type 1+2i+2j+2k)
            'b_4': { q: [1, 2, 2, 2], color: rainbowTones[3] },
            'b_4*': { q: [1, -2, -2, -2], color: rainbowTones[3] },
            'b_5': { q: [1, 2, 2, -2], color: rainbowTones[4] },
            'b_5*': { q: [1, -2, -2, 2], color: rainbowTones[4] },
            'b_6': { q: [1, 2, -2, 2], color: rainbowTones[5] },
            'b_6*': { q: [1, -2, 2, -2], color: rainbowTones[5] },
            'b_7': { q: [1, -2, 2, 2], color: rainbowTones[6] },
            'b_7*': { q: [1, 2, -2, -2], color: rainbowTones[6] },
        };

        const ALL_GEN_KEYS = Object.keys(GENERATORS);

        const RELATIONS = [
            { a: 'a_1', b: 'b_1',  bp: 'b_1',  ap: 'a_1'  }, 
            { a: 'a_1', b: 'b_2',  bp: 'b_6*', ap: 'a_3*' },
            { a: 'a_1', b: 'b_3',  bp: 'b_7',  ap: 'a_2'  }, 
            { a: 'a_1', b: 'b_4',  bp: 'b_2',  ap: 'a_3*' },
            { a: 'a_1', b: 'b_5',  bp: 'b_3*', ap: 'a_2*' },
            { a: 'a_1', b: 'b_6',  bp: 'b_3',  ap: 'a_2'  }, 
            { a: 'a_1', b: 'b_7',  bp: 'b_4',  ap: 'a_1*' },

            { a: 'a_2', b: 'b_1',  bp: 'b_6',  ap: 'a_3'  }, 
            { a: 'a_2', b: 'b_2',  bp: 'b_2',  ap: 'a_2'  }, 
            { a: 'a_2', b: 'b_3',  bp: 'b_5*', ap: 'a_1*' },
            { a: 'a_2', b: 'b_4',  bp: 'b_3',  ap: 'a_1*' }, 
            { a: 'a_2', b: 'b_5',  bp: 'b_1',  ap: 'a_3'  },
            { a: 'a_2', b: 'b_6',  bp: 'b_4',  ap: 'a_2*' }, 
            { a: 'a_2', b: 'b_7',  bp: 'b_1*', ap: 'a_3*' },

            { a: 'a_3', b: 'b_1',  bp: 'b_7*', ap: 'a_2*' }, 
            { a: 'a_3', b: 'b_2',  bp: 'b_5',  ap: 'a_1'  },
            { a: 'a_3', b: 'b_3',  bp: 'b_3',  ap: 'a_3'  }, 
            { a: 'a_3', b: 'b_4',  bp: 'b_1',  ap: 'a_2*' },
            { a: 'a_3', b: 'b_5',  bp: 'b_4',  ap: 'a_3*' }, 
            { a: 'a_3', b: 'b_6',  bp: 'b_2*', ap: 'a_1*' },
            { a: 'a_3', b: 'b_7',  bp: 'b_2',  ap: 'a_1'  }
        ];

        // --- 3. UTILITY FUNCTIONS ---
        const SVG_NS = 'http://www.w3.org/2000/svg';
        // --- Helpers to shrink DOM/SVG boilerplate ---
        const H = (tag, props = {}, kids = []) => {
          const el = document.createElement(tag);
          const { style, ...rest } = props;
          Object.entries(rest).forEach(([k, v]) => {
            if (k === 'className') el.className = v; else if (k === 'text') el.textContent = v; else el[k] = v;
          });
          if (style) Object.entries(style).forEach(([k, v]) => el.style[k] = v);
          kids.forEach(k => el.append(k));
          return el;
        };
        const S = (tag, attrs = {}) => {
          const el = document.createElementNS(SVG_NS, tag);
          Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, String(v)));
          return el;
        };
        // Cache arrow markers by color so we don't rebuild them every time
        const markerCache = new Map();
        const markerForColor = (defs, color) => {
          if (markerCache.has(color)) return markerCache.get(color);
          const id = `arrow-${markerCache.size}`;
          const m = S('marker', { id, viewBox: '0 0 10 10', refX: 0, refY: 5, markerWidth: 5, markerHeight: 5, orient: 'auto-start-reverse', markerUnits: 'strokeWidth' });
          m.append(S('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: color, stroke: color }));
          defs.appendChild(m);
          markerCache.set(color, id);
          return id;
        };
        const isStar = (k) => k.endsWith('*');

        function getContrastColor(hex) {
            const clean = hex.replace('#', '');
            const r = parseInt(clean.substr(0, 2), 16);
            const g = parseInt(clean.substr(2, 2), 16);
            const b = parseInt(clean.substr(4, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 155 ? '#000000' : '#ffffff';
        }

        function formatQuaternion(q) {
            const [w, x, y, z] = q;
            const parts = [];
            if (w !== 0) parts.push(String(w));
            const term = (coef, sym) => {
                if (coef === 0) return;
                const sign = coef > 0 ? (parts.length ? '+' : '') : '';
                const abs = Math.abs(coef);
                parts.push(`${sign}${coef < 0 ? '-' : ''}${abs}${sym}`);
            };
            term(x, 'i');
            term(y, 'j');
            term(z, 'k');
            return parts.join('');
        }
        
        // --- 4. UI & DOM MANIPULATION ---

        function drawRelationSquares() {
            const container = document.getElementById('relations-container');
            container.innerHTML = '';
            const wrapper = H('div', { className: 'relation-square' });
            // New legend construction: two rows (compact)
            const legendContainer = H('div', { className: 'legend-container' }, [
              H('p', { className: 'legend-title', text: 'Generators' })
            ]);
            const legend = H('div', { className: 'legend' });
            const row = keys => H('div', { className: 'legend-row' }, keys.map(key => {
              const color = GENERATORS[key].color;
              const span = H('span', { text: formatQuaternion(GENERATORS[key].q) });
              span.style.backgroundColor = color; span.style.color = getContrastColor(color);
              return span;
            }));
            legend.append(row(['a_1', 'a_2', 'a_3']));
            legend.append(row(['b_1','b_2','b_3','b_4','b_5','b_6','b_7']));
            legendContainer.appendChild(legend);
            wrapper.appendChild(legendContainer);
            const relHeading = H('p', { text: 'Relations', style: { margin: '6px 0 4px 0', textAlign: 'center', fontWeight: '600' } });
            wrapper.appendChild(relHeading);
            const grid = H('div', { className: 'squares-grid' });
            wrapper.appendChild(grid);
            RELATIONS.forEach((rel, i) => {
                const cell = H('div', { className: 'square-cell' });
                const svg = S('svg', { width: 150, height: 150, viewBox: '0 0 100 100' });
                const defs = S('defs');
                svg.appendChild(defs);
                // Lightly shade the interior of the square (behind edges)
                svg.appendChild(S('rect', { x: 15, y: 15, width: 70, height: 70, fill: 'rgba(0,0,0,0.05)', stroke: 'none' }));
                const edges = [
                    // Bottom edge: a
                    { key: rel.a,  x1: 15, y1: 85, x2: 85, y2: 85, color: GENERATORS[rel.a].color },
                    // Right edge: b
                    { key: rel.b,  x1: 85, y1: 85, x2: 85, y2: 15, color: GENERATORS[rel.b].color },
                    // Left edge: b'
                    { key: rel.bp, x1: 15, y1: 85, x2: 15, y2: 15, color: GENERATORS[rel.bp].color },
                    // Top edge: a'
                    { key: rel.ap, x1: 15, y1: 15, x2: 85, y2: 15, color: GENERATORS[rel.ap].color }
                ];
                edges.forEach((e) => {
                  let { x1, y1, x2, y2 } = e;
                  if (isStar(e.key)) { [x1, x2] = [x2, x1]; [y1, y2] = [y2, y1]; }
                  const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
                  const markerId = markerForColor(defs, e.color);
                  const pathEl = S('path', {
                    d: `M ${x1} ${y1} L ${mx} ${my} L ${x2} ${y2}`,
                    fill: 'none', stroke: e.color, 'stroke-width': 3, 'marker-mid': `url(#${markerId})`
                  });
                  svg.appendChild(pathEl);
                });
                cell.appendChild(svg);
                grid.appendChild(cell);
            });
            container.appendChild(wrapper);
        }

        function populateSelectors() {
            const selX = document.getElementById('gen-x');
            const selY = document.getElementById('gen-y');

            // Only 'a' generators for X-axis
            Object.keys(GENERATORS).filter(k => k.startsWith('a')).forEach(key => {
                const labelText = formatQuaternion(GENERATORS[key].q);
                selX.add(new Option(labelText, key));
            });

            // Only 'b' generators for Y-axis
            Object.keys(GENERATORS).filter(k => k.startsWith('b')).forEach(key => {
                const labelText = formatQuaternion(GENERATORS[key].q);
                selY.add(new Option(labelText, key));
            });

            selX.value = 'a_2'; // default to 1+2j
            selY.value = 'b_1'; // default to 3+2i
        }


        // --- 5. THREE.JS VISUALIZATION ---
        let scene, camera, renderer, controls, cayleyGroup;

        function initThree() {
            const container = document.getElementById('vis-container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 2.5;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            camera.add(pointLight);
            scene.add(camera);
            const sphereGeom = new THREE.SphereGeometry(1, 64, 32);
            const sphereMat = new THREE.MeshPhongMaterial({
                color: 0x156289, emissive: 0x072534, side: THREE.BackSide,
                transparent: true, opacity: 0.2, shininess: 50
            });
            const boundarySphere = new THREE.Mesh(sphereGeom, sphereMat);
            scene.add(boundarySphere);
            cayleyGroup = new THREE.Group();
            scene.add(cayleyGroup);
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('vis-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function drawCayleyGraph() {
            while (cayleyGroup.children.length > 0) {
                cayleyGroup.remove(cayleyGroup.children[0]);
            }
            const genX_key = document.getElementById('gen-x').value;
            const genY_key = document.getElementById('gen-y').value;
            const depth = parseInt(document.getElementById('depth-slider').value);
            // Size and fade helpers
            const baseRadius = Math.max(0.05, 0.05 * (3 / (depth + 2))); // smaller for larger depth
            const radiusFor = (lvl) => Math.max(0.003, baseRadius * Math.pow(0.82, Math.max(0, lvl)));
            const edgeOpacityFor = (lvl) => Math.max(0.3, 1 - .5 * (Math.max(0, lvl) / Math.max(1, depth)));
            const q_x = GENERATORS[genX_key];
            const q_y = GENERATORS[genY_key];
            const q_x_inv_key = genX_key.endsWith('*') ? genX_key.slice(0, -1) : genX_key + '*';
            const q_y_inv_key = genY_key.endsWith('*') ? genY_key.slice(0, -1) : genY_key + '*';
            const q_x_inv = GENERATORS[q_x_inv_key];
            const q_y_inv = GENERATORS[q_y_inv_key];
            const gens = [
                { q: q_x.q, color: q_x.color },
                { q: q_y.q, color: q_y.color },
                { q: q_x_inv.q, color: q_x.color },
                { q: q_y_inv.q, color: q_y.color }
            ];
            const basePointVec = new THREE.Vector3(0, 1, 0);
            const basePointPureQ = QMath.vecToPure(basePointVec);
            const queue = [{ q: [1, 0, 0, 0], pos: basePointVec, level: 0 }];
            const visited = new Map();
            visited.set(JSON.stringify(basePointVec.toArray()), true);
            const initialVertexGeom = new THREE.SphereGeometry(radiusFor(0), 20, 12);
            const initialVertexMat = new THREE.MeshBasicMaterial({ color: 0xffd700 }); // highlight basepoint (gold)
            const initialVertex = new THREE.Mesh(initialVertexGeom, initialVertexMat);
            initialVertex.position.copy(basePointVec);
            cayleyGroup.add(initialVertex);
            while (queue.length > 0) {
                const { q, pos, level } = queue.shift();
                if (level >= depth) continue;
                for (const gen of gens) {
                    const next_q = QMath.multiply(gen.q, q);
                    const next_pos_pure = QMath.act(gen.q, QMath.vecToPure(pos));
                    const next_pos = QMath.pureToVec(next_pos_pure);
                    const posKey = JSON.stringify(next_pos.toArray().map(v => v.toFixed(5)));
                    if (!visited.has(posKey)) {
                        visited.set(posKey, true);
                        const vertexGeom = new THREE.SphereGeometry(radiusFor(level + 1), 16, 8);
                        const vertexMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: edgeOpacityFor(level + 1) });
                        const vertex = new THREE.Mesh(vertexGeom, vertexMat);
                        vertex.position.copy(next_pos);
                        cayleyGroup.add(vertex);
                        const curve = new THREE.CatmullRomCurve3([
                            pos.clone().multiplyScalar(0.99),
                            pos.clone().add(next_pos).normalize(),
                            next_pos.clone().multiplyScalar(0.99)
                        ]);
                        const points = curve.getPoints(20);
                        const edgeGeom = new THREE.BufferGeometry().setFromPoints(points);
                        const edgeMat = new THREE.LineBasicMaterial({ color: gen.color, linewidth: 2, transparent: true, opacity: edgeOpacityFor(level + 1) });
                        const edge = new THREE.Line(edgeGeom, edgeMat);
                        cayleyGroup.add(edge);
                        queue.push({ q: next_q, pos: next_pos, level: level + 1 });
                    }
                }
            }
        }
        
        // --- 6. SVG SQUARE COMPLEX VISUALIZATION ---
        
        function drawSquareComplex() {
            const container = document.getElementById('square-complex-container');
            container.innerHTML = '';
            const svg = S('svg', { width: '100%', height: '100%', viewBox: '0 0 1000 1000' });
            container.appendChild(svg);
            const defs = S('defs');
            svg.appendChild(defs);
            const depth = parseInt(document.getElementById('depth-slider').value);
            const genX_key = document.getElementById('gen-x').value;
            const genY_key = document.getElementById('gen-y').value;
            const findRelation = (a, b) => RELATIONS.find(r => r.a === a && r.b === b);
            const rel = findRelation(genX_key, genY_key);
            const squareSize = 900 / (2 * depth + 1);
            const transform = (i, j) => [500 + i * squareSize, 500 - j * squareSize];

            const drawEdge = (x1, y1, x2, y2, genKey) => {
                if (!genKey) return;
                const gen = GENERATORS[genKey];
                let [p1x, p1y] = transform(x1, y1);
                let [p2x, p2y] = transform(x2, y2);
                if (isStar(genKey)) { [p1x, p2x] = [p2x, p1x]; [p1y, p2y] = [p2y, p1y]; }
                const mx = (p1x + p2x) / 2;
                const my = (p1y + p2y) / 2;
                const markerId = markerForColor(defs, gen.color);
                const pathEl = S('path', {
                  d: `M ${p1x} ${p1y} L ${mx} ${my} L ${p2x} ${p2y}`,
                  fill: 'none', stroke: gen.color, 'stroke-width': 2.5, 'marker-mid': `url(#${markerId})`
                });
                svg.appendChild(pathEl);
            };
            const aLo = genX_key;
            const bLo = genY_key;
            const aHi = rel ? rel.ap : genX_key;
            const bHi = rel ? rel.bp : genY_key;
            for (let i = -depth; i <= depth; i++) {
                for (let j = -depth; j <= depth; j++) {
                    if (i < depth) {
                        // Horizontal edge from (i,j) -> (i+1,j): alternate a/a' by row parity
                        const keyH = ((j & 1) === 0) ? aLo : aHi;
                        drawEdge(i, j, i + 1, j, keyH);
                    }
                    if (j < depth) {
                        // Vertical edge from (i,j) -> (i,j+1): alternate b/b' by column parity
                        const keyV = ((i & 1) === 0) ? bLo : bHi;
                        drawEdge(i, j, i, j + 1, keyV);
                    }
                }
            }
            
            // Draw origin marker as a gold disk
            const [cx, cy] = transform(0, 0);
            const originR = Math.max(5, Math.min(14, squareSize * 0.22));
            const origin = S('circle', {
              cx: String(cx), cy: String(cy), r: String(originR),
              fill: '#ffd700', stroke: '#b8860b', 'stroke-width': '2'
            });
            svg.appendChild(origin);
        }

        // --- 7. INITIALIZATION ---

        function setupEventListeners() {
            const genX = document.getElementById('gen-x');
            const genY = document.getElementById('gen-y');
            const depthSlider = document.getElementById('depth-slider');
            const depthValue = document.getElementById('depth-value');

            const updateAll = () => {
                drawCayleyGraph();
                drawSquareComplex();
            };
            
            genX.addEventListener('change', updateAll);
            genY.addEventListener('change', updateAll);
            
            depthSlider.addEventListener('input', () => {
                depthValue.textContent = depthSlider.value;
            });
            depthSlider.addEventListener('change', updateAll);
        }

        // Main execution
        drawRelationSquares();
        populateSelectors();
        initThree();
        drawCayleyGraph();
        drawSquareComplex(); // Initial draw for the square complex
        setupEventListeners();

        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise();
        } else {
            window.addEventListener('load', () => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise();
                }
            });
        }

    </script>
</body>

</html>