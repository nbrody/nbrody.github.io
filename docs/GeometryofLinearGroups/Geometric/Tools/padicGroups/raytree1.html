<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>k‑Regular Tree by Circle Inversions (Ray‑Marched)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0b0d12; color: #e7eaf0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr auto; }
    canvas { width: 100%; height: 100%; display: block; }
    .panel {
      display: grid; gap: .5rem; grid-template-columns: repeat(6, minmax(0,1fr));
      padding: .6rem .8rem; background: rgba(15,18,25,.9); border-top: 1px solid rgba(255,255,255,.08);
      align-items: center; font-size: 13px;
    }
    .panel label { opacity: .9; }
    .panel input[type="range"] { width: 100%; }
    .row { display: contents; }
    .btn { padding: .35rem .6rem; background: #1f2735; border: 1px solid #30405e; border-radius: 6px; color: #cfe2ff; cursor: pointer; }
    .btn:active { transform: translateY(1px); }
    .small { font-size: 12px; opacity: .85; }
    a { color: #9dd4ff; text-decoration: none; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="gl"></canvas>

    <div class="panel" id="ui">
      <div class="row"><label>k</label><input id="k" type="range" min="3" max="24" step="1" value="6"><span id="kVal"></span></div>
      <div class="row"><label>Thickness</label><input id="thick" type="range" min="0.3" max="3.0" step="0.01" value="1.0"><span id="thickVal"></span></div>
      <div class="row"><label>Folds</label><input id="folds" type="range" min="4" max="40" step="1" value="18"><span id="foldsVal"></span></div>
      <div class="row"><label>Fade</label><input id="fade" type="range" min="0.70" max="0.99" step="0.005" value="0.86"><span id="fadeVal"></span></div>
      <div class="row"><label>Show circles</label><input id="showCircles" type="checkbox" checked></div>
      <div class="row"><button id="reset" class="btn">Reset view</button><button id="save" class="btn" style="margin-left:.5rem">Save PNG</button></div>
      <div class="row" style="grid-column: 1 / -1;">
        <span class="small">Drag to pan • Wheel / pinch to zoom • The seed consists of k radial segments from the origin to the nearest point on each orthogonal circle. The infinite k‑regular tree is generated by circle inversions and rendered via a distance‑estimator “ray march,” avoiding explicit word growth.</span>
      </div>
    </div>
  </div>

  <script>
  // Minimal WebGL boilerplate
  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl', {antialias:false, depth:false, preserveDrawingBuffer:true});
  if (!gl) alert('WebGL not supported');

  const vertSrc = `
  attribute vec2 aPos;
  void main(){ gl_Position = vec4(aPos, 0.0, 1.0); }
  `;

  const fragSrc = `
  precision highp float;
  uniform vec2 uRes;
  uniform float uTime;
  uniform int uK;
  uniform float uZoom;
  uniform vec2 uPan;
  uniform float uThickness;
  uniform int uMaxFolds;
  uniform float uFade; // per-fold brightness decay
  uniform bool uShowCircles;

  // Constants
  const float PI = 3.1415926535897932384626433832795;
  const int MAXK = 64;           // hard cap to allow dynamic loops
  const int MAX_STEPS = 64;      // 2D sphere-trace steps (enough for crisp lines)
  const float MAX_DIST = 4.0;    // max travel in normalized view coords
  const float EPS = 1e-5;        // numerical epsilon

  // Rotate by angle a
  mat2 rot(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }

  // Distance from p to segment AB
  float sdSegment(vec2 p, vec2 a, vec2 b){
    vec2 pa = p - a, ba = b - a;
    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);
    return length(pa - ba*h);
  }

  // Inversion fold (in-place): if |p-c| < s, invert p across circle (c,s).
  void invertFold(inout vec2 p, vec2 c, float s, inout float scale, inout int hits){
    vec2 d = p - c; float r2 = dot(d,d);
    float s2 = s*s;
    if (r2 < s2){
      p = c + s2 * d / max(r2, EPS);
      scale *= s2 / max(r2, EPS);
      hits += 1;
    }
  }

  // Bring p into the “outside of all circles” fundamental region by repeatedly
  // inverting across any circle that contains it. Accumulate local scale factor.
  // Returns folded point, scale, and number of inversions applied.
  void foldPoint(inout vec2 p, float d, float s, out float scale, out int hits){
    scale = 1.0; hits = 0;
    // Repeat passes; stop early if no inversions on a full pass
    for (int pass = 0; pass < 80; ++pass){
      bool changed = false;
      for (int i=0; i<MAXK; ++i){
        if (i >= uK) break;
        float theta0 = PI * 0.5; // one circle directly above the origin
        float angle = theta0 + (2.0*PI * float(i)) / float(uK);
        vec2 c = d * vec2(cos(angle), sin(angle));
        vec2 q = p - c; float r2 = dot(q,q);
        if (i > 0 && r2 < s*s){
          invertFold(p, c, s, scale, hits);
          changed = true;
        }
      }
      if (!changed || hits >= uMaxFolds) break;
    }
  }

  // Distance estimator to the replicated tree edges.
  // Strategy: Fold the query point by circle inversions into a base region,
  // then measure distance to the k seed segments from the origin to each circle’s
  // nearest point (radius rho = d - s). Finally rescale by the accumulated
  // conformal scale factor from the inversion chain.
  float treeDE(vec2 p, float d, float s, out float brightness, out int invCount){
    float scale; int hits;
    vec2 z = p;
    foldPoint(z, d, s, scale, hits);
    invCount = hits;

    // Seed: k segments from 0 to (d-s) * dir(theta_j)
    float rho = d - s;
    float mind = 1e9;
    for (int i=0; i<MAXK; ++i){
      if (i >= uK) break;
      float theta0 = PI * 0.5;
      float angle = theta0 + (2.0*PI * float(i)) / float(uK);
      vec2 q = rho * vec2(cos(angle), sin(angle));
      float di = sdSegment(z, vec2(0.0), q);
      mind = min(mind, di);
    }

    // Distance in original space ≈ scale * distance_in_folded_space
    float dist = mind * scale;

    // Simple per-level fading: deeper inversions get paler
    brightness = pow(uFade, float(hits));
    return dist;
  }

  // Optional helper: distance to the unit circle and the necklace (for debug)
  float circleDist(vec2 p, vec2 c, float r){ return abs(length(p - c) - r); }

  vec3 palette(float t){
    vec3 a = vec3(0.5);
    vec3 b = vec3(0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.0, 0.33, 0.67);
    return a + b * cos(6.2831853 * (c * t + d));
  }

  vec3 render(vec2 fragCoord){
    // Normalize coords (preserve aspect): one unit ~ screen height
    vec2 uv = (fragCoord - 0.5*uRes) / uRes.y;

    // Apply pan/zoom: uv' = (uv - pan)/zoom
    vec2 p = (uv - uPan) / max(uZoom, 1e-4);

    // Circle parameters from orthogonal+tangent constraints:
    // If k circles of radius s are arranged evenly, tangent to neighbors,
    // and each orthogonal to the unit circle, then:
    //   s = tan(pi/k),  d = sec(pi/k)
    float a = PI / float(uK);
    float d = 1.0 / cos(a);
    float s = tan(a);

    // 2D "ray march": not along a 3D ray, but a sphere-trace in the plane using the
    // distance estimator to find the implicit 1D set where dist ~ 0 (the tree edges).
    float t = 0.0;
    float brightness = 1.0;
    float dist = 0.0;
    int hcountOut = 0;
    vec2 x = p;
    bool hit = false;
    for (int i=0; i<MAX_STEPS; ++i){
      float b;
      int hcount;
      dist = treeDE(x, d, s, b, hcount);
      hcountOut = hcount;
      brightness = b;
      if (dist < 1e-4){ hit = true; break; }
      if (t > MAX_DIST) break;
      float stepLen = max(dist, 0.002); // floor avoids getting stuck
      // March in the (arbitrary) local gradient direction approximation using finite diff
      // Compute a crude gradient of the DE to bias marching direction.
      vec2 e = vec2(1e-3, 0.0);
      int tmp;
      float d1 = treeDE(x + e, d, s, b, tmp);
      float d2 = treeDE(x + e.yx, d, s, b, tmp);
      vec2 g = normalize(vec2(d1 - dist, d2 - dist));
      if (!((g.x==g.x) && (g.y==g.y))) g = vec2(1.0, 0.0); // NaN guard
      x += g * stepLen; t += stepLen;
    }

    float edge = smoothstep(0.0, uThickness * 0.0025, dist);
    float line = 1.0 - edge;

    // Map inversion count to a hue-based palette
    float tcol = clamp(float(hcountOut) / max(1.0, float(uMaxFolds)), 0.0, 1.0);
    vec3 col = palette(tcol) * brightness * line;

    // Optional debug: draw the unit circle and the necklace
    if (uShowCircles){
      float aUnit = smoothstep(0.0025, 0.0, circleDist(p, vec2(0.0), 1.0));
      col = mix(col, vec3(0.9,0.85,0.4), aUnit);
      float aNeck = 0.0;
      for (int i=0; i<MAXK; ++i){
        if (i >= uK) break;
        float theta0 = PI * 0.5;
        float angle = theta0 + (2.0*PI * float(i)) / float(uK);
        vec2 c = d * vec2(cos(angle), sin(angle));
        float aC = smoothstep(0.0018, 0.0, circleDist(p, c, s));
        aNeck = max(aNeck, aC);
      }
      col = mix(col, vec3(0.98,0.72,0.35), aNeck);

      // Draw the seed radial segments faintly (in the unfolded space for reference)
      float rho = d - s; float seedMin = 1e9;
      for (int i=0; i<MAXK; ++i){
        if (i >= uK) break;
        float theta0 = PI * 0.5;
        float angle = theta0 + (2.0*PI * float(i)) / float(uK);
        vec2 q = rho * vec2(cos(angle), sin(angle));
        seedMin = min(seedMin, sdSegment(p, vec2(0.0), q));
      }
      float aSeed = smoothstep(0.004, 0.0, seedMin);
      col = mix(col, vec3(0.75,0.95,0.95), aSeed*0.65);
    }

    // Subtle vignette for depth
    float r = length((fragCoord - 0.5*uRes) / uRes);
    col *= 0.98 - 0.25*r*r;

    return clamp(col, 0.0, 1.0);
  }

  void main(){
    vec2 fragCoord = gl_FragCoord.xy;
    vec3 col = render(fragCoord);
    gl_FragColor = vec4(col, 1.0);
  }
  `;

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      const info = gl.getShaderInfoLog(sh);
      console.error(info); throw new Error(info);
    }
    return sh;
  }

  function program(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
    gl.bindAttribLocation(p, 0, 'aPos');
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)){
      const info = gl.getProgramInfoLog(p);
      console.error(info); throw new Error(info);
    }
    return p;
  }

  const prog = program(vertSrc, fragSrc);
  gl.useProgram(prog);

  const quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1,1,
     1,-1,  1, 1, -1,1,
  ]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  // Uniforms
  const uRes = gl.getUniformLocation(prog,'uRes');
  const uTime = gl.getUniformLocation(prog,'uTime');
  const uK = gl.getUniformLocation(prog,'uK');
  const uZoom = gl.getUniformLocation(prog,'uZoom');
  const uPan = gl.getUniformLocation(prog,'uPan');
  const uThickness = gl.getUniformLocation(prog,'uThickness');
  const uMaxFolds = gl.getUniformLocation(prog,'uMaxFolds');
  const uFade = gl.getUniformLocation(prog,'uFade');
  const uShowCircles = gl.getUniformLocation(prog,'uShowCircles');

  // UI state
  const kEl = document.getElementById('k');
  const thickEl = document.getElementById('thick');
  const foldsEl = document.getElementById('folds');
  const fadeEl = document.getElementById('fade');
  const kVal = document.getElementById('kVal');
  const thickVal = document.getElementById('thickVal');
  const foldsVal = document.getElementById('foldsVal');
  const fadeVal = document.getElementById('fadeVal');
  const showCirclesEl = document.getElementById('showCircles');
  const resetBtn = document.getElementById('reset');
  const saveBtn = document.getElementById('save');

  function updateLabels(){
    kVal.textContent = kEl.value;
    thickVal.textContent = Number(thickEl.value).toFixed(2);
    foldsVal.textContent = foldsEl.value;
    fadeVal.textContent = Number(fadeEl.value).toFixed(3);
  }
  updateLabels();
  [kEl, thickEl, foldsEl, fadeEl, showCirclesEl].forEach(el => el.addEventListener('input', updateLabels));

  // Pan & zoom
  let zoom = 1.0;
  let pan = {x:0, y:0};
  let dragging = false;
  let last = {x:0, y:0};

  function toNDC(e){
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) / rect.width,
      y: (e.clientY - rect.top) / rect.height
    };
  }

  canvas.addEventListener('mousedown', e=>{ dragging = true; last = toNDC(e); });
  window.addEventListener('mouseup', ()=> dragging=false);
  window.addEventListener('mousemove', e=>{
    if (!dragging) return;
    const cur = toNDC(e);
    const dx = (cur.x - last.x);
    const dy = (cur.y - last.y);
    // Screen space to world: preserve aspect by using height scale
    pan.x -= dx * (canvas.width / canvas.height) * zoom;
    pan.y += dy * zoom;
    last = cur;
  });

  canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const sign = Math.sign(e.deltaY);
    const factor = Math.pow(1.1, sign);
    zoom *= factor;
    zoom = Math.min(Math.max(zoom, 0.05), 20.0);
  }, {passive:false});

  resetBtn.addEventListener('click', ()=>{ zoom = 1.0; pan.x = pan.y = 0; });

  saveBtn.addEventListener('click', ()=>{
    const link = document.createElement('a');
    link.download = `kTree_${kEl.value}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (w !== canvas.width || h !== canvas.height){
      canvas.width = w; canvas.height = h; gl.viewport(0,0,w,h);
    }
    gl.uniform2f(uRes, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  // Render loop
  let t0 = performance.now();
  function frame(){
    resize();
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform1f(uTime, (performance.now()-t0)/1000);
    gl.uniform1i(uK, parseInt(kEl.value,10));
    gl.uniform1f(uZoom, zoom);
    gl.uniform2f(uPan, pan.x, pan.y);
    gl.uniform1f(uThickness, parseFloat(thickEl.value));
    gl.uniform1i(uMaxFolds, parseInt(foldsEl.value,10));
    gl.uniform1f(uFade, parseFloat(fadeEl.value));
    gl.uniform1i(uShowCircles, showCirclesEl.checked ? 1 : 0);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(frame);
  }
  frame();
  </script>
</body>
</html>
