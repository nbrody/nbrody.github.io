<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>k‑Regular Tree via Circle Inversions (Ray‑Marched)</title>
<style>
  html, body { margin:0; height:100%; background:#0b0b10; color:#e8e8ef; font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  #wrap { position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr; }
  header { display:flex; gap:.6rem; align-items:center; padding:.5rem .75rem; background:#0f0f16; border-bottom:1px solid #1b1b24; }
  header h1 { font-size:14px; margin:0; font-weight:600; color:#b9c2ff; letter-spacing:.2px; }
  .spacer { flex:1; }
  .ctrl { display:flex; align-items:center; gap:.4rem; color:#cfcfe8; }
  .ctrl input[type="range"] { width:160px; }
  .ctrl input[type="number"] { width:70px; }
  .btn { background:#1b1b28; border:1px solid #29293a; color:#e8e8ef; border-radius:8px; padding:.45rem .7rem; cursor:pointer; }
  .btn:hover { background:#222235; }
  #canvas { width:100%; height:100%; display:block; cursor: grab; }
  #canvas.dragging { cursor: grabbing; }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>k‑Regular Tree (inversions)</h1>
    <div class="spacer"></div>
    <div class="ctrl"><label>k:</label><input id="k" type="range" min="3" max="24" value="6"><span id="kval">6</span></div>
    <div class="ctrl"><label>Iter:</label><input id="iter" type="range" min="4" max="80" value="48"></div>
    <div class="ctrl"><label>Thickness:</label><input id="thick" type="range" min="1" max="40" value="16"></div>
    <div class="ctrl"><label>Show circles:</label><input id="showCircles" type="checkbox"></div>
    <div class="ctrl"><label>Neighbor links:</label><input id="nbrLinks" type="checkbox" checked></div>
    <button id="reset" class="btn">Reset view</button>
    <button id="save"  class="btn" title="Save PNG">Save</button>
  </header>
  <canvas id="canvas"></canvas>
</div>

<script>
// ——— WebGL2 setup ————————————————————————————————————————————————————————
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2', { antialias:true, preserveDrawingBuffer:true });
if(!gl){ alert('WebGL2 not available'); throw new Error('WebGL2 required'); }

const DPR = Math.max(1, window.devicePixelRatio || 1);
function resize(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  canvas.width  = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  gl.viewport(0,0,canvas.width, canvas.height);
}
new ResizeObserver(resize).observe(canvas);

// ——— Shaders ————————————————————————————————————————————————————————————————
const vertSrc = `#version 300 es
precision highp float;
layout(location=0) in vec2 a_pos;
void main(){ gl_Position = vec4(a_pos, 0.0, 1.0); }
`;

const fragSrc = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform vec2  uRes;
uniform float uTime;
uniform float uZoom;      // world units per screen unit (smaller => zoom in)
uniform vec2  uCenter;    // world center
uniform int   uIters;      // max folding steps
uniform int   uK;          // regular degree
uniform float uThickness;  // line thickness (in px-ish)
uniform int   uShowCircles;// debug circles
uniform int   uNeighborLinks; // 1 = include segments between adjacent outer centers

const float PI = 3.1415926535897932384626433832795;

// Inversion across circle (center c, radius rad)
vec2 invertCircle(vec2 z, vec2 c, float rad, out float scaleMul){
  vec2 v = z - c; float vv = dot(v,v);
  float s = (rad*rad) / max(vv, 1e-30);
  scaleMul *= s;  // |dw/dz|
  return c + v * s;
}

// Distance to segment [a,b]
float sdSegment(vec2 p, vec2 a, vec2 b){
  vec2 pa = p - a; vec2 ba = b - a;
  float h = clamp(dot(pa,ba)/max(dot(ba,ba), 1e-30), 0.0, 1.0);
  return length(pa - ba*h);
}

struct DEOut { float dist; float shade; };

DEOut treeDE(vec2 z0, int maxSteps, int k){
  // Geometry derived from: outer circles of radius r, centers at distance d,
  // tangent to unit circle and each other with angular spacing 2π/k.
  float alpha = PI/float(k);
  float s = sin(alpha);
  float r = s / (1.0 - s);
  float d = 1.0 + r; // = 1/(1 - sin(pi/k))

  vec2 z = z0;
  float scale = 1.0;
  float shade = 0.0;

  // Fold into domain: inside unit circle & outside all outer circles
  for(int i=0;i<256;i++){
    if(i>=maxSteps) break;
    bool did = false;
    float dO = length(z);
    if(dO > 1.0){
      z = invertCircle(z, vec2(0.0), 1.0, scale);
      shade += 0.3;
      did = true;
    } else {
      // if inside any outer circle, invert across it
      for(int j=0;j<96;j++){
        if(j>=k) break;
        float theta = 0.5*PI + (2.0*PI*float(j))/float(k);
        vec2  cj = d * vec2(cos(theta), sin(theta));
        float dj = length(z - cj);
        if(dj < r){
          z = invertCircle(z, cj, r, scale);
          shade += 1.0;
          did = true;
          break;
        }
      }
    }
    if(!did) break;
  }

  // Distance to the seed:
  //  (1) k radial segments from origin to each outer center (always)
  //  (1b) k "little" edges from origin to each tangency point on the unit circle
  //  (2) optional neighbor links between adjacent outer centers (degree-2 ring)
  float dist = 1e9;
  float stepAng = (2.0*PI)/float(k);
  for(int j=0;j<96;j++){
    if(j>=k) break;
    float theta = 0.5*PI + stepAng*float(j);
    vec2  cj = d * vec2(cos(theta), sin(theta));

    // (1) radial spoke (origin -> outer center)
    dist = min(dist, sdSegment(z, vec2(0.0), cj));

    // (1b) "little" edge (origin -> tangency point on unit circle)
    //      This gets carried by the inversion dynamics to create infinitely many branches.
    vec2  pj = vec2(cos(theta), sin(theta));
    dist = min(dist, sdSegment(z, vec2(0.0), pj));

    // (2) neighbor link (j -> j+1 mod k)
    if(uNeighborLinks==1){
      float thetaN = theta + stepAng;
      vec2  cn = d * vec2(cos(thetaN), sin(thetaN));
      dist = min(dist, sdSegment(z, cj, cn));
    }
  }

  dist = dist / max(scale, 1e-30);
  return DEOut(dist, shade);
}

void main(){
  // Pixel -> world coordinates (keep aspect by dividing by uRes.y)
  vec2 uv = (gl_FragCoord.xy - 0.5*uRes) / uRes.y;
  vec2 z  = uv / uZoom + uCenter;

  // Evaluate DE for the folded tree
  DEOut de = treeDE(z, uIters, uK);

  // Pixel footprint in world units (no derivatives required)
  float px = 1.0 / (uRes.y * uZoom);
  float thickness = (uThickness * 0.03) * px; // tweak
  float aa = 0.9*px;

  // Line mask
  float line = 1.0 - smoothstep(thickness, thickness + aa, de.dist);

  // Background
  float vign = smoothstep(1.4, 0.0, length(uv));
  vec3  bg   = mix(vec3(0.015,0.018,0.030), vec3(0.03,0.035,0.06), vign);

  // Ink color with a subtle orbit tint
  vec3 ink = mix(vec3(0.92), vec3(0.7,0.8,1.0), 0.25 + 0.25*sin(0.12*de.shade + 0.1*uTime));
  vec3 col = mix(bg, ink, line);

  // Optional: lightly draw construction circles for context
  if(uShowCircles==1){
    float alpha = PI/float(uK);
    float s = sin(alpha);
    float r = s / (1.0 - s);
    float d = 1.0 + r;
    float du = abs(length(z) - 1.0);
    float cu = 1.0 - smoothstep(0.5*px, 1.6*px, du);
    col = mix(col, vec3(0.35,0.45,0.9), cu*0.35);
    for(int j=0;j<96;j++){
      if(j>=uK) break;
      float theta = 0.5*PI + (2.0*PI*float(j))/float(uK);
      vec2  cj = d * vec2(cos(theta), sin(theta));
      float dj = abs(length(z - cj) - r);
      float c  = 1.0 - smoothstep(0.5*px, 1.6*px, dj);
      col = mix(col, vec3(0.5,0.6,0.85), c*0.25);
    }
  }

  fragColor = vec4(col, 1.0);
}
`;

function compile(gl, type, src){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    const info = gl.getShaderInfoLog(sh);
    console.error(info); throw new Error('Shader compile failed');
  }
  return sh;
}

const vs = compile(gl, gl.VERTEX_SHADER,   vertSrc);
const fs = compile(gl, gl.FRAGMENT_SHADER, fragSrc);
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
  const info = gl.getProgramInfoLog(prog);
  console.error(info); throw new Error('Program link failed');
}
gl.useProgram(prog);

// Fullscreen triangle
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 3,-1, -1,3 ]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uRes   = gl.getUniformLocation(prog, 'uRes');
const uTime  = gl.getUniformLocation(prog, 'uTime');
const uZoom  = gl.getUniformLocation(prog, 'uZoom');
const uCenter= gl.getUniformLocation(prog, 'uCenter');
const uIters = gl.getUniformLocation(prog, 'uIters');
const uK     = gl.getUniformLocation(prog, 'uK');
const uThick = gl.getUniformLocation(prog, 'uThickness');
const uShowC = gl.getUniformLocation(prog, 'uShowCircles');
const uNbrLinks = gl.getUniformLocation(prog, 'uNeighborLinks');

// ——— Interaction & controls ————————————————————————————————————————————
let zoom = 0.9;
let center = { x:0.0, y:0.0 };
let t0 = performance.now();

const kEl      = document.getElementById('k');
const kValEl   = document.getElementById('kval');
const iterEl   = document.getElementById('iter');
const thickEl  = document.getElementById('thick');
const showCE   = document.getElementById('showCircles');
const nbrLinksEl = document.getElementById('nbrLinks');
const resetBtn = document.getElementById('reset');
const saveBtn  = document.getElementById('save');

kEl.addEventListener('input', ()=>{ kValEl.textContent = kEl.value; });
resetBtn.onclick = () => { zoom = 0.9; center.x = 0.0; center.y = 0.0; };
saveBtn.onclick = () => {
  const a = document.createElement('a');
  a.download = `kTree_k${kEl.value}.png`;
  a.href = canvas.toDataURL('image/png');
  a.click();
};

// Click-and-drag pan (Pointer Events), cursor-anchored wheel zoom
let dragging=false, lastX=0, lastY=0;
canvas.addEventListener('pointerdown', (e)=>{
  dragging=true; lastX=e.clientX; lastY=e.clientY;
  canvas.setPointerCapture(e.pointerId);
  canvas.classList.add('dragging');
});
canvas.addEventListener('pointermove', (e)=>{
  if(!dragging) return;
  const dxDev = (e.clientX - lastX) * DPR;
  const dyDev = (e.clientY - lastY) * DPR;
  const worldDX = dxDev / (canvas.height * zoom);
  const worldDY = dyDev / (canvas.height * zoom);
  center.x -= worldDX; center.y += worldDY;
  lastX=e.clientX; lastY=e.clientY;
});
function endDrag(e){ dragging=false; canvas.classList.remove('dragging'); try{ canvas.releasePointerCapture(e.pointerId);}catch{}}
canvas.addEventListener('pointerup', endDrag);
canvas.addEventListener('pointercancel', endDrag);

canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * DPR;
  const my = (e.clientY - rect.top)  * DPR;
  const uvx = (mx - 0.5*canvas.width)  / canvas.height;
  const uvy = (my - 0.5*canvas.height) / canvas.height;
  const worldBefore = { x: uvx/zoom + center.x, y: uvy/zoom + center.y };
  const factor = Math.exp(-e.deltaY * 0.0015);
  const newZoom = zoom * factor;
  zoom = Math.max(1e-8, newZoom);
  const worldAfter  = { x: uvx/zoom + center.x, y: uvy/zoom + center.y };
  center.x += (worldBefore.x - worldAfter.x);
  center.y += (worldBefore.y - worldAfter.y);
}, {passive:false});

// ——— Render loop ——————————————————————————————————————————————————————
function draw(){
  resize();
  gl.useProgram(prog);
  gl.uniform2f(uRes, canvas.width, canvas.height);
  gl.uniform1f(uTime, (performance.now()-t0)*0.001);
  gl.uniform1f(uZoom, zoom);
  gl.uniform2f(uCenter, center.x, center.y);
  gl.uniform1i(uIters, parseInt(iterEl.value,10));
  gl.uniform1i(uK,     parseInt(kEl.value,10));
  gl.uniform1f(uThick, parseFloat(thickEl.value));
  gl.uniform1i(uShowC, showCE.checked ? 1 : 0);
  gl.uniform1i(uNbrLinks, nbrLinksEl.checked ? 1 : 0);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(draw);
}

kValEl.textContent = kEl.value;
draw();
</script>
</body>
</html>
