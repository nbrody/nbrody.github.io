<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dirichlet Polyhedron Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; overflow: hidden; }
        #viewer { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
        .control-panel {
            position: absolute;
            top: 2rem;
            right: 2rem;
            width: 450px;
            max-height: calc(100vh - 4rem);
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease-in-out;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
        }
        #panel-content-wrapper {
             max-height: 80vh;
             overflow-y: auto;
             transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        .content-hidden {
            max-height: 0 !important;
            opacity: 0;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-top: 0 !important;
        }
        .matrix-input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; border: 2px solid #e5e7eb; padding: 0.75rem; border-radius: 0.5rem; }
        .matrix-input { width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #D1D5DB; background-color: #f9fafb; }
        .matrix-display { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; padding: 0.75rem; border-radius: 0.5rem; background-color: #f3f4f6; border: 1px solid #e5e7eb; font-family: monospace; align-items: center; justify-items: center; }
    </style>
</head>
<body class="bg-gray-900">
    <div id="viewer"></div>

    <div class="control-panel p-6">
        <div id="panel-header" class="flex justify-between items-center cursor-pointer">
            <header>
                <h1 class="text-2xl font-bold text-gray-900">Controls</h1>
                <p class="mt-1 text-sm text-gray-600">Kleinian Groups</p>
            </header>
            <button id="toggle-panel-btn" class="p-2 rounded-full hover:bg-gray-200 focus:outline-none">
                 <svg id="chevron-icon" class="w-6 h-6 text-gray-700 transition-transform duration-300 transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </button>
        </div>

        <div id="panel-content-wrapper" class="mt-4">
            <div id="panel-content">
                <div class="mb-4">
                    <h3 class="text-lg font-medium mb-3">Add Generator</h3>
                    <div class="matrix-input-grid">
                        <input type="text" id="a" placeholder="a" class="matrix-input" value="1">
                        <input type="text" id="b" placeholder="b" class="matrix-input" value="1+i">
                        <input type="text" id="c" placeholder="c" class="matrix-input" value="0">
                        <input type="text" id="d" placeholder="d" class="matrix-input" value="1">
                    </div>
                    <button id="addMatrixBtn" class="mt-4 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">Add Matrix</button>
                </div>
                
                <div class="mb-4">
                    <label for="wordLength" class="block text-sm font-medium text-gray-700">Word Length</label>
                    <input type="number" id="wordLength" value="1" min="1" max="5" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>

                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-3">Generators</h3>
                    <div id="matrixListContainer" class="space-y-3 max-h-40 overflow-y-auto p-2 bg-gray-50 rounded-lg"></div>
                </div>

                <div>
                    <button id="generateBtn" class="w-full bg-teal-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-600 transition-colors mb-2">Generate Polyhedron</button>
                    <button id="resetBtn" class="w-full bg-slate-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-700 transition-colors">Reset</button>
                </div>
                <div id="message-box" class="mt-4 p-3 text-center text-sm rounded-lg hidden"></div>
            </div>
        </div>
        <div id="loader" class="absolute inset-0 bg-white bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-blue-500"></div>
        </div>
    </div>

    <script type="module">
        // --- THREE.js Setup ---
        let scene, camera, renderer, controls;
        let polyhedronGroup = new THREE.Group();
        const viewer = document.getElementById('viewer');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 5);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            viewer.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1, 0);
            const ambientLight = new THREE.AmbientLight(0xcccccc, 1.0);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(2, 5, 3);
            scene.add(directionalLight);
            const planeGeom = new THREE.PlaneGeometry(20, 20);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
            const boundaryPlane = new THREE.Mesh(planeGeom, planeMat);
            boundaryPlane.rotation.x = -Math.PI / 2;
            scene.add(boundaryPlane);
            const basepointGeom = new THREE.SphereGeometry(0.1, 16, 16);
            const basepointMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const basepointMesh = new THREE.Mesh(basepointGeom, basepointMat);
            basepointMesh.position.set(0, 1, 0);
            scene.add(basepointMesh);
            scene.add(polyhedronGroup);
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- Complex Number and Matrix Logic ---
        class Complex {
            constructor(re = 0, im = 0) { this.re = re; this.im = im; }
            add(z) { return new Complex(this.re + z.re, this.im + z.im); }
            sub(z) { return new Complex(this.re - z.re, this.im - z.im); }
            mul(z) { return new Complex(this.re * z.re - this.im * z.im, this.re * z.im + this.im * z.re); }
            div(z) {
                const denom = z.re * z.re + z.im * z.im;
                if (denom === 0) return new Complex(Infinity, Infinity);
                return new Complex((this.re * z.re + this.im * z.im) / denom, (this.im * z.re - this.re * z.im) / denom);
            }
            conjugate() { return new Complex(this.re, -this.im); }
            normSq() { return this.re * this.re + this.im * this.im; }
            abs() { return Math.sqrt(this.normSq()); }
            toString() {
                const formatNum = (x) => {
                    // show integers without decimals, otherwise trim trailing zeros
                    if (Math.abs(x - Math.round(x)) < 1e-9) return String(Math.round(x));
                    return String(parseFloat(x.toFixed(6)));
                };
                const reZero  = Math.abs(this.re) < 1e-9;
                const imZero  = Math.abs(this.im) < 1e-9;

                // purely real
                if (imZero) return formatNum(this.re);

                // purely imaginary
                if (reZero) {
                    const coeff = this.im === 1 ? '' : this.im === -1 ? '-' : formatNum(this.im);
                    return `${coeff}i`;
                }

                // generic complex number
                const rePart = formatNum(this.re);
                const imAbs  = Math.abs(this.im);
                const imPart = imAbs === 1 ? 'i' : `${formatNum(imAbs)}i`;
                const sign   = this.im < 0 ? '-' : '+';
                return `${rePart} ${sign} ${imPart}`;
            }
        }
        function parseComplex(str) {
            let s = str.trim().replace(/\s/g, '').toLowerCase();
            if (s.length === 0) return new Complex(0, 0);
            s = s.replace(/^i$/, '1i').replace(/^-i$/, '-1i').replace(/\+i$/, '+1i').replace(/-i$/, '-1i');
            let real = 0, imag = 0;
            const terms = s.match(/[+-]?(?:[^+-]+)/g) || [];
            for (const term of terms) {
                if (term.endsWith('i')) {
                    const coeffStr = term.substring(0, term.length - 1);
                    imag += parseFloat(coeffStr === '' || coeffStr === '+' ? '1' : (coeffStr === '-' ? '-1' : coeffStr));
                } else if (term.includes('sqrt')) {
                    const numMatch = term.match(/sqrt\(([^)]+)\)/);
                    if (numMatch && numMatch[1]) {
                        real += (term.startsWith('-') ? -1 : 1) * Math.sqrt(parseFloat(numMatch[1]));
                    }
                } else {
                    real += parseFloat(term);
                }
            }
            return new Complex(real, imag);
        }
        class Matrix2 {
            constructor(a, b, c, d) { this.a = a; this.b = b; this.c = c; this.d = d; }
            multiply(m) { return new Matrix2(this.a.mul(m.a).add(this.b.mul(m.c)), this.a.mul(m.b).add(this.b.mul(m.d)), this.c.mul(m.a).add(this.d.mul(m.c)), this.c.mul(m.b).add(this.d.mul(m.d))); }
            inverse() {
                const det = this.a.mul(this.d).sub(this.b.mul(this.c));
                if (det.normSq() === 0) return null;
                const invDet = new Complex(1, 0).div(det);
                return new Matrix2(this.d.mul(invDet), this.b.mul(new Complex(-1, 0)).mul(invDet), this.c.mul(new Complex(-1, 0)).mul(invDet), this.a.mul(invDet));
            }
            isIdentity() {
                return Math.abs(this.a.re - 1) < 1e-9 && Math.abs(this.a.im) < 1e-9 &&
                       Math.abs(this.b.re) < 1e-9 && Math.abs(this.b.im) < 1e-9 &&
                       Math.abs(this.c.re) < 1e-9 && Math.abs(this.c.im) < 1e-9 &&
                       Math.abs(this.d.re - 1) < 1e-9 && Math.abs(this.d.im) < 1e-9;
            }
        }

        // --- UI Logic ---
        const generators = [];
        const matrixListContainer = document.getElementById('matrixListContainer');
        const loader = document.getElementById('loader');
        const messageBox = document.getElementById('message-box');

        const panelHeader = document.getElementById('panel-header');
        const panelContentWrapper = document.getElementById('panel-content-wrapper');
        const chevronIcon = document.getElementById('chevron-icon');
        
        panelHeader.addEventListener('click', () => {
            panelContentWrapper.classList.toggle('content-hidden');
            chevronIcon.classList.toggle('rotate-180');
        });

        function showMessage(message, isError = false) {
            messageBox.textContent = message;
            messageBox.className = `mt-4 p-3 text-center text-sm rounded-lg ${isError ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700'}`;
            setTimeout(() => { messageBox.classList.add('hidden'); }, 5000);
        }
        
        function updateMatrixList() {
            matrixListContainer.innerHTML = '';
            generators.forEach((m) => {
                const matrixDiv = document.createElement('div');
                matrixDiv.className = 'matrix-display';
                matrixDiv.textContent = `(${m.a.toString()}, ${m.b.toString()}; ${m.c.toString()}, ${m.d.toString()})`;
                matrixListContainer.appendChild(matrixDiv);
            });
        }

        document.getElementById('addMatrixBtn').addEventListener('click', () => {
            try {
                const a = parseComplex(document.getElementById('a').value);
                const b = parseComplex(document.getElementById('b').value);
                const c = parseComplex(document.getElementById('c').value);
                const d = parseComplex(document.getElementById('d').value);

                const det = a.mul(d).sub(b.mul(c));
                if (Math.abs(det.re - 1) > 1e-4 || Math.abs(det.im) > 1e-4) {
                    showMessage(`Determinant must be 1. Got: ${det.toString()}`, true);
                    return;
                }

                const matrix = new Matrix2(a, b, c, d);
                generators.push(matrix);
                updateMatrixList();
            } catch (e) {
                showMessage(`Error parsing matrix values: ${e.message}`, true);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            generators.length = 0;
            updateMatrixList();
            clearPolyhedron();
            showMessage("Scene reset.", false);
        });

        document.getElementById('generateBtn').addEventListener('click', () => {
            if (generators.length === 0) {
                showMessage("Please add at least one generator matrix.", true);
                return;
            }
            loader.classList.remove('hidden');
            setTimeout(() => {
                generateAndDrawPolyhedron();
                loader.classList.add('hidden');
                showMessage(`Generated polyhedron for word length ${document.getElementById('wordLength').value}.`, false);
            }, 50);
        });

        // --- Hyperbolic Geometry & Drawing ---
        function clearPolyhedron() {
            while(polyhedronGroup.children.length > 0){ 
                const obj = polyhedronGroup.children[0];
                polyhedronGroup.remove(obj); 
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            }
        }
        function generateGroupElements(gens, wordLength) {
            const elements = new Map();
            const initialSet = [...gens];
            gens.forEach(g => {
                const inv = g.inverse();
                if (inv) initialSet.push(inv);
            });

            let queue = [...initialSet];
            const identityKey = "1;0;0;0;0;0;1;0";
            elements.set(identityKey, new Matrix2(new Complex(1,0), new Complex(0,0), new Complex(0,0), new Complex(1,0)));
            
            queue.forEach(g => {
                const key = `${g.a.re};${g.a.im};${g.b.re};${g.b.im};${g.c.re};${g.c.im};${g.d.re};${g.d.im}`;
                elements.set(key, g);
            });

            for (let l = 1; l < wordLength; l++) {
                const nextQueue = [];
                for (const word of queue) {
                    for (const g of initialSet) {
                        const newWord = word.multiply(g);
                        if (newWord.isIdentity()) continue;
                        const key = `${newWord.a.re};${newWord.a.im};${newWord.b.re};${newWord.b.im};${newWord.c.re};${newWord.c.im};${newWord.d.re};${newWord.d.im}`;
                        if (!elements.has(key)) {
                            elements.set(key, newWord);
                            nextQueue.push(newWord);
                        }
                    }
                }
                queue = nextQueue;
            }
            
            elements.delete(identityKey);
            return Array.from(elements.values());
        }
        function generateAndDrawPolyhedron() {
            clearPolyhedron();
            const wordLength = parseInt(document.getElementById('wordLength').value) || 1;
            const groupElements = generateGroupElements(generators, wordLength);

            groupElements.forEach((g, i) => {
                const c = g.c;
                const color = new THREE.Color().setHSL(i / groupElements.length, 0.7, 0.6);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.35,
                    side: THREE.DoubleSide,
                    metalness: 0.2,
                    roughness: 0.6
                });

                if (c.normSq() > 1e-9) {
                    const centerComplex = g.d.mul(new Complex(-1,0)).div(c);
                    const radius = 1.0 / c.abs();
                    const geometry = new THREE.SphereGeometry(radius, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                    const hemisphere = new THREE.Mesh(geometry, material);
                    hemisphere.position.set(centerComplex.re, 0, -centerComplex.im);
                    polyhedronGroup.add(hemisphere);

                } else {
                    const alpha = g.a.div(g.d);
                    const beta = g.b.div(g.d);
                    const alphaAbs = alpha.abs();

                    if (Math.abs(alphaAbs - 1.0) < 1e-9) {
                        const planeGeom = new THREE.PlaneGeometry(20, 20);
                        const planeMesh = new THREE.Mesh(planeGeom, material);
                        const normal = new THREE.Vector3(beta.re, 0, -beta.im).normalize();
                        planeMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), normal);
                        const pos = new THREE.Vector3(beta.re/2, 1, -beta.im/2);
                        planeMesh.position.copy(pos);
                        polyhedronGroup.add(planeMesh);
                    } else {
                        const centerComplex = beta.conjugate().mul(new Complex(-1 / (alphaAbs - 1), 0));
                        const R_sq = (beta.normSq() + Math.pow(alphaAbs, 2) - alphaAbs) / (alphaAbs - 1) + centerComplex.normSq();
                        if (R_sq > 0) {
                            const radius = Math.sqrt(R_sq);
                            const geometry = new THREE.SphereGeometry(radius, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                            const hemisphere = new THREE.Mesh(geometry, material);
                            hemisphere.position.set(centerComplex.re, 0, -centerComplex.im);
                            polyhedronGroup.add(hemisphere);
                        }
                    }
                }
            });
        }

        // --- Init ---
        init();
        (function addDefaultMatrices() {
            const defaults = [
                { a: '1', b: '1', c: '0', d: '1' },
                { a: '1', b: 'i', c: '0', d: '1' },
                { a: '0', b: '-1', c: '1', d: '0' }
            ];
            defaults.forEach(m => {
                document.getElementById('a').value = m.a;
                document.getElementById('b').value = m.b;
                document.getElementById('c').value = m.c;
                document.getElementById('d').value = m.d;
                document.getElementById('addMatrixBtn').click();
            });
            document.getElementById('wordLength').value = 2;
            document.getElementById('generateBtn').click();
            
            panelContentWrapper.classList.add('content-hidden');
            chevronIcon.classList.add('rotate-180');
        })();

    </script>
</body>
</html>
