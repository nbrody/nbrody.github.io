<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brooks-Matelski: Hyperbolic Dynamics & The Mandelbrot Set</title>
  <style>
    body {
      font-family: 'Outfit', -apple-system, sans-serif;
      line-height: 1.6;
      color: #1a1a1a;
      max-width: 1000px;
      margin: 0 auto;
      padding: 40px 20px;
      background: #f8f9fc;
    }

    h1,
    h2,
    h3 {
      color: #1e293b;
      font-weight: 700;
      letter-spacing: -0.02em;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 30px;
      justify-content: center;
      margin: 40px 0;
    }

    canvas,
    #threeContainer {
      background: #ffffff;
      border: 1px solid rgba(0, 0, 0, 0.05);
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05), 0 8px 10px -6px rgba(0, 0, 0, 0.05);
      border-radius: 16px;
      width: 450px;
      height: 450px;
      overflow: hidden;
      transition: transform 0.2s ease;
    }

    .controls {
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      padding: 30px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      flex: 1;
      min-width: 350px;
    }

    .picker-box {
      background: #fff;
      padding: 15px;
      border-radius: 12px;
      border: 1px solid #edf2f7;
      margin-bottom: 20px;
    }

    .input-row {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      align-items: center;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      flex: 1;
    }

    .input-group label {
      font-size: 11px;
      text-transform: uppercase;
      color: #64748b;
      margin-bottom: 4px;
      font-weight: 600;
    }

    input[type="text"],
    input[type="number"] {
      padding: 8px 12px;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      color: #334155;
      transition: all 0.2s;
    }

    input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .label {
      font-weight: 600;
      color: #334155;
      margin-bottom: 8px;
    }

    input[type="range"] {
      width: 100%;
      accent-color: #3b82f6;
    }

    .math-block {
      background: #ffffff;
      padding: 25px;
      border-radius: 16px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      margin: 30px 0;
    }
  </style>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

  <h1>The Dynamics of 2-Generator Subgroups of \( PSL(2,\mathbb{C}) \)</h1>

  <p>In 1978, Robert Brooks and J. Peter Matelski investigated the discreteness of groups generated by two matrices \( X
    \)
    and \( Y \)[cite: 2, 7]. Their work led to a sequence of inequalities generalizing <b>Jørgensen's
      Inequality</b>[cite:
    5, 7].</p>

  ---

  ## 1. The Shimizu-Leutbecher Sequence
  <p>To analyze the discreteness of a group \( \langle X, Y \rangle \), we look at the interaction of their axes.
    We define the initial matrices as:</p>
  <div class="math-block">
    \[ X = \begin{pmatrix} \cosh(\tau/2) & \sinh(\tau/2) \\ \sinh(\tau/2) & \cosh(\tau/2) \end{pmatrix}, \quad
    Y = \begin{pmatrix} e^{\beta/2} & 0 \\ 0 & e^{-\beta/2} \end{pmatrix} \]
  </div>
  <p>The sequence of matrices $Y_i$ is then generated by the recurrence relation \( Y_{i+1} = Y_i X Y_i^{-1} \).</p>

  <div class="container">
    <div>
      <div id="threeContainer"></div>
      <p style="text-align: center;"><b>Hyperbolic Axes of \( Y_i \)</b></p>
    </div>
    <div class="controls">
      <div class="picker-box">
        <span class="label">Parameter Explorer (\( \color{red}{\tau} \), \( \color{blue}{\beta_1} \))</span>
        <canvas id="complexPicker" width="300" height="300"
          style="border:1px solid #e2e8f0; background:#fff; cursor:crosshair; width: 100%; aspect-ratio: 1; border-radius: 8px; margin: 15px 0;"></canvas>

        <div class="input-row">
          <div class="input-group">
            <label>τ Re</label>
            <input type="number" id="tauRe" value="0.80" step="0.01">
          </div>
          <div class="input-group">
            <label>τ Im</label>
            <input type="number" id="tauIm" value="0.00" step="0.01">
          </div>
        </div>

        <div class="input-row">
          <div class="input-group">
            <label>β Re</label>
            <input type="number" id="betaRe" value="1.20" step="0.01">
          </div>
          <div class="input-group">
            <label>β Im</label>
            <input type="number" id="betaIm" value="0.00" step="0.01">
          </div>
        </div>
      </div>

      <span class="label" style="margin-top:20px;">Iterations:</span>
      <input type="range" id="iterRange" min="1" max="15" step="1" value="5">

      <p><small>The blue line is the axis of \( X \). The red/orange lines are the axes of the generated \( Y_i \)
          sequence. In the 3D Upper Half-Space model, geodesics are vertical lines or semi-circles orthogonal to the
          boundary plane \( y=0 \). If they "pile up," the group is not discrete.</small></p>

      <div class="control-group" style="display:flex; align-items:center; gap:20px; margin-top: 10px; flex-wrap: wrap;">
        <div style="display:flex; align-items:center; gap:5px;">
          <input type="checkbox" id="showLabels" checked>
          <label style="margin:0;">Show Axis Labels</label>
        </div>
        <div style="display:flex; align-items:center; gap:5px;">
          <input type="checkbox" id="showOrbit" checked>
          <label style="margin:0;">Show Beta Orbit</label>
        </div>
        <div style="display:flex; align-items:center; gap:10px;">
          <input type="checkbox" id="showHeatmap">
          <label style="margin:0;">Stability Heatmap (n=</label>
          <input type="number" id="heatmapIter" value="7" min="1" max="25" style="width: 40px;">
          <label style="margin:0;">)</label>
        </div>
      </div>
    </div>
  </div>

  ---

  ## 2. The Lemma: Geometric to Algebraic
  <p>Brooks and Matelski proved that the distance \( \cosh(\beta_i) \) evolves according to a specific lemma:</p>
  <div class="math-block">
    \[ \cosh(\beta_{i+1}) = (1 - \cosh(\tau)) \cosh^2(\beta_i) + \cosh(\tau) \]
  </div>
  <p>This follows from the <b>Hyperbolic Law of Cosines</b>. By setting \( z_i = (1 - \cosh(\tau)) \cosh(\beta_i) \),
    the
    formula transforms into the classic quadratic map \( z_{i+1} = z_i^2 + C \)[cite: 40, 41].</p>

  ---

  ## 3. The Mandelbrot Set (Fig. 2)
  <p>Brooks and Matelski used computers to find the region of \( C \) values where the sequence \( z^2 + C \) has a
    <b>stable
      periodic orbit</b>[cite: 51]. Their "Figure 2" was the first published image of what we now call the Mandelbrot
    Set.
  </p>

  <div class="container">
    <div>
      <canvas id="mandelCanvas" width="400" height="400"></canvas>
      <p style="text-align: center;"><b>The Stability Region of \( C \) (Fig. 2)</b></p>
    </div>
    <div class="controls">
      <p>This visualization calculates the stability for \( f(z) = z^2 + C \)[cite: 41, 48].</p>
      <ul>
        <li><b>Black:</b> Stable (Not Discrete) [cite: 48, 72]</li>
        <li><b>White:</b> Unstable / Escaping</li>
      </ul>
      <p>In the paper, if \( C \) falls into a stable orbit, the sequence \( \{z_i\} \) cannot be discrete, and thus the
        group
        \( \langle X, Y \rangle \) is not discrete[cite: 43, 72, 80].</p>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.145.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.145.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // --- Complex Math & PSL(2,C) ---
    class Complex {
      constructor(re, im = 0) { this.re = re; this.im = im; }
      add(c) { return new Complex(this.re + c.re, this.im + c.im); }
      sub(c) { return new Complex(this.re - c.re, this.im - c.im); }
      mul(c) {
        if (typeof c === 'number') return new Complex(this.re * c, this.im * c);
        return new Complex(this.re * c.re - this.im * c.im, this.re * c.im + this.im * c.re);
      }
      div(c) {
        let den = c.re * c.re + c.im * c.im;
        return new Complex((this.re * c.re + this.im * c.im) / den, (this.im * c.re - this.re * c.im) / den);
      }
      sqrt() {
        let r = Math.sqrt(this.re * this.re + this.im * this.im);
        let re = Math.sqrt((r + this.re) / 2);
        let im = Math.sqrt((r - this.re) / 2) * (this.im < 0 ? -1 : 1);
        return new Complex(re, im);
      }
      exp() {
        let r = Math.exp(this.re);
        return new Complex(r * Math.cos(this.im), r * Math.sin(this.im));
      }
      static cosh(z) {
        let ez = z.exp();
        let emz = new Complex(-z.re, -z.im).exp();
        return ez.add(emz).mul(0.5);
      }
      static sinh(z) {
        let ez = z.exp();
        let emz = new Complex(-z.re, -z.im).exp();
        return ez.sub(emz).mul(0.5);
      }
      log() {
        return new Complex(Math.log(Math.sqrt(this.re * this.re + this.im * this.im)), Math.atan2(this.im, this.re));
      }
      static acosh(z) {
        // acosh(z) = log(z + sqrt(z^2 - 1))
        let z2 = z.mul(z);
        let s = z2.sub(new Complex(1)).sqrt();
        return z.add(s).log();
      }
    }

    class Matrix2x2 {
      constructor(a, b, c, d) { this.a = a; this.b = b; this.c = c; this.d = d; }
      mul(m) {
        return new Matrix2x2(
          this.a.mul(m.a).add(this.b.mul(m.c)), this.a.mul(m.b).add(this.b.mul(m.d)),
          this.c.mul(m.a).add(this.d.mul(m.c)), this.c.mul(m.b).add(this.d.mul(m.d))
        );
      }
      inv() {
        let det = this.a.mul(this.d).sub(this.b.mul(this.c));
        return new Matrix2x2(this.d.div(det), this.b.mul(-1).div(det), this.c.mul(-1).div(det), this.a.div(det));
      }
      getFixedPoints() {
        let a = this.c, b = this.d.sub(this.a), c = this.b.mul(-1);
        if (Math.abs(a.re) < 1e-6 && Math.abs(a.im) < 1e-6) {
          // Linear: (d-a)z - b = 0 => z = b/(d-a)
          return [this.b.div(this.d.sub(this.a)), null];
        }
        let disc = b.mul(b).sub(a.mul(c).mul(4)).sqrt();
        return [
          b.mul(-1).add(disc).div(a.mul(2)),
          b.mul(-1).sub(disc).div(a.mul(2))
        ];
      }
    }

    // --- Three.js Setup ---
    const container = document.getElementById('threeContainer');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf1f5f9);
    scene.fog = new THREE.Fog(0xf1f5f9, 20, 100);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 5000);
    camera.position.set(20, 15, 20);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(450, 450);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Boundary Plane (Complex Plane)
    const grid = new THREE.GridHelper(100, 50, 0xaaaaaa, 0xcccccc);
    grid.position.y = 0;
    scene.add(grid);

    const boundaryPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshPhongMaterial({ color: 0x99ccff, transparent: true, opacity: 0.1, side: THREE.DoubleSide })
    );
    boundaryPlane.rotation.x = Math.PI / 2;
    scene.add(boundaryPlane);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const pointLight = new THREE.PointLight(0xffffff, 1.2);
    pointLight.position.set(20, 20, 20);
    scene.add(pointLight);

    const axesGroup = new THREE.Group();
    scene.add(axesGroup);
    const labelsGroup = new THREE.Group();
    scene.add(labelsGroup);

    function complexToVector3(c, height = 0) {
      if (!c) return new THREE.Vector3(0, 10, 0); // Visual proxy for infinity
      return new THREE.Vector3(c.re, height, c.im);
    }

    function createTextLabel(text, pos, color) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      // Replace roundRect with manual path for better compatibility
      const r = 8;
      ctx.beginPath();
      ctx.moveTo(r, 0);
      ctx.lineTo(256 - r, 0); ctx.quadraticCurveTo(256, 0, 256, r);
      ctx.lineTo(256, 64 - r); ctx.quadraticCurveTo(256, 64, 256 - r, 64);
      ctx.lineTo(r, 64); ctx.quadraticCurveTo(0, 64, 0, 64 - r);
      ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0);
      ctx.closePath();
      ctx.fill();

      ctx.font = 'bold 32px sans-serif';
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, 128, 32);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(spriteMat);
      sprite.position.copy(pos);
      sprite.scale.set(1.5, 0.375, 1);
      return sprite;
    }

    function drawGeodesic(p1, p2, color, width) {
      const steps = 60;
      const points = [];

      if (!p1 || !p2) {
        // One point is infinity: Vertical Line
        const finite = p1 || p2;
        const v = complexToVector3(finite, 0);
        for (let i = 0; i <= steps; i++) {
          points.push(new THREE.Vector3(v.x, i * 2, v.z)); // Vertical ray
        }
      } else {
        // Both finite: Semi-circle
        // Euclidean distance between points
        const d = Math.sqrt(Math.pow(p1.re - p2.re, 2) + Math.pow(p1.im - p2.im, 2));
        if (d < 1e-6) return; // Same point

        const radius = d / 2;
        const centerRe = (p1.re + p2.re) / 2;
        const centerIm = (p1.im + p2.im) / 2;

        // Angle in horizontal plane
        const angleHorizontal = Math.atan2(p2.im - centerIm, p2.re - centerRe);

        for (let i = 0; i <= steps; i++) {
          const theta = i / steps * Math.PI; // 0 to PI
          // Parametric semi-circle in UHP
          const r = radius * Math.cos(theta); // Horizontal distance from center
          const h = radius * Math.sin(theta); // Height

          points.push(new THREE.Vector3(
            centerRe + r * Math.cos(angleHorizontal),
            h,
            centerIm + r * Math.sin(angleHorizontal)
          ));
        }
      }

      const geom = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.LineBasicMaterial({ color: color, linewidth: width });
      axesGroup.add(new THREE.Line(geom, mat));
    }

    const iterInput = document.getElementById('iterRange');
    const complexPicker = document.getElementById('complexPicker');

    const tauReInput = document.getElementById('tauRe');
    const tauImInput = document.getElementById('tauIm');
    const betaReInput = document.getElementById('betaRe');
    const betaImInput = document.getElementById('betaIm');

    let tauVal = new Complex(0.8, 0);
    let betaVal = new Complex(1.2, 0);

    function syncInputs() {
      tauReInput.value = tauVal.re.toFixed(2);
      tauImInput.value = tauVal.im.toFixed(2);
      betaReInput.value = betaVal.re.toFixed(2);
      betaImInput.value = betaVal.im.toFixed(2);
    }

    [tauReInput, tauImInput, betaReInput, betaImInput].forEach(inp => {
      inp.addEventListener('input', () => {
        tauVal = new Complex(parseFloat(tauReInput.value) || 0, parseFloat(tauImInput.value) || 0);
        betaVal = new Complex(parseFloat(betaReInput.value) || 0, parseFloat(betaImInput.value) || 0);
        if (window.refreshPicker) window.refreshPicker();
        updateHyperbolic();
      });
    });

    function initUnifiedPicker() {
      const ctx = complexPicker.getContext('2d');
      const w = complexPicker.width, h = complexPicker.height;
      let activePoint = null;
      let viewportCenter = new Complex(0, 0);
      let viewportRange = 4.0; // Total width/height in complex units

      function toScreen(c) {
        return {
          x: ((c.re - viewportCenter.re) / viewportRange) * w + w / 2,
          y: -((c.im - viewportCenter.im) / viewportRange) * h + h / 2
        };
      }

      function fromScreen(x, y) {
        return new Complex(
          ((x - w / 2) / w) * viewportRange + viewportCenter.re,
          -((y - h / 2) / h) * viewportRange + viewportCenter.im
        );
      }

      function draw() {
        ctx.clearRect(0, 0, w, h);

        // Heatmap
        if (document.getElementById('showHeatmap').checked) {
          const n = parseInt(document.getElementById('heatmapIter').value) || 7;
          const imgData = ctx.createImageData(w, h);
          const cTau = Complex.cosh(tauVal);
          const factor = new Complex(1).sub(cTau);

          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              let b0 = fromScreen(x, y);
              let current = b0;
              for (let i = 0; i < n; i++) {
                let cb = Complex.cosh(current);
                current = Complex.acosh(factor.mul(cb.mul(cb)).add(cTau));
                if (current.re < 0) current = current.mul(-1);
                if (Math.abs(current.re) > 10 || Math.abs(current.im) > 10) break;
              }
              const mag = Math.sqrt(current.re * current.re + current.im * current.im);
              const idx = (y * w + x) * 4;
              const intensity = Math.min(255, Math.log10(mag + 1) * 120);
              imgData.data[idx] = intensity;
              imgData.data[idx + 1] = 255 - intensity * 0.5;
              imgData.data[idx + 2] = 255 - intensity;
              imgData.data[idx + 3] = 40;
            }
          }
          ctx.putImageData(imgData, 0, 0);
        }

        // Grid
        ctx.strokeStyle = '#eee';
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Dynamic Grid based on range
        const step = Math.pow(10, Math.floor(Math.log10(viewportRange)) - 1);
        const startRe = Math.floor((viewportCenter.re - viewportRange / 2) / step) * step;
        const endRe = Math.ceil((viewportCenter.re + viewportRange / 2) / step) * step;
        for (let r = startRe; r <= endRe; r += step) {
          const p = toScreen(new Complex(r, 0));
          ctx.moveTo(p.x, 0); ctx.lineTo(p.x, h);
        }
        const startIm = Math.floor((viewportCenter.im - viewportRange / 2) / step) * step;
        const endIm = Math.ceil((viewportCenter.im + viewportRange / 2) / step) * step;
        for (let i = startIm; i <= endIm; i += step) {
          const p = toScreen(new Complex(0, i));
          ctx.moveTo(0, p.y); ctx.lineTo(w, p.y);
        }
        ctx.stroke();

        // Origin Axes
        ctx.strokeStyle = '#ccc';
        const origin = toScreen(new Complex(0, 0));
        ctx.beginPath();
        ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, h);
        ctx.moveTo(0, origin.y); ctx.lineTo(w, origin.y);
        ctx.stroke();

        // Tau (Red)
        const sTau = toScreen(tauVal);
        if (sTau.x >= 0 && sTau.x <= w && sTau.y >= 0 && sTau.y <= h) {
          ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(255,0,0,0.5)';
          ctx.fillStyle = 'red';
          ctx.beginPath(); ctx.arc(sTau.x, sTau.y, 7, 0, Math.PI * 2); ctx.fill();
          ctx.shadowBlur = 0;
          ctx.font = 'bold 16px sans-serif';
          ctx.fillText('τ', sTau.x + 12, sTau.y + 4);
        }

        const sBeta = toScreen(betaVal);
        if (sBeta.x >= 0 && sBeta.x <= w && sBeta.y >= 0 && sBeta.y <= h) {
          ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(0,0,255,0.5)';
          ctx.fillStyle = 'blue';
          ctx.beginPath(); ctx.arc(sBeta.x, sBeta.y, 7, 0, Math.PI * 2); ctx.fill();
          ctx.shadowBlur = 0;
          ctx.fillText('β', sBeta.x + 12, sBeta.y + 4);
        }

        syncInputs();

        // Draw Beta Orbit
        if (document.getElementById('showOrbit').checked) {
          const iters = parseInt(iterInput.value);
          let currentBeta = betaVal;
          let orbitPoints = [toScreen(currentBeta)];

          let cTau = Complex.cosh(tauVal);
          let factor = new Complex(1).sub(cTau);

          for (let i = 0; i < iters; i++) {
            let cb = Complex.cosh(currentBeta);
            let nextCB = factor.mul(cb.mul(cb)).add(cTau);
            currentBeta = Complex.acosh(nextCB);
            // We want the branch with positive real part usually
            if (currentBeta.re < 0) currentBeta = currentBeta.mul(-1);
            orbitPoints.push(toScreen(currentBeta));
          }


          ctx.strokeStyle = 'rgba(0, 0, 255, 0.3)';
          ctx.setLineDash([2, 4]);
          ctx.beginPath();
          ctx.moveTo(orbitPoints[0].x, orbitPoints[0].y);
          for (let i = 1; i < orbitPoints.length; i++) {
            ctx.lineTo(orbitPoints[i].x, orbitPoints[i].y);
          }
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
          for (let i = 1; i < orbitPoints.length; i++) {
            ctx.beginPath();
            ctx.arc(orbitPoints[i].x, orbitPoints[i].y, 3, 0, Math.PI * 2);
            ctx.fill();
            if (i < 4) { // Only label first few to avoid clutter
              ctx.fillText(`β${i + 1}`, orbitPoints[i].x + 8, orbitPoints[i].y);
            }
          }
        }
      }

      function handleMove(e) {
        const rect = complexPicker.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (w / rect.width);
        const y = (e.clientY - rect.top) * (h / rect.height);

        if (activePoint === 'tau') tauVal = fromScreen(x, y);
        if (activePoint === 'beta') betaVal = fromScreen(x, y);

        draw();
        updateHyperbolic();
      }

      // Add draw to window so updateHyperbolic can trigger picker refresh
      window.refreshPicker = draw;

      complexPicker.addEventListener('mousedown', (e) => {
        const rect = complexPicker.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (w / rect.width);
        const y = (e.clientY - rect.top) * (h / rect.height);

        if (e.button === 2) { // Right click to pan
          let lastX = e.clientX, lastY = e.clientY;
          const onPan = (pe) => {
            const dx = pe.clientX - lastX;
            const dy = pe.clientY - lastY;
            viewportCenter.re -= (dx / rect.width) * viewportRange;
            viewportCenter.im += (dy / rect.height) * viewportRange;
            lastX = pe.clientX; lastY = pe.clientY;
            draw();
            updateHyperbolic();
          };
          window.addEventListener('mousemove', onPan);
          window.addEventListener('mouseup', () => window.removeEventListener('mousemove', onPan), { once: true });
          return;
        }

        const sTau = toScreen(tauVal);
        const sBeta = toScreen(betaVal);

        const dTau = Math.hypot(x - sTau.x, y - sTau.y);
        const dBeta = Math.hypot(x - sBeta.x, y - sBeta.y);

        if (dTau < 15) activePoint = 'tau';
        else if (dBeta < 15) activePoint = 'beta';
        else activePoint = null;

        if (activePoint) {
          const onMove = (me) => handleMove(me);
          const onUp = () => {
            window.removeEventListener('mousemove', onMove);
            window.removeEventListener('mouseup', onUp);
            activePoint = null;
          };
          window.addEventListener('mousemove', onMove);
          window.addEventListener('mouseup', onUp);
          handleMove(e);
        }
      });

      // Prevent context menu on right click for panning
      complexPicker.addEventListener('contextmenu', e => e.preventDefault());

      complexPicker.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = complexPicker.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * (w / rect.width);
        const mouseY = (e.clientY - rect.top) * (h / rect.height);
        const beforeZoom = fromScreen(mouseX, mouseY);

        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        viewportRange *= zoomFactor;

        const afterZoom = fromScreen(mouseX, mouseY);
        viewportCenter.re += (beforeZoom.re - afterZoom.re);
        viewportCenter.im += (beforeZoom.im - afterZoom.im);

        draw();
        updateHyperbolic();
      });

      draw();
    }

    initUnifiedPicker();

    function updateHyperbolic() {
      axesGroup.clear();
      let iters = parseInt(iterInput.value);

      const showLabels = document.getElementById('showLabels').checked;
      labelsGroup.visible = showLabels;
      labelsGroup.clear();

      // --- Brooks-Matelski Generator Definitions ---
      // X: Fixed points at -1 and 1
      // We use the complex tauVal
      let t2 = tauVal.mul(0.5);
      let ch = Complex.cosh(t2), sh = Complex.sinh(t2);
      let X = new Matrix2x2(ch, sh, sh, ch);

      // Y: Fixed points at 0 and Infinity
      // We use the complex betaVal
      let b2 = betaVal.mul(0.5);
      let expB = b2.exp();
      let Y = new Matrix2x2(expB, new Complex(0), new Complex(0), new Complex(1).div(expB));

      // Draw X Axis (Semi-circle between -1 and 1)
      drawGeodesic(new Complex(-1), new Complex(1), 0x0000ff, 3);
      labelsGroup.add(createTextLabel('X', new THREE.Vector3(0, 1.2, 0), '#0000ff'));

      let Yi = Y;
      for (let i = 0; i < iters; i++) {
        let fps = Yi.getFixedPoints();
        let colorHex = new THREE.Color().setHSL(0.05 + i * 0.05, 0.9, 0.5);

        drawGeodesic(fps[0], fps[1], colorHex, 2);

        // Label the axis
        let labelName = i === 0 ? 'Y' : `Y${i}`;
        if (fps[1] === null) {
          labelsGroup.add(createTextLabel(labelName, new THREE.Vector3(fps[0].re, 2 + i, fps[0].im), colorHex.getStyle()));
        } else {
          let mid = fps[0].add(fps[1]).mul(0.5);
          let dist = Math.sqrt(Math.pow(fps[0].re - fps[1].re, 2) + Math.pow(fps[0].im - fps[1].im, 2)) / 2;
          labelsGroup.add(createTextLabel(labelName, complexToVector3(mid, dist + 0.2), colorHex.getStyle()));
        }

        // Compute next Y: Y_{i+1} = Y_i X Y_i^-1
        Yi = Yi.mul(X).mul(Yi.inv());
      }

    }

    [iterInput].forEach(el => el.addEventListener('input', updateHyperbolic));
    document.getElementById('showLabels').addEventListener('change', updateHyperbolic);
    document.getElementById('showOrbit').addEventListener('change', () => { if (window.refreshPicker) window.refreshPicker(); });
    document.getElementById('showHeatmap').addEventListener('change', () => { if (window.refreshPicker) window.refreshPicker(); });
    document.getElementById('heatmapIter').addEventListener('input', () => { if (window.refreshPicker) window.refreshPicker(); });

    updateHyperbolic();
    if (window.refreshPicker) window.refreshPicker();
    const mCanvas = document.getElementById('mandelCanvas');
    const mCtx = mCanvas.getContext('2d');

    function drawMandelbrot() {
      const dpr = window.devicePixelRatio || 1;
      const w = 400 * dpr, h = 400 * dpr;
      mCanvas.width = w; mCanvas.height = h;
      mCanvas.style.width = '400px'; mCanvas.style.height = '400px';

      const imgData = mCtx.createImageData(w, h);
      const maxIter = 250;

      for (let py = 0; py < h; py++) {
        for (let px = 0; px < w; px++) {
          let cr = (px / w) * 2.5 - 2.0;
          let ci = (py / h) * 2.4 - 1.2;

          let zr = 0, zi = 0, iter = 0;
          while (zr * zr + zi * zi < 16 && iter < maxIter) {
            let temp = zr * zr - zi * zi + cr;
            zi = 2 * zr * zi + ci;
            zr = temp;
            iter++;
          }

          let pix = (py * w + px) * 4;
          if (iter === maxIter) {
            // Interior (The Mandelbrot Set)
            imgData.data[pix] = 20;
            imgData.data[pix + 1] = 20;
            imgData.data[pix + 2] = 30;
          } else {
            // Exterior with smooth coloring
            let log_zn = Math.log(zr * zr + zi * zi) / 2;
            let nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
            let smoothIter = iter + 1 - nu;

            // Generate a nice gradient
            let hue = (smoothIter * 5) % 360;
            let [r, g, b] = hslToRgb(hue / 360, 0.7, 0.4 + (iter / maxIter) * 0.4);

            imgData.data[pix] = r;
            imgData.data[pix + 1] = g;
            imgData.data[pix + 2] = b;
          }
          imgData.data[pix + 3] = 255;
        }
      }
      mCtx.putImageData(imgData, 0, 0);
    }

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const huetorgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = huetorgb(p, q, h + 1 / 3);
        g = huetorgb(p, q, h);
        b = huetorgb(p, q, h - 1 / 3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    drawMandelbrot();
    animate();
  </script>

</body>

</html>