<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Three.js Rube Goldberg Machine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
        }

        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
        }

        button {
            pointer-events: auto;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            background: #ff4757;
            border: none;
            color: white;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div id="info">
        Rube Goldberg Prototype<br>
        <button onclick="window.location.reload()">Reset Machine</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, world;
        let objectsToUpdate = []; // Array to store {mesh, body} pairs
        let kinematicObjects = []; // Array to store objects with custom logic
        let audioCtx;
        const notes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25]; // C4 to C5

        init();
        animate();

        function init() {
            // 1. SETUP SCENE
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(15, 12, 15);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 2. SETUP PHYSICS WORLD
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            // Default material interactions
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.3,
                restitution: 0.5 // Bounciness
            });
            world.addContactMaterial(defaultContactMaterial);

            // 3. BUILD THE MACHINE
            buildStage();

            // 4. AUDIO SETUP (Must be triggered by interaction ideally, but we'll try to resume on click)
            window.addEventListener('mousedown', () => {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } else if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            });

            // Resize listener
            window.addEventListener('resize', onWindowResize);
        }

        // --- AUDIO HELPERS ---
        function playNote(freq) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        // --- HELPER FUNCTIONS FOR OBJECTS ---

        function createCylinder(radiusTop, radiusBottom, height, position, mass, color, rotation = { x: 0, y: 0, z: 0 }) {
            const geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 32);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Cylinder(radiusTop, radiusBottom, height, 32);
            // Cannon cylinders are along the Y axis by default
            const body = new CANNON.Body({
                mass: mass,
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: shape
            });

            const q = new CANNON.Quaternion();
            q.setFromEuler(rotation.x, rotation.y, rotation.z);
            body.quaternion = q;
            mesh.quaternion.copy(body.quaternion);

            world.addBody(body);
            if (mass > 0) objectsToUpdate.push({ mesh, body });
        }

        function createChainLift(x, y, z, height, numHooks, speed) {
            const chainGroup = new THREE.Group();
            scene.add(chainGroup);

            const hooks = [];
            const spacing = (height * 2) / numHooks;

            for (let i = 0; i < numHooks; i++) {
                const hookGroup = new THREE.Group();
                chainGroup.add(hookGroup);

                // Visual base
                const baseGeo = new THREE.BoxGeometry(1.5, 0.2, 2);
                const baseMat = new THREE.MeshStandardMaterial({ color: 0x4b7cf3 });
                const baseMesh = new THREE.Mesh(baseGeo, baseMat);
                hookGroup.add(baseMesh);

                // Visual lip
                const lipGeo = new THREE.BoxGeometry(0.2, 0.8, 2);
                const lipMesh = new THREE.Mesh(lipGeo, baseMat);
                lipMesh.position.set(0.75, 0.4, 0);
                hookGroup.add(lipMesh);

                const body = new CANNON.Body({
                    mass: 0,
                    type: CANNON.Body.KINEMATIC,
                    position: new CANNON.Vec3(x, y, z)
                });

                const baseShape = new CANNON.Box(new CANNON.Vec3(0.75, 0.1, 1));
                const lipShape = new CANNON.Box(new CANNON.Vec3(0.1, 0.4, 1));
                body.addShape(baseShape);
                body.addShape(lipShape, new CANNON.Vec3(0.75, 0.4, 0));

                world.addBody(body);

                // Track progress along the loop (0 to 1)
                const progress = i / numHooks;
                hooks.push({ mesh: hookGroup, body: body, progress: progress });
            }

            kinematicObjects.push({
                type: 'chainLift',
                hooks: hooks,
                centerX: x,
                height: height,
                speed: speed
            });
        }

        function createPendulumSwitcher(x, y, z) {
            const pillarGeo = new THREE.CylinderGeometry(0.1, 0.1, 4);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x57606f });
            const pillar = new THREE.Mesh(pillarGeo, pillarMat);
            pillar.position.set(x, y + 2, z);
            scene.add(pillar);

            const gateGeo = new THREE.BoxGeometry(4, 0.4, 0.4);
            const gateMat = new THREE.MeshStandardMaterial({ color: 0xff4757 });
            const gateMesh = new THREE.Mesh(gateGeo, gateMat);
            scene.add(gateMesh);

            const body = new CANNON.Body({
                mass: 1,
                position: new CANNON.Vec3(x, y + 2, z)
            });
            body.addShape(new CANNON.Box(new CANNON.Vec3(2, 0.2, 0.2)));

            // Fixed anchor body for the pendulum
            const anchor = new CANNON.Body({ mass: 0 });
            anchor.position.set(x, y + 2, z);

            // Constraint to keep it as a pendulum
            const pivot = new CANNON.PointToPointConstraint(
                body, new CANNON.Vec3(0, 0, 0),
                anchor, new CANNON.Vec3(0, 0, 0)
            );
            world.addConstraint(pivot);
            world.addBody(body);

            objectsToUpdate.push({ mesh: gateMesh, body: body });
        }

        function createMusicalBlock(position, color, noteIndex) {
            const width = 2.0, height = 0.6, depth = 3;
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const body = new CANNON.Body({
                mass: 0,
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2))
            });

            body.addEventListener('collide', (e) => {
                if (e.contact.getImpactVelocityAlongNormal() > 0.8) {
                    playNote(notes[noteIndex % notes.length]);
                    // Visual feedback: brief emissive flash
                    mesh.material.emissive.set(0x444444);
                    setTimeout(() => mesh.material.emissive.set(0x000000), 150);
                }
            });

            world.addBody(body);
        }

        function createBox(width, height, depth, position, mass, color, rotation = { x: 0, y: 0, z: 0 }) {
            // Three.js Mesh
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js Body
            const shape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
            const body = new CANNON.Body({
                mass: mass,
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: shape
            });

            // Apply rotation
            const quaternion = new CANNON.Quaternion();
            quaternion.setFromEuler(rotation.x, rotation.y, rotation.z);
            body.quaternion = quaternion;
            mesh.quaternion.copy(body.quaternion);

            world.addBody(body);

            // Store for syncing
            if (mass > 0) {
                objectsToUpdate.push({ mesh, body });
            }
        }

        function createSphere(radius, position, mass, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({
                mass: mass,
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: shape
            });
            world.addBody(body);

            if (mass > 0) {
                objectsToUpdate.push({ mesh, body });
            }
        }

        // --- BUILDING THE STAGES ---

        function buildStage() {
            // Ground
            createBox(100, 0.5, 100, { x: 0, y: -0.25, z: 0 }, 0, 0x1e272e);

            // --- THE CHAIN LIFT (Centerpiece) ---
            // Lifting marbles from y=2 to y=18
            const liftX = 20;
            createChainLift(liftX, 8, 0, 10, 16, 0.004);

            // --- TOP EXIT FROM LIFT ---
            createBox(6, 0.2, 5, { x: liftX, y: 18.5, z: 0 }, 0, 0x27ae60, { x: 0, y: 0, z: 0.15 });

            // Bridge to the Musical Section
            createBox(20, 0.2, 3, { x: 8, y: 17, z: 0 }, 0, 0x0fbcf9, { x: 0, y: 0, z: 0.1 });

            // --- THE MUSICAL XYLOPHONE ---
            const xyColors = [0xff5e57, 0xffa44b, 0xffdd59, 0x05c46b, 0x0fbcf9, 0x575fcf, 0xef5777, 0xf53b57];
            const startX = -5;
            for (let i = 0; i < 8; i++) {
                createMusicalBlock({ x: startX + i * 1.5, y: 14 - i * 1.0, z: 0 }, xyColors[i], i);
            }

            // --- SWITCHER TRANSITION ---
            // Funnel path to switcher
            createBox(6, 0.2, 4, { x: 8, y: 6.5, z: 0 }, 0, 0x808e9b, { x: 0, y: 0, z: 0.1 });
            createPendulumSwitcher(12, 4.5, 0);

            // --- BRANCHING PATHS ---
            // Path A: Spirals forward
            createBox(12, 0.2, 3, { x: 18, y: 2.5, z: 5 }, 0, 0xffdd59, { x: 0.2, y: 0, z: 0.1 });
            // Path B: Spirals backward
            createBox(12, 0.2, 3, { x: 18, y: 2.5, z: -5 }, 0, 0xffa44b, { x: -0.2, y: 0, z: 0.1 });

            // --- COLLECTION LAKE ---
            // Both paths lead back to this large basin at the foot of the lift
            createBox(14, 0.2, 16, { x: 20, y: 1, z: 0 }, 0, 0x34495e, { x: 0, y: 0, z: -0.15 });

            // Guides for the collection area to feed into the chain
            createBox(5, 0.2, 2.5, { x: 23, y: 0.5, z: 0 }, 0, 0x34495e, { x: 0, y: 0, z: -0.1 });

            // --- THE MARBLES (Perpetual actors) ---
            const marbleColors = [0xffffff, 0xff4757, 0x2ed573, 0x1e90ff, 0xffa502];
            for (let i = 0; i < 6; i++) {
                createSphere(0.4, { x: 15 + i * 1.5, y: 5 + i, z: (Math.random() - 0.5) * 6 }, 1, marbleColors[i % marbleColors.length]);
            }
        }

        // --- ANIMATION LOOP ---

        function animate() {
            requestAnimationFrame(animate);

            // Step the physics world
            world.step(1 / 60);

            // Update kinematic objects
            kinematicObjects.forEach(obj => {
                if (obj.type === 'chainLift') {
                    obj.hooks.forEach(hook => {
                        // Offset progress calculation for lift cycle
                        hook.progress = (hook.progress + obj.speed) % 1;

                        // Vertical racetrack loop
                        const rx = 1.6; // Half-width
                        const ry = obj.height; // Half-height
                        let tx, ty;

                        if (hook.progress < 0.4) { // Moving UP
                            tx = rx;
                            ty = (hook.progress / 0.4) * (ry * 2) - ry;
                        } else if (hook.progress < 0.5) { // Rounding TOP
                            const localP = (hook.progress - 0.4) / 0.1;
                            const angle = localP * Math.PI;
                            tx = Math.cos(angle) * rx;
                            ty = ry + Math.sin(angle) * 0.8;
                        } else if (hook.progress < 0.9) { // Moving DOWN
                            tx = -rx;
                            ty = ry - ((hook.progress - 0.5) / 0.4) * (ry * 2);
                        } else { // Rounding BOTTOM
                            const localP = (hook.progress - 0.9) / 0.1;
                            const angle = Math.PI + localP * Math.PI;
                            tx = Math.cos(angle) * rx;
                            ty = -ry + Math.sin(angle) * 0.8;
                        }

                        hook.body.position.set(obj.centerX + tx, ty + ry + 2, 0);
                        hook.mesh.position.copy(hook.body.position);
                        hook.mesh.quaternion.copy(hook.body.quaternion);
                    });
                } else if (obj.rotationSpeed) {
                    const rotationDelta = obj.rotationSpeed * (1 / 60);
                    const q = new CANNON.Quaternion();
                    q.setFromEuler(0, 0, rotationDelta);
                    obj.body.quaternion.mult(q, obj.body.quaternion);
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                }
            });

            // Sync Three.js meshes and handle marble respawns
            objectsToUpdate.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);

                // If a marble falls off the world, respawn it in the collection basin
                if (obj.body.position.y < -10) {
                    obj.body.position.set(15, 5, (Math.random() - 0.5) * 6);
                    obj.body.velocity.set(0, 0, 0);
                    obj.body.angularVelocity.set(0, 0, 0);
                }
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>