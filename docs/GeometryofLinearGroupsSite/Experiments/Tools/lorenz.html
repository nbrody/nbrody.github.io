<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorenz Attractor</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        
        #canvas {
            display: block;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls h3 {
            margin-top: 0;
            color: #fff;
            font-size: 18px;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        
        .control-group input[type="range"] {
            width: 200px;
            height: 5px;
            background: #333;
            outline: none;
            border-radius: 3px;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            width: 15px;
            height: 15px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
        }
        
        .value {
            display: inline-block;
            width: 50px;
            color: #4CAF50;
            font-weight: bold;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #aaa;
            font-size: 12px;
            text-align: right;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <h3>Lorenz Attractor</h3>
        
        <div class="control-group">
            <label>σ (Sigma): <span class="value" id="sigmaValue">10.0</span></label>
            <input type="range" id="sigma" min="0" max="30" value="10" step="0.1">
        </div>
        
        <div class="control-group">
            <label>ρ (Rho): <span class="value" id="rhoValue">28.0</span></label>
            <input type="range" id="rho" min="0" max="50" value="28" step="0.1">
        </div>
        
        <div class="control-group">
            <label>β (Beta): <span class="value" id="betaValue">2.67</span></label>
            <input type="range" id="beta" min="0" max="10" value="2.667" step="0.01">
        </div>
        
        <div class="control-group">
            <label>Speed: <span class="value" id="speedValue">1.0</span></label>
            <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
        </div>
        
        <button id="resetBtn">Reset</button>
        <button id="clearBtn">Clear Trail</button>
    </div>
    
    <div class="info">
        Drag to rotate • Scroll to zoom
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 50, 150);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 30, 50);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('canvas'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(50, 50, 50);
        scene.add(pointLight);
        
        // Lorenz parameters
        let sigma = 10;
        let rho = 28;
        let beta = 8/3;
        let dt = 0.01;
        let speedMultiplier = 1;
        
        // Starting position
        let x = 0.1;
        let y = 0;
        let z = 0;
        
        // Trail
        const MAX_POINTS = 10000;
        const positions = new Float32Array(MAX_POINTS * 3);
        const colors = new Float32Array(MAX_POINTS * 3);
        let drawCount = 0;
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setDrawRange(0, drawCount);
        
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            linewidth: 2,
            transparent: true,
            opacity: 0.8
        });
        
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        
        // Current point indicator
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.5
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);
        
        // Mouse controls
        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let rotationX = 0;
        let rotationY = 0;
        
        document.addEventListener('mousedown', () => isMouseDown = true);
        document.addEventListener('mouseup', () => isMouseDown = false);
        
        document.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                targetRotationY += (e.clientX - mouseX) * 0.01;
                targetRotationX += (e.clientY - mouseY) * 0.01;
            }
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        document.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.05;
            camera.position.z = Math.max(20, Math.min(100, camera.position.z));
        });
        
        // Controls
        document.getElementById('sigma').addEventListener('input', (e) => {
            sigma = parseFloat(e.target.value);
            document.getElementById('sigmaValue').textContent = sigma.toFixed(1);
        });
        
        document.getElementById('rho').addEventListener('input', (e) => {
            rho = parseFloat(e.target.value);
            document.getElementById('rhoValue').textContent = rho.toFixed(1);
        });
        
        document.getElementById('beta').addEventListener('input', (e) => {
            beta = parseFloat(e.target.value);
            document.getElementById('betaValue').textContent = beta.toFixed(2);
        });
        
        document.getElementById('speed').addEventListener('input', (e) => {
            speedMultiplier = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = speedMultiplier.toFixed(1);
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            x = 0.1;
            y = 0;
            z = 0;
            drawCount = 0;
            geometry.setDrawRange(0, drawCount);
        });
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            drawCount = 0;
            geometry.setDrawRange(0, drawCount);
        });
        
        // Lorenz equations
        function lorenz() {
            const dx = sigma * (y - x) * dt;
            const dy = (x * (rho - z) - y) * dt;
            const dz = (x * y - beta * z) * dt;
            
            x += dx * speedMultiplier;
            y += dy * speedMultiplier;
            z += dz * speedMultiplier;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update Lorenz attractor
            for (let i = 0; i < 10; i++) {
                lorenz();
                
                if (drawCount < MAX_POINTS) {
                    positions[drawCount * 3] = x;
                    positions[drawCount * 3 + 1] = y;
                    positions[drawCount * 3 + 2] = z;
                    
                    // Color gradient based on position
                    const hue = (drawCount / MAX_POINTS) * 360;
                    const color = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
                    colors[drawCount * 3] = color.r;
                    colors[drawCount * 3 + 1] = color.g;
                    colors[drawCount * 3 + 2] = color.b;
                    
                    drawCount++;
                } else {
                    // Shift array when full
                    for (let j = 0; j < (MAX_POINTS - 1) * 3; j++) {
                        positions[j] = positions[j + 3];
                        colors[j] = colors[j + 3];
                    }
                    
                    positions[(MAX_POINTS - 1) * 3] = x;
                    positions[(MAX_POINTS - 1) * 3 + 1] = y;
                    positions[(MAX_POINTS - 1) * 3 + 2] = z;
                    
                    const hue = (Date.now() * 0.01) % 360;
                    const color = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
                    colors[(MAX_POINTS - 1) * 3] = color.r;
                    colors[(MAX_POINTS - 1) * 3 + 1] = color.g;
                    colors[(MAX_POINTS - 1) * 3 + 2] = color.b;
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.color.needsUpdate = true;
                geometry.setDrawRange(0, drawCount);
            }
            
            // Update sphere position
            sphere.position.set(x, y, z);
            
            // Smooth rotation
            rotationX += (targetRotationX - rotationX) * 0.05;
            rotationY += (targetRotationY - rotationY) * 0.05;
            
            // Apply rotation
            camera.position.x = Math.sin(rotationY) * 50;
            camera.position.z = Math.cos(rotationY) * 50;
            camera.position.y = 30 + Math.sin(rotationX) * 20;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>