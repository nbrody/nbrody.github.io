#!/usr/bin/env python3
"""
Monte Carlo Tree Search for infinite-order integer matrices.

Group generated by:
    A = ((3, 0), (0, 1/3))
    B = 1/8 * ((82, 2), (9, 1))

Key insight: [A, B]^2 = -I, so the commutator has order 4.

Strategy: Work in an integer representation by scaling. Track the "denominator
exponents" (powers of 2 and 3) and search for states with both = 0.
"""

import flint
from flint import fmpz, fmpz_mat
import random
import math
import time
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Tuple, Set
from collections import defaultdict


# ============================================================================
# Integer Matrix Representation
# ============================================================================
# 
# To avoid rationals, we represent matrices as (M, e2, e3) where:
#   actual matrix = M / (2^e2 * 3^e3)
# 
# A = ((3, 0), (0, 1/3)) = ((9, 0), (0, 1)) / 3  -> e2=0, e3=1
# B = ((82, 2), (9, 1)) / 8                      -> e2=3, e3=0
#
# When multiplying: (M1/d1) * (M2/d2) = (M1*M2) / (d1*d2)
# We need to reduce common factors.

def gcd_matrix(M: fmpz_mat) -> fmpz:
    """Compute GCD of all entries."""
    result = fmpz(0)
    for i in range(2):
        for j in range(2):
            result = fmpz.gcd(result, M[i, j])
    return result if result != 0 else fmpz(1)


def divide_by_p(M: fmpz_mat, p: int) -> Tuple[fmpz_mat, int]:
    """Divide matrix by highest power of p possible. Return (M/p^k, k)."""
    k = 0
    while True:
        # Check if all entries divisible by p
        divisible = True
        for i in range(2):
            for j in range(2):
                if int(M[i, j]) % p != 0:
                    divisible = False
                    break
            if not divisible:
                break
        
        if divisible:
            # Divide by p
            new_entries = [[int(M[i, j]) // p for j in range(2)] for i in range(2)]
            M = fmpz_mat(new_entries)
            k += 1
        else:
            break
    
    return M, k


@dataclass
class IntMatrix:
    """Integer matrix with tracked denominator factors."""
    M: fmpz_mat  # Numerator matrix
    e2: int      # Power of 2 in denominator
    e3: int      # Power of 3 in denominator
    
    def __post_init__(self):
        # Canonicalize: reduce common factors
        self._canonicalize()
    
    def _canonicalize(self):
        """Remove common factors of 2 and 3."""
        # Reduce by 2
        self.M, k2 = divide_by_p(self.M, 2)
        self.e2 -= k2
        
        # Reduce by 3
        self.M, k3 = divide_by_p(self.M, 3)
        self.e3 -= k3
        
        # Ensure non-negative exponents by scaling
        if self.e2 < 0:
            scale = 2 ** (-self.e2)
            entries = [[int(self.M[i, j]) * scale for j in range(2)] for i in range(2)]
            self.M = fmpz_mat(entries)
            self.e2 = 0
        
        if self.e3 < 0:
            scale = 3 ** (-self.e3)
            entries = [[int(self.M[i, j]) * scale for j in range(2)] for i in range(2)]
            self.M = fmpz_mat(entries)
            self.e3 = 0
    
    @property
    def is_integer(self) -> bool:
        """True if e2 = e3 = 0."""
        return self.e2 == 0 and self.e3 == 0
    
    @property
    def trace(self) -> int:
        """Trace (only meaningful if is_integer)."""
        if not self.is_integer:
            raise ValueError("Not an integer matrix")
        return int(self.M[0, 0]) + int(self.M[1, 1])
    
    @property
    def det(self) -> int:
        """Determinant (only meaningful if is_integer)."""
        if not self.is_integer:
            raise ValueError("Not an integer matrix")
        return int(self.M[0, 0] * self.M[1, 1] - self.M[0, 1] * self.M[1, 0])
    
    @property 
    def is_infinite_order(self) -> bool:
        """For SL(2, Z), infinite order iff |trace| > 2."""
        if not self.is_integer:
            return False
        tr = self.trace
        det = self.det
        if det != 1 and det != -1:
            return True  # Not in SL(2, Z)
        return abs(tr) > 2
    
    @property
    def is_identity(self) -> bool:
        if not self.is_integer:
            return False
        M = self.M
        return (M[0, 1] == 0 and M[1, 0] == 0 and 
                abs(int(M[0, 0])) == 1 and M[0, 0] == M[1, 1])
    
    def hash_key(self) -> tuple:
        """Hashable key for this matrix."""
        entries = tuple(int(self.M[i, j]) for i in range(2) for j in range(2))
        return (entries, self.e2, self.e3)
    
    def __mul__(self, other: 'IntMatrix') -> 'IntMatrix':
        """Matrix multiplication."""
        new_M = self.M * other.M
        new_e2 = self.e2 + other.e2
        new_e3 = self.e3 + other.e3
        return IntMatrix(new_M, new_e2, new_e3)
    
    def __str__(self) -> str:
        denom = f"2^{self.e2} * 3^{self.e3}" if self.e2 > 0 or self.e3 > 0 else "1"
        return f"1/{denom} * [[{self.M[0,0]}, {self.M[0,1]}], [{self.M[1,0]}, {self.M[1,1]}]]"


def create_generators() -> Dict[str, IntMatrix]:
    """Create generator matrices."""
    # A = ((3, 0), (0, 1/3)) = ((9, 0), (0, 1)) / 3
    A = IntMatrix(fmpz_mat([[9, 0], [0, 1]]), 0, 1)
    
    # A^-1 = ((1/3, 0), (0, 3)) = ((1, 0), (0, 9)) / 3
    Ai = IntMatrix(fmpz_mat([[1, 0], [0, 9]]), 0, 1)
    
    # B = ((82, 2), (9, 1)) / 8
    B = IntMatrix(fmpz_mat([[82, 2], [9, 1]]), 3, 0)
    
    # B^-1 = ((1, -2), (-9, 82)) / 8
    Bi = IntMatrix(fmpz_mat([[1, -2], [-9, 82]]), 3, 0)
    
    return {'a': A, 'ai': Ai, 'b': B, 'bi': Bi}


# ============================================================================
# Word Operations
# ============================================================================

INVERSE = {'a': 'ai', 'ai': 'a', 'b': 'bi', 'bi': 'b'}


def reduce_word(word: List[str]) -> List[str]:
    """Cancel adjacent inverses."""
    result = []
    for letter in word:
        if result and INVERSE[result[-1]] == letter:
            result.pop()
        else:
            result.append(letter)
    return result


def word_str(word: List[str]) -> str:
    return '.'.join(word) if word else 'e'


# ============================================================================
# MCTS Node
# ============================================================================

@dataclass
class Node:
    word: List[str]
    matrix: IntMatrix
    parent: Optional['Node'] = None
    children: Dict[str, 'Node'] = field(default_factory=dict)
    visits: int = 0
    reward: float = 0.0
    
    @property
    def is_terminal(self) -> bool:
        return len(self.word) >= 50
    
    @property
    def is_fully_expanded(self) -> bool:
        return len(self.children) == 4
    
    def ucb1(self, c: float = 1.414) -> float:
        if self.visits == 0:
            return float('inf')
        return self.reward / self.visits + c * math.sqrt(math.log(self.parent.visits) / self.visits)
    
    def best_child(self, c: float = 1.414) -> 'Node':
        return max(self.children.values(), key=lambda n: n.ucb1(c))


# ============================================================================
# MCTS Algorithm
# ============================================================================

class MCTS:
    def __init__(self):
        self.generators = create_generators()
        self.gen_keys = list(self.generators.keys())
        
        # Root: identity
        I = IntMatrix(fmpz_mat([[1, 0], [0, 1]]), 0, 0)
        self.root = Node(word=[], matrix=I)
        
        self.visited: Dict[tuple, List[str]] = {}
        self.solutions: List[Tuple[int, List[str], IntMatrix]] = []
        
    def score(self, mat: IntMatrix) -> float:
        """Score for MCTS - higher is better."""
        # Best score if infinite order integer
        if mat.is_integer:
            if mat.is_infinite_order and not mat.is_identity:
                return 1000.0
            return 100.0 - abs(mat.trace)  # Integer but finite order
        
        # Score based on closeness to integer
        # Lower exponents = closer to integer
        return 10.0 / (1 + mat.e2 + mat.e3)
    
    def select(self, node: Node) -> Node:
        while not node.is_terminal and node.is_fully_expanded:
            node = node.best_child()
        return node
    
    def expand(self, node: Node) -> Node:
        if node.is_terminal:
            return node
        
        unexpanded = [g for g in self.gen_keys if g not in node.children]
        if not unexpanded:
            return node
        
        action = random.choice(unexpanded)
        new_word = reduce_word(node.word + [action])
        
        if not new_word:
            new_matrix = IntMatrix(fmpz_mat([[1, 0], [0, 1]]), 0, 0)
        else:
            new_matrix = node.matrix * self.generators[action]
        
        child = Node(word=new_word, matrix=new_matrix, parent=node)
        node.children[action] = child
        
        # Check for solution
        if new_matrix.is_integer and new_matrix.is_infinite_order and not new_matrix.is_identity:
            self._record_solution(new_word, new_matrix)
        
        return child
    
    def simulate(self, node: Node, depth: int = 30) -> float:
        """Random rollout."""
        word = list(node.word)
        matrix = node.matrix
        
        best_score = self.score(matrix)
        
        for _ in range(depth):
            if len(word) >= 50:
                break
            
            action = random.choice(self.gen_keys)
            word = reduce_word(word + [action])
            
            if not word:
                matrix = IntMatrix(fmpz_mat([[1, 0], [0, 1]]), 0, 0)
            else:
                matrix = matrix * self.generators[action]
            
            s = self.score(matrix)
            best_score = max(best_score, s)
            
            if matrix.is_integer and matrix.is_infinite_order and not matrix.is_identity:
                self._record_solution(word, matrix)
                return 1000.0
        
        return best_score
    
    def backprop(self, node: Node, reward: float):
        while node is not None:
            node.visits += 1
            node.reward += reward
            node = node.parent
    
    def _record_solution(self, word: List[str], matrix: IntMatrix):
        key = matrix.hash_key()
        if key in self.visited:
            return
        
        self.visited[key] = word
        self.solutions.append((len(word), list(word), matrix))
        
        print(f"\n{'='*60}")
        print(f"SOLUTION FOUND!")
        print(f"Word: {word_str(word)}")
        print(f"Length: {len(word)}")
        print(f"Matrix: {matrix}")
        print(f"Trace: {matrix.trace}")
        print(f"Det: {matrix.det}")
        print(f"{'='*60}\n")
    
    def search(self, iterations: int = 50000) -> List:
        print(f"Starting MCTS with {iterations} iterations...")
        start = time.time()
        
        for i in range(iterations):
            node = self.select(self.root)
            node = self.expand(node)
            reward = self.simulate(node)
            self.backprop(node, reward)
            
            if (i + 1) % 5000 == 0:
                elapsed = time.time() - start
                print(f"Iteration {i+1}/{iterations} - "
                      f"{(i+1)/elapsed:.0f} iter/s - "
                      f"Solutions: {len(self.solutions)}")
        
        return sorted(self.solutions, key=lambda x: x[0])


# ============================================================================
# Targeted Beam Search
# ============================================================================

def beam_search_targeted(beam_width: int = 5000, max_depth: int = 30) -> List:
    """
    Beam search specifically targeting integer matrices.
    
    Key insight: to get an integer matrix, we need both e2=0 and e3=0.
    We prioritize states that are close to this goal.
    """
    print(f"\nRunning targeted beam search (width={beam_width}, depth={max_depth})...")
    
    generators = create_generators()
    gen_keys = list(generators.keys())
    
    # Identity
    I = IntMatrix(fmpz_mat([[1, 0], [0, 1]]), 0, 0)
    
    # Beam: list of (score, word, matrix)
    # Score = e2 + e3 (lower is better, 0 means integer)
    beam = [(0, [], I)]
    visited: Set[tuple] = set()
    solutions = []
    
    for depth in range(max_depth):
        candidates = []
        
        for _, word, matrix in beam:
            for action in gen_keys:
                new_word = reduce_word(word + [action])
                
                if not new_word:
                    continue  # Reduced to identity
                
                new_matrix = matrix * generators[action]
                key = new_matrix.hash_key()
                
                if key in visited:
                    continue
                visited.add(key)
                
                # Check for solution
                if new_matrix.is_integer:
                    if new_matrix.is_infinite_order and not new_matrix.is_identity:
                        solutions.append((len(new_word), new_word, new_matrix))
                        print(f"  SOLUTION at depth {depth+1}: {word_str(new_word)}")
                        print(f"    Trace: {new_matrix.trace}")
                
                score = new_matrix.e2 + new_matrix.e3
                candidates.append((score, new_word, new_matrix))
        
        # Sort by score (lower e2+e3 is better)
        candidates.sort(key=lambda x: (x[0], len(x[1])))
        beam = candidates[:beam_width]
        
        if not beam:
            print(f"  Exhausted at depth {depth+1}")
            break
        
        if (depth + 1) % 5 == 0:
            best_score = beam[0][0] if beam else float('inf')
            # Count integer candidates
            int_count = sum(1 for s, _, _ in beam if s == 0)
            print(f"  Depth {depth+1}: {len(beam)} nodes, best_score={best_score}, integers={int_count}")
    
    print(f"Beam search found {len(solutions)} solutions")
    return solutions


# ============================================================================
# Main
# ============================================================================

def main():
    print("="*60)
    print("Infinite-Order Integer Matrix Search (v2)")
    print("="*60)
    print()
    print("Generators:")
    print("  A = ((3, 0), (0, 1/3))")
    print("  B = 1/8 * ((82, 2), (9, 1))")
    print()
    
    # Verify generators
    gens = create_generators()
    print("Verifying generators:")
    for name, m in gens.items():
        print(f"  {name}: {m}")
    print()
    
    # Verify commutator relation
    print("Verifying [A,B]^2 = -I:")
    C = gens['a'] * gens['b'] * gens['ai'] * gens['bi']
    C2 = C * C
    print(f"  [A,B]^2 = {C2}")
    print(f"  Is -I? {C2.is_integer and C2.trace == -2}")
    print()
    
    # Run targeted beam search first
    beam_solutions = beam_search_targeted(beam_width=10000, max_depth=25)
    
    # Then run MCTS for exploration
    print()
    mcts = MCTS()
    mcts_solutions = mcts.search(iterations=30000)
    
    # Summary
    all_solutions = beam_solutions + mcts_solutions
    
    print("\n" + "="*60)
    print("SUMMARY")
    print("="*60)
    
    if all_solutions:
        # Deduplicate
        unique = {}
        for length, word, matrix in all_solutions:
            key = matrix.hash_key()
            if key not in unique or len(word) < len(unique[key][1]):
                unique[key] = (length, word, matrix)
        
        solutions = sorted(unique.values(), key=lambda x: x[0])
        
        print(f"\nFound {len(solutions)} unique infinite-order integer matrices:")
        for length, word, matrix in solutions[:10]:
            print(f"\n  Length {length}: {word_str(word)}")
            print(f"  Matrix: {matrix}")
            print(f"  Trace: {matrix.trace}, Det: {matrix.det}")
    else:
        print("\nNo infinite-order integer matrices found.")
        print("\nThis suggests that the group G = <A, B> may only intersect")
        print("SL(2, Z) in {Â±I}. The relation [A,B]^2 = -I implies the group")
        print("is a central extension that might not contain hyperbolic integer elements.")


if __name__ == "__main__":
    main()
